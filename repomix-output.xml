This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.swift
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
StressMonitor/
  StressMonitor/
    Components/
      Character/
        CharacterAnimationModifier.swift
        StressCharacterCard.swift
      Charts/
        AccessibleStressTrendChart.swift
        SparklineChart.swift
      Dashboard/
        BreathingExerciseCTA.swift
    Models/
      Base/
        ObservableModel.swift
      ExportModels.swift
      HeartRateSample.swift
      HRVMeasurement.swift
      PersonalBaseline.swift
      StressBuddyMood.swift
      StressCategory.swift
      StressMeasurement.swift
      StressResult.swift
      WidgetSharedData.swift
    Services/
      Algorithm/
        BaselineCalculator.swift
        StressCalculator.swift
      Background/
        HealthBackgroundScheduler.swift
        NotificationManager.swift
      CloudKit/
        CloudKitManager.swift
        CloudKitSchema.swift
        CloudKitSyncEngine.swift
      Connectivity/
        PhoneConnectivityManager.swift
      DataManagement/
        CloudKitResetService.swift
        CSVGenerator.swift
        DataDeleter.swift
        DataDeleterService.swift
        DataExporter.swift
        DataManagementService.swift
        DataManagementUtilities.swift
        JSONGenerator.swift
        LocalDataWipeService.swift
      HealthKit/
        HealthKitManager.swift
      Protocols/
        CloudKitServiceProtocol.swift
        HealthKitServiceProtocol.swift
        StressAlgorithmServiceProtocol.swift
        StressRepositoryProtocol.swift
      Repository/
        StressRepository.swift
      Sync/
        ConflictResolver.swift
        SyncManager.swift
      InsightGeneratorService.swift
      MockServices.swift
    Theme/
      Color+Extensions.swift
      Color+Wellness.swift
      DesignTokens.swift
      Font+WellnessType.swift
      Gradients.swift
    Utilities/
      AccessibilityModifiers.swift
      Animation+Wellness.swift
      AnimationPresets.swift
      ColorBlindnessSimulator.swift
      DynamicTypeScaling.swift
      HighContrastModifier.swift
      PatternOverlay.swift
    ViewModels/
      DataManagementViewModel.swift
      StressViewModel.swift
    Views/
      Breathing/
        Components/
          BeforeAfterChart.swift
          BreathingCircleView.swift
        BreathingExerciseView.swift
        BreathingSessionView.swift
        BreathingSummaryView.swift
        BreathingViewModel.swift
      Components/
        HapticManager.swift
        MeasureButton.swift
        PrimaryMetricCard.swift
      Dashboard/
        Components/
          AIInsightCard.swift
          DailyTimelineView.swift
          DashboardInsightCard.swift
          DateHeaderView.swift
          EmptyDashboardView.swift
          HealthDataSection.swift
          LearningPhaseCard.swift
          MetricCardView.swift
          MiniLineChartView.swift
          NoDataCard.swift
          PermissionErrorCard.swift
          PremiumLockOverlay.swift
          QuickActionCard.swift
          QuickStatCard.swift
          SelfNoteCard.swift
          StatusBadgeView.swift
          StressOverTimeChart.swift
          StressRingView.swift
          StressStatusBadge.swift
          TripleMetricRow.swift
          WeeklyInsightCard.swift
        DashboardViewModel.swift
        StressDashboardView.swift
      DesignSystem/
        Components/
          Badge.swift
          Buttons.swift
          EmptyStateView.swift
          GlassCard.swift
          LoadingView.swift
          ProgressRing.swift
          SectionHeader.swift
          StatCard.swift
        Shadows.swift
        Spacing.swift
        Typography.swift
      History/
        Components/
          FactorProgressBar.swift
          HistoryRowView.swift
          RecommendationCard.swift
          StressGaugeView.swift
        DetailViewModel.swift
        HistoryViewModel.swift
        MeasurementDetailView.swift
        MeasurementHistoryView.swift
      Journal/
        NoteEntryView.swift
      Onboarding/
        HealthKitErrorView.swift
        HealthKitErrorViewModel.swift
        OnboardingBaselineCalibrationView.swift
        OnboardingBaselineCalibrationViewModel.swift
        OnboardingHealthSyncView.swift
        OnboardingHealthSyncViewModel.swift
        OnboardingSuccessView.swift
        OnboardingSuccessViewModel.swift
        OnboardingWelcomeView.swift
        OnboardingWelcomeViewModel.swift
      Settings/
        DataManagement/
          Components/
            DeleteConfirmationView.swift
            ExportProgressView.swift
          DataDeleteView.swift
          DataExportView.swift
        SettingsView.swift
        SettingsViewModel.swift
      Trends/
        Components/
          DistributionBarView.swift
          InsightCard.swift
          LineChartView.swift
          TimeRangePicker.swift
        TrendsView.swift
        TrendsViewModel.swift
      DashboardView.swift
      HistoryView.swift
      MainTabView.swift
    StressMonitorApp.swift
  StressMonitorTests/
    Components/
      Charts/
        AccessibleStressTrendChartTests.swift
        SparklineChartTests.swift
      StressCharacterCardTests.swift
    Mocks/
      MockCloudKitManager.swift
    Models/
      StressBuddyMoodTests.swift
    TestHelpers/
      TestDataFactory.swift
    Theme/
      FontWellnessTypeTests.swift
      GradientsTests.swift
    Utilities/
      AnimationWellnessTests.swift
      ColorBlindnessSimulatorTests.swift
      DynamicTypeScalingTests.swift
      HapticManagerTests.swift
      HighContrastTests.swift
      PatternOverlayTests.swift
    Views/
      Breathing/
        BreathingExerciseViewTests.swift
      AccessibilityLabelsTests.swift
    BaselineCalculatorTests.swift
    HealthKitErrorViewModelTests.swift
    HealthKitManagerTests.swift
    OnboardingBaselineCalibrationViewModelTests.swift
    OnboardingHealthSyncViewModelTests.swift
    OnboardingSuccessViewModelTests.swift
    OnboardingWelcomeViewModelTests.swift
    StressCalculatorTests.swift
    StressMonitorTests.swift
    StressRepositoryTests.swift
    StressViewModelTests.swift
  StressMonitorUITests/
    StressMonitorUITests.swift
    StressMonitorUITestsLaunchTests.swift
  StressMonitorWatch Watch App/
    Complications/
      Intents/
        OpenWatchAppIntent.swift
      Providers/
        CircularComplicationProvider.swift
        InlineComplicationProvider.swift
        RectangularComplicationProvider.swift
      Services/
        ComplicationDataProvider.swift
      Views/
        CircularStressView.swift
        InlineStressView.swift
        RectangularStressView.swift
      ComplicationBundle.swift
    Models/
      HeartRateSample.swift
      HRVMeasurement.swift
      PersonalBaseline.swift
      StressCategory.swift
      StressMeasurement.swift
      StressResult.swift
    Services/
      CloudKit/
        WatchCloudKitManager.swift
      CloudKitSchema.swift
      CloudKitServiceProtocol.swift
      HealthKitServiceProtocol.swift
      StressAlgorithmServiceProtocol.swift
      StressCalculator.swift
      WatchConnectivityManager.swift
      WatchHealthKitManager.swift
    Theme/
      Color+Extensions.swift
      WatchDesignTokens.swift
    ViewModels/
      WatchStressViewModel.swift
    Views/
      Components/
        CompactStressView.swift
    ContentView.swift
    StressMonitorWatchApp.swift
  StressMonitorWatch Watch AppTests/
    StressMonitorWatch_Watch_AppTests.swift
  StressMonitorWatch Watch AppUITests/
    StressMonitorWatch_Watch_AppUITests.swift
    StressMonitorWatch_Watch_AppUITestsLaunchTests.swift
  StressMonitorWidget/
    Intents/
      UpdateWidgetIntent.swift
    Models/
      WidgetDataProvider.swift
    Providers/
      StressWidgetProvider.swift
    Views/
      LargeWidgetView.swift
      MediumWidgetView.swift
      SmallWidgetView.swift
    StressMonitorWidget.swift
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="StressMonitor/StressMonitor/Components/Character/CharacterAnimationModifier.swift">
import SwiftUI

// MARK: - Character Animation Modifier

/// Applies mood-specific animation to Stress Buddy character
/// All animations respect Reduce Motion accessibility setting
struct CharacterAnimationModifier: ViewModifier {
    let mood: StressBuddyMood
    @Environment(\.accessibilityReduceMotion) var reduceMotion

    @State private var breathingScale: CGFloat = 1.0
    @State private var fidgetOffset: CGSize = .zero
    @State private var shakeRotation: Double = 0
    @State private var dizzyRotation: Double = 0
    @State private var fidgetTimer: Timer?

    func body(content: Content) -> some View {
        content
            .scaleEffect(mood == .sleeping ? breathingScale : 1.0)
            .offset(mood == .concerned ? fidgetOffset : .zero)
            .rotationEffect(mood == .worried ? .degrees(shakeRotation) : .zero)
            .rotationEffect(mood == .overwhelmed ? .degrees(dizzyRotation) : .zero)
            .onDisappear {
                fidgetTimer?.invalidate()
                fidgetTimer = nil
            }
            .onAppear {
                if !reduceMotion {
                    applyAnimation()
                }
            }
    }

    // MARK: - Animation Implementations

    private func applyAnimation() {
        switch mood {
        case .sleeping:
            startBreathing()
        case .calm:
            // No animation for calm state
            break
        case .concerned:
            startFidget()
        case .worried:
            startShake()
        case .overwhelmed:
            startDizzy()
        }
    }

    /// Breathing animation: Slow scale 0.95-1.05 over 4s
    private func startBreathing() {
        withAnimation(.breathing(reduceMotion: reduceMotion)) {
            breathingScale = 1.05
        }
    }

    /// Fidget animation: Random offset ±3pt every 2-3s
    private func startFidget() {
        fidgetTimer = Timer.scheduledTimer(withTimeInterval: 2.5, repeats: true) { _ in
            guard !self.reduceMotion else { return }

            let randomX = CGFloat.random(in: -3...3)
            let randomY = CGFloat.random(in: -3...3)

            withAnimation(.fidget(reduceMotion: false)) {
                self.fidgetOffset = CGSize(width: randomX, height: randomY)
            }

            // Reset after delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                withAnimation(.fidget(reduceMotion: false)) {
                    self.fidgetOffset = .zero
                }
            }
        }
    }

    /// Shake animation: Rotation ±5° over 0.5s
    private func startShake() {
        withAnimation(.shake(reduceMotion: reduceMotion)) {
            shakeRotation = 5
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            withAnimation(.shake(reduceMotion: reduceMotion)) {
                shakeRotation = -5
            }
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            withAnimation(.shake(reduceMotion: reduceMotion)) {
                shakeRotation = 0
            }
        }
    }

    /// Dizzy animation: Continuous rotation 360° over 1.5s
    private func startDizzy() {
        withAnimation(.dizzy(reduceMotion: reduceMotion)) {
            dizzyRotation = 360
        }
    }
}

extension View {
    /// Apply character animation based on mood
    /// Respects Reduce Motion accessibility setting
    /// - Parameter mood: Stress Buddy mood
    /// - Returns: View with animation applied
    func characterAnimation(for mood: StressBuddyMood) -> some View {
        modifier(CharacterAnimationModifier(mood: mood))
    }
}

// MARK: - Accessory Animation Modifier

/// Applies floating animation to character accessories
struct AccessoryAnimationModifier: ViewModifier {
    let index: Int // For staggered animation
    @Environment(\.accessibilityReduceMotion) var reduceMotion

    @State private var floatOffset: CGFloat = 0
    @State private var rotation: Double = 0

    func body(content: Content) -> some View {
        content
            .offset(y: floatOffset)
            .rotationEffect(.degrees(rotation))
            .onAppear {
                if !reduceMotion {
                    startFloating()
                }
            }
    }

    private func startFloating() {
        // Stagger animation based on index
        let delay = Double(index) * 0.2

        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
            withAnimation(
                .easeInOut(duration: 2.0)
                    .repeatForever(autoreverses: true)
            ) {
                floatOffset = -5
                rotation = Double.random(in: -10...10)
            }
        }
    }
}

extension View {
    /// Apply floating animation to accessory
    /// - Parameter index: Index for staggered timing
    /// - Returns: View with floating animation
    func accessoryAnimation(index: Int = 0) -> some View {
        modifier(AccessoryAnimationModifier(index: index))
    }
}
</file>

<file path="StressMonitor/StressMonitor/Components/Charts/AccessibleStressTrendChart.swift">
import SwiftUI
import Charts

// MARK: - Accessible Stress Trend Chart

/// Line chart with VoiceOver data table alternative
/// Implements WCAG 2.1 AA accessibility requirements for data visualization
struct AccessibleStressTrendChart: View {
    let data: [StressMeasurement]
    let timeRange: TimeRange
    @AccessibilityFocusState private var isChartFocused: Bool
    @Environment(\.accessibilityVoiceOverEnabled) var voiceOverEnabled

    enum TimeRange: String, CaseIterable {
        case day = "24H"
        case week = "7D"
        case month = "4W"

        var description: String {
            switch self {
            case .day: return "24 hours"
            case .week: return "7 days"
            case .month: return "4 weeks"
            }
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: DesignTokens.Spacing.md) {
            chartHeader

            if data.isEmpty {
                emptyState
            } else {
                if voiceOverEnabled {
                    dataTableView
                } else {
                    visualChartView
                }
            }
        }
        .padding(DesignTokens.Spacing.md)
        .background(Color.Wellness.surface)
        .cornerRadius(DesignTokens.Layout.cornerRadius)
    }

    // MARK: - Chart Header

    private var chartHeader: some View {
        VStack(alignment: .leading, spacing: DesignTokens.Spacing.sm) {
            Text("Stress Trend")
                .font(Typography.headline)
                .fontWeight(.semibold)
                .accessibilityAddTraits(.isHeader)

            if let stats = calculateStats() {
                HStack(spacing: DesignTokens.Spacing.md) {
                    statLabel(title: "Avg", value: "\(Int(stats.average))")
                    statLabel(title: "Min", value: "\(Int(stats.min))")
                    statLabel(title: "Max", value: "\(Int(stats.max))")
                }
                .font(Typography.caption1)
                .foregroundStyle(.secondary)
            }
        }
    }

    private func statLabel(title: String, value: String) -> some View {
        HStack(spacing: 4) {
            Text(title)
            Text(value)
                .fontWeight(.semibold)
                .monospacedDigit()
        }
    }

    // MARK: - Visual Chart

    @ViewBuilder
    private var visualChartView: some View {
        Chart(data) { measurement in
            LineMark(
                x: .value("Time", measurement.timestamp),
                y: .value("Stress", measurement.stressLevel)
            )
            .foregroundStyle(Color.Wellness.calmBlue)
            .interpolationMethod(.catmullRom)
            .lineStyle(StrokeStyle(lineWidth: 2))

            AreaMark(
                x: .value("Time", measurement.timestamp),
                y: .value("Stress", measurement.stressLevel)
            )
            .foregroundStyle(
                LinearGradient(
                    colors: [
                        Color.Wellness.calmBlue.opacity(0.3),
                        Color.Wellness.calmBlue.opacity(0.1),
                        Color.Wellness.calmBlue.opacity(0)
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
        }
        .frame(height: 200)
        .chartYScale(domain: 0...100)
        .chartXAxis {
            AxisMarks(position: .bottom, values: .automatic(desiredCount: 4)) { _ in
                AxisGridLine(stroke: StrokeStyle(lineWidth: 0.5))
                    .foregroundStyle(.secondary.opacity(0.3))
                AxisValueLabel(format: .dateTime.hour().minute())
                    .font(Typography.caption2)
                    .foregroundStyle(.secondary)
            }
        }
        .chartYAxis {
            AxisMarks(position: .leading, values: .stride(by: 25)) { value in
                AxisGridLine(stroke: StrokeStyle(lineWidth: 0.5))
                    .foregroundStyle(.secondary.opacity(0.3))
                AxisValueLabel()
                    .font(Typography.caption2)
                    .foregroundStyle(.secondary)
            }
        }
        .accessibilityHidden(true)
    }

    // MARK: - Data Table (VoiceOver Alternative)

    @ViewBuilder
    private var dataTableView: some View {
        VStack(alignment: .leading, spacing: DesignTokens.Spacing.sm) {
            Text("Stress Measurements")
                .font(Typography.callout)
                .fontWeight(.semibold)
                .accessibilityAddTraits(.isHeader)

            ScrollView {
                VStack(alignment: .leading, spacing: DesignTokens.Spacing.xs) {
                    ForEach(data) { measurement in
                        dataTableRow(measurement)
                    }
                }
            }
            .frame(maxHeight: 250)
        }
        .accessibilityElement(children: .contain)
        .accessibilityLabel("Stress trend data table")
        .accessibilityHint("Shows \(data.count) measurements over \(timeRange.description)")
    }

    private func dataTableRow(_ measurement: StressMeasurement) -> some View {
        HStack {
            VStack(alignment: .leading, spacing: 2) {
                Text(measurement.timestamp, format: .dateTime.month().day().hour().minute())
                    .font(Typography.caption1)
                    .foregroundStyle(.secondary)

                Text(measurement.category.rawValue.capitalized)
                    .font(Typography.caption2)
                    .foregroundStyle(measurement.category.color)
            }

            Spacer()

            Text("\(Int(measurement.stressLevel))")
                .font(Typography.callout)
                .fontWeight(.semibold)
                .monospacedDigit()
                .foregroundStyle(.primary)
        }
        .padding(DesignTokens.Spacing.sm)
        .background(Color.Wellness.background)
        .cornerRadius(8)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(measurement.timestamp.formatted(.dateTime.month().day().hour().minute())), \(Int(measurement.stressLevel)) stress level, \(measurement.category.rawValue)")
    }

    // MARK: - Empty State

    private var emptyState: some View {
        VStack(spacing: DesignTokens.Spacing.md) {
            Image(systemName: "chart.line.uptrend.xyaxis")
                .font(.system(size: 48))
                .foregroundStyle(.secondary)

            Text("No data available")
                .font(Typography.callout)
                .foregroundStyle(.secondary)
        }
        .frame(height: 200)
        .frame(maxWidth: .infinity)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("No stress trend data available for \(timeRange.description)")
    }

    // MARK: - Statistics

    private func calculateStats() -> (average: Double, min: Double, max: Double)? {
        guard !data.isEmpty else { return nil }

        let levels = data.map { $0.stressLevel }
        let sum = levels.reduce(0, +)
        let average = sum / Double(levels.count)
        let min = levels.min() ?? 0
        let max = levels.max() ?? 0

        return (average, min, max)
    }
}

// MARK: - Preview

#Preview("With Data") {
    let measurements = (0..<20).map { i in
        StressMeasurement(
            timestamp: Calendar.current.date(byAdding: .hour, value: -i, to: Date())!,
            stressLevel: Double.random(in: 20...80),
            hrv: 50,
            restingHeartRate: 70
        )
    }

    AccessibleStressTrendChart(
        data: measurements,
        timeRange: .day
    )
    .padding()
    .background(Color.Wellness.background)
}

#Preview("Empty State") {
    AccessibleStressTrendChart(
        data: [],
        timeRange: .week
    )
    .padding()
    .background(Color.Wellness.background)
}

#Preview("VoiceOver Mode") {
    let measurements = (0..<5).map { i in
        StressMeasurement(
            timestamp: Calendar.current.date(byAdding: .hour, value: -i, to: Date())!,
            stressLevel: Double.random(in: 20...80),
            hrv: 50,
            restingHeartRate: 70
        )
    }

    AccessibleStressTrendChart(
        data: measurements,
        timeRange: .day
    )
    .padding()
    .background(Color.Wellness.background)
}
</file>

<file path="StressMonitor/StressMonitor/Components/Charts/SparklineChart.swift">
import SwiftUI
import Charts

// MARK: - Sparkline Chart

/// Mini trend chart for quick stats cards
/// Shows last 7 data points in compact 60x120pt format
/// Full Reduce Motion support with static chart
struct SparklineChart: View {
    let data: [DataPoint]
    let tintColor: Color
    @Environment(\.accessibilityReduceMotion) var reduceMotion

    struct DataPoint: Identifiable {
        let id = UUID()
        let value: Double
        let timestamp: Date
    }

    var body: some View {
        Group {
            if data.isEmpty {
                emptyState
            } else {
                chartView
            }
        }
        .frame(width: 120, height: 60)
    }

    // MARK: - Chart View

    @ViewBuilder
    private var chartView: some View {
        Chart(data) { point in
            LineMark(
                x: .value("Time", point.timestamp),
                y: .value("Value", point.value)
            )
            .foregroundStyle(tintColor)
            .interpolationMethod(.catmullRom)
            .lineStyle(StrokeStyle(lineWidth: 2))

            AreaMark(
                x: .value("Time", point.timestamp),
                y: .value("Value", point.value)
            )
            .foregroundStyle(
                LinearGradient(
                    colors: [
                        tintColor.opacity(0.3),
                        tintColor.opacity(0.1),
                        tintColor.opacity(0)
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
        }
        .chartXAxis(.hidden)
        .chartYAxis(.hidden)
        .chartYScale(domain: yAxisDomain())
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Trend chart")
        .accessibilityValue(trendDescription)
        .accessibilityHint("Shows \(data.count) recent measurements")
    }

    // MARK: - Empty State

    private var emptyState: some View {
        Rectangle()
            .fill(.clear)
            .overlay(
                Image(systemName: "chart.line.flattrend.xyaxis")
                    .font(.caption)
                    .foregroundStyle(.secondary.opacity(0.5))
            )
            .accessibilityLabel("No trend data available")
    }

    // MARK: - Helpers

    private func yAxisDomain() -> ClosedRange<Double> {
        guard !data.isEmpty else { return 0...100 }

        let values = data.map { $0.value }
        let min = values.min() ?? 0
        let max = values.max() ?? 100

        let padding = (max - min) * 0.2
        return (min - padding)...(max + padding)
    }

    private var trendDescription: String {
        guard data.count >= 2 else { return "Insufficient data" }

        let firstValue = data.first?.value ?? 0
        let lastValue = data.last?.value ?? 0
        let change = lastValue - firstValue

        if change > 5 {
            return "Trending up by \(Int(abs(change))) points"
        } else if change < -5 {
            return "Trending down by \(Int(abs(change))) points"
        } else {
            return "Stable trend"
        }
    }
}

// MARK: - Preview

#Preview("Upward Trend") {
    VStack(spacing: 16) {
        let data = (0..<7).map { i in
            SparklineChart.DataPoint(
                value: Double(30 + i * 5),
                timestamp: Calendar.current.date(byAdding: .day, value: -6 + i, to: Date())!
            )
        }

        SparklineChart(data: data, tintColor: .green)
            .padding()
            .background(Color.Wellness.surface)
            .cornerRadius(12)
    }
    .padding()
    .background(Color.Wellness.background)
}

#Preview("Downward Trend") {
    VStack(spacing: 16) {
        let data = (0..<7).map { i in
            SparklineChart.DataPoint(
                value: Double(70 - i * 5),
                timestamp: Calendar.current.date(byAdding: .day, value: -6 + i, to: Date())!
            )
        }

        SparklineChart(data: data, tintColor: .red)
            .padding()
            .background(Color.Wellness.surface)
            .cornerRadius(12)
    }
    .padding()
    .background(Color.Wellness.background)
}

#Preview("Empty") {
    SparklineChart(data: [], tintColor: .blue)
        .padding()
        .background(Color.Wellness.surface)
        .cornerRadius(12)
        .padding()
        .background(Color.Wellness.background)
}

#Preview("Reduce Motion") {
    VStack(spacing: 16) {
        let data = (0..<7).map { i in
            SparklineChart.DataPoint(
                value: Double.random(in: 40...80),
                timestamp: Calendar.current.date(byAdding: .day, value: -6 + i, to: Date())!
            )
        }

        SparklineChart(data: data, tintColor: .blue)
            .padding()
            .background(Color.Wellness.surface)
            .cornerRadius(12)
    }
    .padding()
    .background(Color.Wellness.background)
}
</file>

<file path="StressMonitor/StressMonitor/Components/Dashboard/BreathingExerciseCTA.swift">
import SwiftUI

// MARK: - Breathing Exercise CTA Card

/// Call-to-action card for breathing exercise
/// Displayed on dashboard to encourage stress relief
struct BreathingExerciseCTA: View {
    let action: () -> Void

    var body: some View {
        Button(action: handleTap) {
            HStack(spacing: DesignTokens.Spacing.md) {
                iconSection

                VStack(alignment: .leading, spacing: DesignTokens.Spacing.xs) {
                    Text("Try Breathing Exercise")
                        .font(Typography.headline)
                        .fontWeight(.semibold)
                        .foregroundStyle(.primary)

                    Text("4-7-8 technique to reduce stress")
                        .font(Typography.caption1)
                        .foregroundStyle(.secondary)
                        .lineLimit(2)
                }

                Spacer()

                Image(systemName: "chevron.right")
                    .font(.callout)
                    .foregroundStyle(.secondary)
            }
            .padding(DesignTokens.Spacing.md)
            .background(
                LinearGradient(
                    colors: [
                        Color.Wellness.calmBlue.opacity(0.1),
                        Color.Wellness.healthGreen.opacity(0.05)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .overlay(
                RoundedRectangle(cornerRadius: DesignTokens.Layout.cornerRadius)
                    .strokeBorder(Color.Wellness.calmBlue.opacity(0.2), lineWidth: 1)
            )
            .cornerRadius(DesignTokens.Layout.cornerRadius)
        }
        .buttonStyle(BreathingCTAButtonStyle())
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Try breathing exercise")
        .accessibilityHint("4-7-8 breathing technique to help reduce stress. Double tap to start.")
        .accessibilityAddTraits(.isButton)
    }

    // MARK: - Icon Section

    private var iconSection: some View {
        ZStack {
            Circle()
                .fill(Color.Wellness.calmBlue.opacity(0.15))
                .frame(width: 50, height: 50)

            Image(systemName: "wind")
                .font(.title2)
                .foregroundStyle(Color.Wellness.calmBlue)
        }
    }

    // MARK: - Actions

    private func handleTap() {
        HapticManager.shared.buttonPress()
        action()
    }
}

// MARK: - Button Style

struct BreathingCTAButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.98 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}

// MARK: - Preview

#Preview {
    VStack(spacing: 16) {
        BreathingExerciseCTA {
            print("Breathing exercise tapped")
        }

        BreathingExerciseCTA {
            print("Breathing exercise tapped")
        }
        .environment(\.colorScheme, .dark)
    }
    .padding()
    .background(Color.Wellness.background)
}
</file>

<file path="StressMonitor/StressMonitor/Models/Base/ObservableModel.swift">
import Foundation
import Observation

@Observable
class ObservableModel {
    var isLoading = false
    var errorMessage: String?

    func setError(_ message: String) {
        errorMessage = message
    }

    func clearError() {
        errorMessage = nil
    }
}
</file>

<file path="StressMonitor/StressMonitor/Models/ExportModels.swift">
import Foundation

// MARK: - Export Metadata

/// Metadata included in data exports
public struct ExportMetadata: Codable, Sendable {
    let exportDate: Date
    let deviceName: String
    let appVersion: String
    let measurementCount: Int
    let startDate: Date
    let endDate: Date
    let format: DataExportFormat

    var dateRange: ClosedRange<Date> {
        startDate...endDate
    }

    private enum CodingKeys: String, CodingKey {
        case exportDate
        case deviceName
        case appVersion
        case measurementCount
        case startDate
        case endDate
        case format
    }

    public init(
        exportDate: Date,
        deviceName: String,
        appVersion: String,
        measurementCount: Int,
        startDate: Date,
        endDate: Date,
        format: DataExportFormat
    ) {
        self.exportDate = exportDate
        self.deviceName = deviceName
        self.appVersion = appVersion
        self.measurementCount = measurementCount
        self.startDate = startDate
        self.endDate = endDate
        self.format = format
    }
}

// MARK: - Data Export Format

public enum DataExportFormat: String, Codable {
    case csv
    case json

    public var fileExtension: String {
        rawValue
    }

    public var mimeType: String {
        switch self {
        case .csv: return "text/csv"
        case .json: return "application/json"
        }
    }
}

// MARK: - JSON Export Structure

/// Complete JSON export structure
public struct JSONExport: Codable, Sendable {
    let metadata: ExportMetadata
    let baseline: BaselineData
    let measurements: [StressSnapshot]
    let summary: ExportSummary

    init(
        metadata: ExportMetadata,
        baseline: BaselineData,
        measurements: [StressSnapshot],
        summary: ExportSummary
    ) {
        self.metadata = metadata
        self.baseline = baseline
        self.measurements = measurements
        self.summary = summary
    }
}

// MARK: - Baseline Data

/// Personal baseline data for export
public struct BaselineData: Codable, Sendable {
    public let restingHeartRate: Double
    public let baselineHRV: Double
    public let lastUpdated: Date

    internal init(from baseline: PersonalBaseline) {
        self.restingHeartRate = baseline.restingHeartRate
        self.baselineHRV = baseline.baselineHRV
        self.lastUpdated = baseline.lastUpdated
    }
}

// MARK: - Stress Snapshot

/// Single stress measurement snapshot for export
public struct StressSnapshot: Codable, Sendable {
    let timestamp: Date
    let stressLevel: Double
    let category: String
    let hrv: Double
    let heartRate: Double
    let confidence: Double
    let isSynced: Bool
    let deviceID: String

    init(from measurement: StressMeasurement) {
        self.timestamp = measurement.timestamp
        self.stressLevel = measurement.stressLevel
        self.category = measurement.category.rawValue
        self.hrv = measurement.hrv
        self.heartRate = measurement.restingHeartRate

        // Calculate average confidence
        if let confidences = measurement.confidences, !confidences.isEmpty {
            self.confidence = confidences.reduce(0, +) / Double(confidences.count)
        } else {
            self.confidence = 0.0
        }

        self.isSynced = measurement.isSynced
        self.deviceID = measurement.deviceID
    }
}

// MARK: - Export Summary

/// Statistical summary of exported data
public struct ExportSummary: Codable, Sendable {
    let totalMeasurements: Int
    let dateRange: DateRangeData
    let averages: AverageData
    let distribution: CategoryDistribution
    let peakStress: PeakStressData

    init(from measurements: [StressMeasurement]) {
        self.totalMeasurements = measurements.count

        // Calculate date range
        if let first = measurements.first?.timestamp,
           let last = measurements.last?.timestamp {
            let start = min(first, last)
            let end = max(first, last)
            self.dateRange = DateRangeData(startDate: start, endDate: end)
        } else {
            self.dateRange = DateRangeData(startDate: Date(), endDate: Date())
        }

        // Calculate averages
        let stressLevels = measurements.map { $0.stressLevel }
        let hrvs = measurements.map { $0.hrv }
        let heartRates = measurements.map { $0.restingHeartRate }

        self.averages = AverageData(
            stressLevel: stressLevels.isEmpty ? 0 : stressLevels.reduce(0, +) / Double(stressLevels.count),
            hrv: hrvs.isEmpty ? 0 : hrvs.reduce(0, +) / Double(hrvs.count),
            heartRate: heartRates.isEmpty ? 0 : heartRates.reduce(0, +) / Double(heartRates.count)
        )

        // Calculate category distribution
        let categories = measurements.map { $0.category }
        var distribution: [String: Int] = [:]
        for category in categories {
            distribution[category.rawValue, default: 0] += 1
        }
        self.distribution = CategoryDistribution(
            relaxed: distribution[StressCategory.relaxed.rawValue] ?? 0,
            mild: distribution[StressCategory.mild.rawValue] ?? 0,
            moderate: distribution[StressCategory.moderate.rawValue] ?? 0,
            high: distribution[StressCategory.high.rawValue] ?? 0
        )

        // Find peak stress
        if let peak = measurements.max(by: { $0.stressLevel < $1.stressLevel }) {
            self.peakStress = PeakStressData(
                level: peak.stressLevel,
                timestamp: peak.timestamp,
                category: peak.category.rawValue
            )
        } else {
            self.peakStress = PeakStressData(
                level: 0,
                timestamp: Date(),
                category: StressCategory.relaxed.rawValue
            )
        }
    }
}

// MARK: - Date Range Data

public struct DateRangeData: Codable, Sendable {
    public let startDate: Date
    public let endDate: Date
    public let durationDays: Int

    public init(startDate: Date, endDate: Date) {
        self.startDate = startDate
        self.endDate = endDate
        let seconds = endDate.timeIntervalSince(startDate)
        self.durationDays = max(1, Int(ceil(seconds / 86400)))
    }
}

// MARK: - Average Data

public struct AverageData: Codable, Sendable {
    public let stressLevel: Double
    public let hrv: Double
    public let heartRate: Double
}

// MARK: - Category Distribution

public struct CategoryDistribution: Codable, Sendable {
    let relaxed: Int
    let mild: Int
    let moderate: Int
    let high: Int

    var total: Int {
        relaxed + mild + moderate + high
    }

    var percentages: [String: Double] {
        let total = Double(total)
        guard total > 0 else { return [:] }

        return [
            StressCategory.relaxed.rawValue: Double(relaxed) / total * 100,
            StressCategory.mild.rawValue: Double(mild) / total * 100,
            StressCategory.moderate.rawValue: Double(moderate) / total * 100,
            StressCategory.high.rawValue: Double(high) / total * 100
        ]
    }
}

// MARK: - Peak Stress Data

public struct PeakStressData: Codable, Sendable {
    public let level: Double
    public let timestamp: Date
    public let category: String
}


// MARK: - Export Errors

public enum ExportError: LocalizedError {
    case noData
    case encodingFailed
    case fileWriteFailed(Error)
    case invalidPath
    case fileAccessFailed

    public var errorDescription: String? {
        switch self {
        case .noData:
            return "No measurements available to export."
        case .encodingFailed:
            return "Failed to encode data for export."
        case .fileWriteFailed(let error):
            return "Failed to write file: \(error.localizedDescription)"
        case .invalidPath:
            return "Invalid file path for export."
        case .fileAccessFailed:
            return "Could not access file system"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Models/HeartRateSample.swift">
import Foundation

struct HeartRateSample: Identifiable, Codable, Sendable {
    let id: UUID
    let value: Double
    let timestamp: Date

    init(value: Double, timestamp: Date = Date()) {
        self.id = UUID()
        self.value = value
        self.timestamp = timestamp
    }
}
</file>

<file path="StressMonitor/StressMonitor/Models/HRVMeasurement.swift">
import Foundation

struct HRVMeasurement: Identifiable, Codable, Sendable {
    let id: UUID
    let value: Double
    let timestamp: Date
    let unit: String

    init(value: Double, timestamp: Date = Date()) {
        self.id = UUID()
        self.value = value
        self.timestamp = timestamp
        self.unit = "ms"
    }
}
</file>

<file path="StressMonitor/StressMonitor/Models/PersonalBaseline.swift">
import Foundation

struct PersonalBaseline: Codable, Sendable {
    var restingHeartRate: Double
    var baselineHRV: Double
    var lastUpdated: Date

    init(restingHeartRate: Double = 60.0, baselineHRV: Double = 50.0, lastUpdated: Date = Date()) {
        self.restingHeartRate = restingHeartRate
        self.baselineHRV = baselineHRV
        self.lastUpdated = lastUpdated
    }
}
</file>

<file path="StressMonitor/StressMonitor/Models/StressBuddyMood.swift">
import SwiftUI

/// Stress Buddy character mood states mapped to stress levels
/// Part of Phase 2: Character System with WCAG-compliant dual coding
public enum StressBuddyMood: String, CaseIterable, Sendable {
    case sleeping     // 0-10: very relaxed
    case calm         // 10-25: relaxed
    case concerned    // 25-50: mild stress
    case worried      // 50-75: moderate stress
    case overwhelmed  // 75-100: high stress

    // MARK: - Stress Level Mapping

    /// Map stress level (0-100) to character mood
    /// - Parameter stressLevel: Stress level from 0-100
    /// - Returns: Corresponding mood
    public static func from(stressLevel: Double) -> StressBuddyMood {
        switch stressLevel {
        case ..<10:
            return .sleeping
        case 10..<25:
            return .calm
        case 25..<50:
            return .concerned
        case 50..<75:
            return .worried
        default:
            return .overwhelmed
        }
    }

    // MARK: - Visual Representation

    /// SF Symbol for this mood
    public var symbol: String {
        switch self {
        case .sleeping:
            return "moon.zzz.fill"
        case .calm:
            return "figure.mind.and.body"
        case .concerned:
            return "figure.walk.circle"
        case .worried:
            return "exclamationmark.triangle.fill"
        case .overwhelmed:
            return "flame.fill"
        }
    }

    /// Accessory symbols to display alongside character
    public var accessories: [String] {
        switch self {
        case .sleeping:
            return ["zzz"]
        case .calm:
            return []
        case .concerned:
            return ["star.fill"]
        case .worried:
            return ["drop.fill"]
        case .overwhelmed:
            return ["drop.fill", "star.fill"]
        }
    }

    /// Color for the mood
    public var color: Color {
        switch self {
        case .sleeping, .calm:
            return StressCategory.relaxed.color
        case .concerned:
            return StressCategory.mild.color
        case .worried:
            return StressCategory.moderate.color
        case .overwhelmed:
            return StressCategory.high.color
        }
    }

    // MARK: - Size Variants

    /// Context for character display size
    public enum CharacterContext {
        case dashboard
        case widget
        case watchOS
    }

    /// Size for symbol based on context
    /// - Parameter context: Display context
    /// - Returns: Point size for the symbol
    public func symbolSize(for context: CharacterContext) -> CGFloat {
        switch context {
        case .dashboard:
            return 120
        case .widget:
            return 80
        case .watchOS:
            return 60
        }
    }

    /// Accessory size relative to main symbol
    /// - Parameter context: Display context
    /// - Returns: Point size for accessories
    public func accessorySize(for context: CharacterContext) -> CGFloat {
        symbolSize(for: context) * 0.3
    }

    // MARK: - Accessibility

    /// VoiceOver description
    public var accessibilityDescription: String {
        switch self {
        case .sleeping:
            return "Very relaxed, sleeping peacefully"
        case .calm:
            return "Calm and relaxed"
        case .concerned:
            return "Showing mild concern"
        case .worried:
            return "Moderately worried"
        case .overwhelmed:
            return "Feeling overwhelmed"
        }
    }

    /// Display name for UI
    public var displayName: String {
        rawValue.capitalized
    }
}
</file>

<file path="StressMonitor/StressMonitor/Models/StressResult.swift">
import Foundation

struct StressResult: Identifiable, Codable, Sendable {
    let id: UUID
    let level: Double
    let category: StressCategory
    let confidence: Double
    let hrv: Double
    let heartRate: Double
    let timestamp: Date

    init(level: Double, category: StressCategory, confidence: Double, hrv: Double, heartRate: Double, timestamp: Date = Date()) {
        self.id = UUID()
        self.level = level
        self.category = category
        self.confidence = confidence
        self.hrv = hrv
        self.heartRate = heartRate
        self.timestamp = timestamp
    }

    static func category(for level: Double) -> StressCategory {
        switch level {
        case 0..<25: return .relaxed
        case 25..<50: return .mild
        case 50..<75: return .moderate
        default: return .high
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Models/WidgetSharedData.swift">
import Foundation
import WidgetKit

// MARK: - Complication Entry (watchOS)
struct ComplicationEntry: TimelineEntry, Sendable, Codable {
    let date: Date
    let stressLevel: Double
    let category: StressCategory
    let hrv: Double
    let heartRate: Double
    let trendData: [Double]
    let lastUpdated: Date

    var confidence: Double {
        (hrv > 20 && hrv < 200 && heartRate > 40 && heartRate < 180) ? 0.9 : 0.6
    }
}

// MARK: - Widget Entry (iOS)
struct WidgetEntry: TimelineEntry, Sendable, Codable {
    let date: Date
    let stressLevel: Double
    let category: StressCategory
    let hrv: Double
    let heartRate: Double
    let hrvHistory: [Double]
    let lastUpdated: Date

    var hrvAverage: Double {
        guard !hrvHistory.isEmpty else { return hrv }
        return hrvHistory.reduce(0, +) / Double(hrvHistory.count)
    }

    var hrvMax: Double {
        hrvHistory.max() ?? hrv
    }

    var trend: WidgetTrend {
        guard hrvHistory.count >= 2 else { return .stable }
        let recent = hrvHistory.suffix(min(6, hrvHistory.count))
        let avg = recent.reduce(0, +) / Double(recent.count)
        let latest = recent.last ?? avg

        if latest > avg * 1.1 { return .improving }
        if latest < avg * 0.9 { return .declining }
        return .stable
    }
}

// MARK: - Widget Trend
enum WidgetTrend: String, Sendable, Codable {
    case improving
    case stable
    case declining

    var icon: String {
        switch self {
        case .improving: return "arrow.down.right"
        case .stable: return "minus"
        case .declining: return "arrow.up.right"
        }
    }
}

// MARK: - Shared Data Schema (App Groups)
struct ComplicationSharedData: Codable, Sendable {
    let currentStress: WidgetStressSnapshot
    let hrvHistory: [Double]
    let lastSync: Date

    var trend: StressTrend {
        guard hrvHistory.count >= 2 else { return .stable }
        let recent = hrvHistory.suffix(6)
        let avg = recent.reduce(0, +) / Double(recent.count)
        let latest = recent.last ?? avg

        if latest > avg * 1.1 { return .improving }
        if latest < avg * 0.9 { return .declining }
        return .stable
    }
}

// Renamed to avoid conflict with StressSnapshot in ExportModels.swift
struct WidgetStressSnapshot: Codable, Sendable {
    let level: Double
    let category: String
    let hrv: Double
    let heartRate: Double
    let timestamp: Date
}

enum StressTrend: String, Codable {
    case improving
    case stable
    case declining
}

// MARK: - App Groups Constants
enum WidgetConstants {
    static let appGroupID = "group.com.stressmonitor.app"
    static let latestMeasurementKey = "latestMeasurement"
    static let widgetHistoryKey = "widgetHistory"
    static let lastUpdateKey = "lastUpdate"
}
</file>

<file path="StressMonitor/StressMonitor/Services/Algorithm/BaselineCalculator.swift">
import Foundation

enum BaselineCalculatorError: Error, LocalizedError {
    case insufficientSamples
    case noValidData

    var errorDescription: String? {
        switch self {
        case .insufficientSamples: return "Need at least 30 samples for baseline calculation"
        case .noValidData: return "No valid measurements available"
        }
    }
}

final class BaselineCalculator: Sendable {

    private let minimumSampleCount: Int
    private let timeWindowDays: Int

    init(minimumSampleCount: Int = 30, timeWindowDays: Int = 30) {
        self.minimumSampleCount = minimumSampleCount
        self.timeWindowDays = timeWindowDays
    }

    func calculateBaseline(from measurements: [HRVMeasurement]) async throws -> PersonalBaseline {
        let filtered = filterOutliers(measurements)

        try validateSampleCount(filtered.count)

        guard !filtered.isEmpty else {
            throw BaselineCalculatorError.noValidData
        }

        let avgHRV = filtered.reduce(0) { $0 + $1.value } / Double(filtered.count)

        return PersonalBaseline(
            restingHeartRate: 60,
            baselineHRV: avgHRV,
            lastUpdated: Date()
        )
    }

    func calculateRestingHeartRate(from samples: [HeartRateSample]) -> Double {
        guard samples.count >= 10 else { return 60 }

        let sorted = samples.map { $0.value }.sorted()
        let percentileIndex = Int(Double(sorted.count) * 0.1)
        return sorted[percentileIndex]
    }

    func shouldUpdateBaseline(lastUpdate: Date, samples: Int) -> Bool {
        let daysSinceUpdate = Calendar.current.dateComponents([.day], from: lastUpdate, to: Date()).day ?? 0
        return daysSinceUpdate >= 7 || samples >= 10
    }

    private func validateSampleCount(_ count: Int) throws {
        guard count >= minimumSampleCount else {
            throw BaselineCalculatorError.insufficientSamples
        }
    }

    func filterOutliers(_ measurements: [HRVMeasurement]) -> [HRVMeasurement] {
        guard measurements.count >= 4 else { return measurements }

        let sorted = measurements.map { $0.value }.sorted()
        let q1Index = sorted.count / 4
        let q3Index = (sorted.count * 3) / 4

        let q1 = sorted[q1Index]
        let q3 = sorted[q3Index]
        let iqr = q3 - q1

        let lowerBound = q1 - (1.5 * iqr)
        let upperBound = q3 + (1.5 * iqr)

        return measurements.filter { $0.value >= lowerBound && $0.value <= upperBound }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/Background/NotificationManager.swift">
import Foundation
import UIKit
import UserNotifications

@MainActor
final class NotificationManager {
  static let shared = NotificationManager()

  private let notificationCenter = UNUserNotificationCenter.current()

  private init() {}

  func requestAuthorization() async throws {
    let options: UNAuthorizationOptions = [.alert, .sound, .badge]
    try await notificationCenter.requestAuthorization(options: options)
  }

  func notifyHighStress(level: Double) async {
    let content = UNMutableNotificationContent()
    content.title = "High Stress Detected"
    content.body =
      "Your stress level is \(Int(level)). Consider taking a break and practicing deep breathing."
    content.sound = .default
    content.badge = 1

    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)

    let request = UNNotificationRequest(
      identifier: "high-stress-\(UUID().uuidString)",
      content: content,
      trigger: trigger
    )

    try? await notificationCenter.add(request)
  }

  func scheduleNotification(
    content: UNMutableNotificationContent,
    trigger: UNNotificationTrigger
  ) async {
    let request = UNNotificationRequest(
      identifier: UUID().uuidString,
      content: content,
      trigger: trigger
    )

    try? await notificationCenter.add(request)
  }
}
</file>

<file path="StressMonitor/StressMonitor/Services/CloudKit/CloudKitManager.swift">
import CloudKit
import Foundation
import Observation

@preconcurrency import CloudKit

@MainActor
@Observable
public final class CloudKitManager: CloudKitServiceProtocol {
    // MARK: - Properties

    public private(set) var syncStatus: SyncStatus = .idle
    public private(set) var lastSyncDate: Date?
    public private(set) var deviceID: String

    private let container: CKContainer
    private let privateDatabase: CKDatabase

    private var subscriptionID = "com.stressmonitor.subscription"

    // MARK: - Initialization

    public init(container: CKContainer = .default()) {
        self.container = container
        self.privateDatabase = container.privateCloudDatabase
        self.deviceID = Self.getDeviceID()
    }

    // MARK: - Device ID

    private static func getDeviceID() -> String {
        let key = "com.stressmonitor.deviceID"

        if let existingID = UserDefaults.standard.string(forKey: key) {
            return existingID
        }

        let newID = UUID().uuidString
        UserDefaults.standard.set(newID, forKey: key)
        return newID
    }

    // MARK: - Save Measurement

    public func saveMeasurement(_ measurement: StressMeasurement) async throws {
        syncStatus = .syncing(progress: 0.0)

        let record = CKRecord(recordType: CloudKitRecordType.stressMeasurement.rawValue)
        record["timestamp"] = measurement.timestamp
        record["stressLevel"] = measurement.stressLevel
        record["hrv"] = measurement.hrv
        record["restingHeartRate"] = measurement.restingHeartRate
        record["category"] = measurement.categoryRawValue
        record["confidences"] = measurement.confidences ?? []
        record["deviceID"] = deviceID
        record["isDeleted"] = false
        record["cloudKitModTime"] = Date()

        do {
            try await privateDatabase.save(record)
            lastSyncDate = Date()
            syncStatus = .success
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Fetch Measurements

    public func fetchMeasurements(since date: Date? = nil) async throws -> [StressMeasurement] {
        syncStatus = .syncing(progress: 0.0)

        let predicate: NSPredicate
        if let sinceDate = date {
            predicate = NSPredicate(format: "timestamp >= %@", sinceDate as NSDate)
        } else {
            predicate = NSPredicate(value: true)
        }

        let query = CKQuery(recordType: CloudKitRecordType.stressMeasurement.rawValue, predicate: predicate)
        query.sortDescriptors = [NSSortDescriptor(key: "timestamp", ascending: false)]

        do {
            let (matchResults, _) = try await privateDatabase.records(matching: query)

            var measurements: [StressMeasurement] = []
            for (_, result) in matchResults {
                switch result {
                case .success(let record):
                    if let measurement = self.convertRecordToMeasurement(record) {
                        measurements.append(measurement)
                    }
                case .failure:
                    continue
                }
            }

            lastSyncDate = Date()
            syncStatus = .success
            return measurements
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Delete Measurement

    public func deleteMeasurement(_ measurement: StressMeasurement) async throws {
        syncStatus = .syncing(progress: 0.0)

        // First, find the record ID
        let predicate = NSPredicate(format: "timestamp == %@ AND deviceID == %@",
                                    measurement.timestamp as NSDate,
                                    deviceID as NSString)
        let query = CKQuery(recordType: CloudKitRecordType.stressMeasurement.rawValue, predicate: predicate)

        do {
            let (matchResults, _) = try await privateDatabase.records(matching: query)

            for (recordID, result) in matchResults {
                switch result {
                case .success:
                    try await privateDatabase.deleteRecord(withID: recordID)
                case .failure:
                    continue
                }
            }

            lastSyncDate = Date()
            syncStatus = .success
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Sync

    public func sync() async throws {
        syncStatus = .syncing(progress: 0.0)

        do {
            _ = try await fetchMeasurements()
            lastSyncDate = Date()
            syncStatus = .success
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Push Subscription

    public func setupPushSubscription() async throws {
        let subscription = CKQuerySubscription(
            recordType: CloudKitRecordType.stressMeasurement.rawValue,
            predicate: NSPredicate(value: true),
            subscriptionID: subscriptionID,
            options: [.firesOnRecordCreation, .firesOnRecordUpdate, .firesOnRecordDeletion]
        )

        let notificationInfo = CKSubscription.NotificationInfo()
        notificationInfo.shouldSendContentAvailable = true
        subscription.notificationInfo = notificationInfo

        do {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                privateDatabase.save(subscription) { _, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume()
                    }
                }
            }
        } catch let error as CKError {
            if error.code == .serverRejectedRequest {
                return
            }
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Account Status

    public func checkAccountStatus() async throws -> CloudKitAccountStatus {
        do {
            let accountStatus = try await container.accountStatus()

            switch accountStatus {
            case .available:
                return .available
            case .noAccount:
                return .noAccount
            case .restricted:
                return .restricted
            case .couldNotDetermine:
                return .unknown
            case .temporarilyUnavailable:
                return .unknown
            @unknown default:
                return .unknown
            }
        } catch let error as CKError {
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Helper Methods

    private func convertRecordToMeasurement(_ record: CKRecord) -> StressMeasurement? {
        guard let timestamp = record["timestamp"] as? Date,
              let stressLevel = record["stressLevel"] as? Double,
              let hrv = record["hrv"] as? Double,
              let restingHeartRate = record["restingHeartRate"] as? Double,
              let categoryRawValue = record["category"] as? String else {
            return nil
        }

        let confidences = record["confidences"] as? [Double]

        let measurement = StressMeasurement(
            timestamp: timestamp,
            stressLevel: stressLevel,
            hrv: hrv,
            restingHeartRate: restingHeartRate,
            confidences: confidences
        )
        measurement.categoryRawValue = categoryRawValue

        return measurement
    }

    // MARK: - Error Handling

    private func adaptCloudKitError(_ error: CKError) -> CloudKitError {
        switch error.code {
        case .networkFailure, .networkUnavailable:
            return CloudKitError.networkUnavailable(.noInternet)
        case .notAuthenticated:
            return CloudKitError.networkUnavailable(.iCloudNotSignedIn)
        case .quotaExceeded:
            return CloudKitError.networkUnavailable(.quotaExceeded)
        case .requestRateLimited:
            return CloudKitError.rateLimited
        case .zoneNotFound:
            return CloudKitError.zoneNotFound
        case .unknownItem:
            return CloudKitError.recordNotFound
        default:
            return CloudKitError.unknown(error)
        }
    }
}

// MARK: - CloudKitError

public enum CloudKitError: Error, Sendable {
    case networkUnavailable(NetworkReason)
    case rateLimited
    case zoneNotFound
    case recordNotFound
    case unknown(Error)

    public var localizedDescription: String {
        switch self {
        case .networkUnavailable(let reason):
            switch reason {
            case .noInternet:
                return "No internet connection available"
            case .iCloudNotSignedIn:
                return "iCloud is not signed in"
            case .cloudKitDisabled:
                return "CloudKit is disabled"
            case .quotaExceeded:
                return "iCloud storage quota exceeded"
            }
        case .rateLimited:
            return "Too many requests. Please try again later."
        case .zoneNotFound:
            return "CloudKit zone not found"
        case .recordNotFound:
            return "Record not found"
        case .unknown(let error):
            return error.localizedDescription
        }
    }
}

// MARK: - Sendable Conformance for StressMeasurement

extension StressMeasurement: @unchecked Sendable {}
</file>

<file path="StressMonitor/StressMonitor/Services/CloudKit/CloudKitSchema.swift">
import CloudKit
import Foundation

// MARK: - Record Types
enum CloudKitRecordType: String, Sendable {
    case stressMeasurement = "CD_StressMeasurement"
    case personalBaseline = "CD_PersonalBaseline"
    case syncMetadata = "CD_SyncMetadata"
}

// MARK: - StressMeasurement Record
struct CloudKitStressMeasurement: Sendable {
    let recordID: CKRecord.ID
    let timestamp: Date
    let stressLevel: Double
    let hrv: Double
    let restingHeartRate: Double
    let category: String
    let confidences: [Double]
    let deviceID: String
    let isDeleted: Bool
    let cloudKitModTime: Date?

    init?(record: CKRecord) {
        guard record.recordType == CloudKitRecordType.stressMeasurement.rawValue else {
            return nil
        }

        self.recordID = record.recordID
        self.timestamp = record["timestamp"] as? Date ?? Date()
        self.stressLevel = record["stressLevel"] as? Double ?? 0
        self.hrv = record["hrv"] as? Double ?? 0
        self.restingHeartRate = record["restingHeartRate"] as? Double ?? 0
        self.category = record["category"] as? String ?? ""
        self.confidences = record["confidences"] as? [Double] ?? []
        self.deviceID = record["deviceID"] as? String ?? ""
        self.isDeleted = record["isDeleted"] as? Bool ?? false
        self.cloudKitModTime = record["cloudKitModTime"] as? Date
    }

    func toCKRecord() -> CKRecord {
        let record = CKRecord(recordType: CloudKitRecordType.stressMeasurement.rawValue, recordID: recordID)
        record["timestamp"] = timestamp
        record["stressLevel"] = stressLevel
        record["hrv"] = hrv
        record["restingHeartRate"] = restingHeartRate
        record["category"] = category
        record["confidences"] = confidences
        record["deviceID"] = deviceID
        record["isDeleted"] = isDeleted
        return record
    }
}

// MARK: - PersonalBaseline Record
struct CloudKitPersonalBaseline: Sendable {
    let recordID: CKRecord.ID
    let restingHeartRate: Double
    let baselineHRV: Double
    let lastUpdated: Date

    init?(record: CKRecord) {
        guard record.recordType == CloudKitRecordType.personalBaseline.rawValue else {
            return nil
        }

        self.recordID = record.recordID
        self.restingHeartRate = record["restingHeartRate"] as? Double ?? 60
        self.baselineHRV = record["baselineHRV"] as? Double ?? 50
        self.lastUpdated = record["lastUpdated"] as? Date ?? Date()
    }

    func toCKRecord() -> CKRecord {
        let record = CKRecord(recordType: CloudKitRecordType.personalBaseline.rawValue, recordID: recordID)
        record["restingHeartRate"] = restingHeartRate
        record["baselineHRV"] = baselineHRV
        record["lastUpdated"] = lastUpdated
        return record
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/CloudKit/CloudKitSyncEngine.swift">
import CloudKit
import Foundation
import Observation

@MainActor
@Observable
public final class CloudKitSyncEngine {
    // MARK: - Properties

    public private(set) var syncProgress: Double = 0.0
    public private(set) var isSyncing: Bool = false
    public private(set) var lastError: Error?

    private let cloudKitManager: CloudKitManager
    private let batchSize: Int
    private let maxRetries: Int
    private let baseRetryDelay: TimeInterval

    // MARK: - Initialization

    public init(
        cloudKitManager: CloudKitManager,
        batchSize: Int = 10,
        maxRetries: Int = 3,
        baseRetryDelay: TimeInterval = 1.0
    ) {
        self.cloudKitManager = cloudKitManager
        self.batchSize = batchSize
        self.maxRetries = maxRetries
        self.baseRetryDelay = baseRetryDelay
    }

    // MARK: - Upload Operations

    public func uploadMeasurements(_ measurements: [StressMeasurement]) async throws {
        guard !measurements.isEmpty else { return }

        isSyncing = true
        syncProgress = 0.0
        lastError = nil

        let batches = measurements.chunked(into: batchSize)
        let totalBatches = batches.count

        for (index, batch) in batches.enumerated() {
            var attempt = 0
            var lastError: Error?

            while attempt < maxRetries {
                do {
                    try await uploadBatch(batch)
                    syncProgress = Double(index + 1) / Double(totalBatches)
                    break
                } catch {
                    lastError = error
                    attempt += 1

                    if attempt < maxRetries {
                        let delay = baseRetryDelay * pow(2.0, Double(attempt))
                        try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                    }
                }
            }

            if attempt >= maxRetries {
                self.lastError = lastError
                isSyncing = false
                throw lastError ?? CloudKitSyncError.uploadFailed
            }
        }

        isSyncing = false
    }

    private func uploadBatch(_ batch: [StressMeasurement]) async throws {
        let records = batch.map { measurement -> CKRecord in
            let record = CKRecord(recordType: CloudKitRecordType.stressMeasurement.rawValue)
            record["timestamp"] = measurement.timestamp
            record["stressLevel"] = measurement.stressLevel
            record["hrv"] = measurement.hrv
            record["restingHeartRate"] = measurement.restingHeartRate
            record["category"] = measurement.categoryRawValue
            record["confidences"] = measurement.confidences ?? []
            record["deviceID"] = cloudKitManager.deviceID
            record["isDeleted"] = false
            record["cloudKitModTime"] = Date()
            return record
        }

        let operation = CKModifyRecordsOperation(recordsToSave: records, recordIDsToDelete: nil)

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            operation.modifyRecordsResultBlock = { result in
                switch result {
                case .success:
                    continuation.resume()
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }

            CKContainer.default().privateCloudDatabase.add(operation)
        }
    }

    // MARK: - Download Operations

    public func downloadMeasurements(since date: Date? = nil) async throws -> [StressMeasurement] {
        isSyncing = true
        syncProgress = 0.0
        lastError = nil

        var attempt = 0
        var lastError: Error?

        while attempt < maxRetries {
            do {
                let measurements = try await cloudKitManager.fetchMeasurements(since: date)
                syncProgress = 1.0
                isSyncing = false
                return measurements
            } catch {
                lastError = error
                attempt += 1

                if attempt < maxRetries {
                    let delay = baseRetryDelay * pow(2.0, Double(attempt))
                    try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                }
            }
        }

        self.lastError = lastError
        isSyncing = false
        throw lastError ?? CloudKitSyncError.downloadFailed
    }

    // MARK: - Bidirectional Sync

    public func sync(localMeasurements: [StressMeasurement]) async throws -> [StressMeasurement] {
        isSyncing = true
        syncProgress = 0.0
        lastError = nil

        do {
            // Step 1: Upload local measurements
            try await uploadMeasurements(localMeasurements)
            syncProgress = 0.5

            // Step 2: Download remote measurements
            let remoteMeasurements = try await downloadMeasurements()
            syncProgress = 1.0

            isSyncing = false
            return remoteMeasurements
        } catch {
            self.lastError = error
            isSyncing = false
            throw error
        }
    }

    // MARK: - Background Task Support

    public func performBackgroundSync() async throws {
        let startDate = Date()

        do {
            // Fetch last sync date or use 24 hours ago
            let sinceDate = cloudKitManager.lastSyncDate?.addingTimeInterval(-86400) ?? startDate.addingTimeInterval(-86400)
            _ = try await downloadMeasurements(since: sinceDate)

            // Process measurements would happen here
            // This is handled by SyncManager
        } catch {
            lastError = error
            throw error
        }
    }

    // MARK: - Reset

    public func reset() {
        syncProgress = 0.0
        isSyncing = false
        lastError = nil
    }
}

// MARK: - Batch Chunking

private extension Array {
    func chunked(into size: Int) -> [[Element]] {
        guard size > 0 else { return [self] }
        return stride(from: 0, to: count, by: size).map {
            Array(self[$0..<Swift.min($0 + size, count)])
        }
    }
}

// MARK: - Sync Errors

public enum CloudKitSyncError: Error, Sendable {
    case uploadFailed
    case downloadFailed
    case syncCancelled
    case backgroundTaskExpired

    public var localizedDescription: String {
        switch self {
        case .uploadFailed:
            return "Failed to upload measurements to iCloud"
        case .downloadFailed:
            return "Failed to download measurements from iCloud"
        case .syncCancelled:
            return "Sync operation was cancelled"
        case .backgroundTaskExpired:
            return "Background sync task expired"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/Connectivity/PhoneConnectivityManager.swift">
import Combine
import Foundation
import SwiftData
import WatchConnectivity

final class PhoneConnectivityManager: NSObject, ObservableObject {
  static let shared = PhoneConnectivityManager()

  @Published var isWatchPaired = false
  @Published var isWatchAppInstalled = false
  @Published var isReachable = false

  private var modelContext: ModelContext?

  private override init() {
    super.init()
    if WCSession.isSupported() {
      WCSession.default.delegate = self
      WCSession.default.activate()
    }
  }

  func setModelContext(_ context: ModelContext) {
    self.modelContext = context
  }

  private func handleWatchMeasurement(_ userInfo: [String: Any]) {
    guard
      let stressLevel = userInfo["stressLevel"] as? Double,
      let categoryRaw = userInfo["category"] as? String,
      let category = StressCategory(rawValue: categoryRaw),
      let confidence = userInfo["confidence"] as? Double,
      let hrv = userInfo["hrv"] as? Double,
      let heartRate = userInfo["heartRate"] as? Double,
      let timestamp = userInfo["timestamp"] as? Date
    else {
      return
    }

    let measurement = StressMeasurement(
      timestamp: timestamp,
      stressLevel: stressLevel,
      hrv: hrv,
      restingHeartRate: heartRate,
      confidences: [confidence]
    )

    guard let context = modelContext else {
      return
    }

    do {
      context.insert(measurement)
      try context.save()
    } catch {
      print("Failed to save watch measurement: \(error)")
    }
  }
}

extension PhoneConnectivityManager: WCSessionDelegate {
  func sessionDidBecomeInactive(_ session: WCSession) {}

  func sessionDidDeactivate(_ session: WCSession) {
    WCSession.default.activate()
  }

  func session(
    _ session: WCSession,
    activationDidCompleteWith activationState: WCSessionActivationState,
    error: Error?
  ) {
    isWatchPaired = session.isPaired
    isWatchAppInstalled = session.isWatchAppInstalled
    isReachable = session.isReachable
  }

  func sessionReachabilityDidChange(_ session: WCSession) {
    isReachable = session.isReachable
  }

  func session(_ session: WCSession, didReceiveUserInfo userInfo: [String: Any] = [:]) {
    handleWatchMeasurement(userInfo)
  }

  func session(
    _ session: WCSession,
    didReceiveMessage message: [String: Any],
    replyHandler: @escaping ([String: Any]) -> Void
  ) {
    guard let action = message["action"] as? String, action == "fetchLatest" else {
      replyHandler([:])
      return
    }

    guard let context = modelContext else {
      replyHandler([:])
      return
    }

    var descriptor = FetchDescriptor<StressMeasurement>(
      sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
    )
    descriptor.fetchLimit = 1

    do {
      if let latest = try context.fetch(descriptor).first {
        let reply: [String: Any] = [
          "stressLevel": latest.stressLevel,
          "category": StressResult.category(for: latest.stressLevel).rawValue,
          "confidence": latest.confidences?.first ?? 0.0,
          "hrv": latest.hrv,
          "heartRate": latest.restingHeartRate,
          "timestamp": latest.timestamp,
        ]
        replyHandler(reply)
      } else {
        replyHandler([:])
      }
    } catch {
      replyHandler([:])
    }
  }
}
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/CloudKitResetService.swift">
import CloudKit
import Foundation
import os.log

// MARK: - CloudKit Reset Service
/// Handles deletion of CloudKit records and database reset operations
@MainActor
final class CloudKitResetService: Sendable {

    // MARK: - Properties

    private let container: CKContainer
    private let privateDatabase: CKDatabase
    private nonisolated let logger: DataManagementLogger

    // MARK: - Progress Tracking

    private var _isDeleting: ObserverIsolated<Bool> = ObserverIsolated(false)
    private var _deleteProgress: ObserverIsolated<Double> = ObserverIsolated(0.0)
    private var _currentOperation: ObserverIsolated<String?> = ObserverIsolated(nil)
    private var _recordsDeleted: ObserverIsolated<Int> = ObserverIsolated(0)

    var isDeleting: Bool { _isDeleting.wrappedValue }
    var deleteProgress: Double { _deleteProgress.wrappedValue }
    var currentOperation: String? { _currentOperation.wrappedValue }
    var recordsDeleted: Int { _recordsDeleted.wrappedValue }

    // MARK: - Initialization

    init(container: CKContainer = .default(), logger: DataManagementLogger = .default) {
        self.container = container
        self.privateDatabase = container.privateCloudDatabase
        self.logger = logger
    }

    // MARK: - Delete All Records

    /// Delete all CloudKit records across all record types
    /// - Parameters:
    ///   - confirmation: Optional confirmation callback before proceeding
    ///   - includeBaseline: Whether to also delete personal baseline records
    /// - Throws: CloudKitResetError if deletion fails
    func deleteAllRecords(
        confirmation: (() async -> Bool)? = nil,
        includeBaseline: Bool = true
    ) async throws {
        _isDeleting.wrappedValue = true
        _deleteProgress.wrappedValue = 0.0
        _recordsDeleted.wrappedValue = 0
        _currentOperation.wrappedValue = "Preparing CloudKit reset"

        defer {
            _isDeleting.wrappedValue = false
            _currentOperation.wrappedValue = nil
        }

        // Request confirmation if callback provided
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                logger.log("CloudKit reset cancelled by user")
                throw CloudKitResetError.operationCancelled
            }
        }

        // Check account status first
        _currentOperation.wrappedValue = "Verifying iCloud account"
        _deleteProgress.wrappedValue = 0.05

        let accountStatus = try await container.accountStatus()
        guard accountStatus == .available else {
            logger.log("iCloud account not available: \(accountStatus.rawValue)")
            throw CloudKitResetError.accountNotAvailable
        }

        // Delete each record type
        try await deleteRecords(ofType: .stressMeasurement, expectedProgress: 0.0...0.6)

        if includeBaseline {
            try await deleteRecords(ofType: .personalBaseline, expectedProgress: 0.6...0.8)
        }

        try await deleteRecords(ofType: .syncMetadata, expectedProgress: 0.8...0.95)

        _deleteProgress.wrappedValue = 1.0
        _currentOperation.wrappedValue = "CloudKit reset complete"
        logger.log("Successfully deleted \(_recordsDeleted.wrappedValue) CloudKit records")
    }

    // MARK: - Delete by Record Type

    /// Delete all records of a specific type
    /// - Parameter recordType: The CloudKit record type to delete
    /// - Throws: CloudKitResetError if deletion fails
    func deleteRecords(ofType recordType: CloudKitRecordType, expectedProgress: ClosedRange<Double> = 0.0...1.0) async throws {
        _currentOperation.wrappedValue = "Fetching \(recordType.rawValue) records"
        logger.log("Starting deletion of \(recordType.rawValue) records")

        do {
            // Query all records of this type
            let predicate = NSPredicate(value: true)
            let query = CKQuery(recordType: recordType.rawValue, predicate: predicate)

            let (matchResults, queryCursor) = try await privateDatabase.records(matching: query)

            var recordsToDelete: [CKRecord.ID] = []
            var deletedCount = 0

            // Collect record IDs from initial results
            for (recordID, result) in matchResults {
                switch result {
                case .success:
                    recordsToDelete.append(recordID)
                    deletedCount += 1
                case .failure(let error):
                    logger.log("Error fetching record: \(error.localizedDescription)")
                }
            }

            // Handle cursor if there are more records
            if let cursor = queryCursor {
                try await fetchRecordsWithCursor(cursor, accumalatingInto: &recordsToDelete)
            }

            guard !recordsToDelete.isEmpty else {
                logger.log("No \(recordType.rawValue) records found to delete")
                return
            }

            // Batch delete records
            _currentOperation.wrappedValue = "Deleting \(recordsToDelete.count) \(recordType.rawValue) records"
            _deleteProgress.wrappedValue = expectedProgress.lowerBound + (expectedProgress.upperBound - expectedProgress.lowerBound) * 0.5

            try await deleteBatchRecords(recordsToDelete, recordType: recordType)

            _recordsDeleted.wrappedValue += deletedCount
            _deleteProgress.wrappedValue = expectedProgress.upperBound

            logger.log("Successfully deleted \(deletedCount) \(recordType.rawValue) records")

        } catch let error as CKError {
            logger.log("CloudKit error deleting \(recordType.rawValue): \(error.localizedDescription)")
            throw CloudKitResetError.cloudKitError(adaptCloudKitError(error))
        } catch {
            logger.log("Failed to delete \(recordType.rawValue) records: \(error.localizedDescription)")
            throw CloudKitResetError.deletionFailed(underlying: error)
        }
    }

    // MARK: - Delete by Date Range

    /// Delete records within a specific date range
    /// - Parameters:
    ///   - recordType: The CloudKit record type
    ///   - range: Date range for deletion
    /// - Throws: CloudKitResetError if deletion fails
    func deleteRecords(ofType recordType: CloudKitRecordType, in range: ClosedRange<Date>) async throws {
        _isDeleting.wrappedValue = true
        _currentOperation.wrappedValue = "Finding \(recordType.rawValue) records in date range"

        defer {
            _isDeleting.wrappedValue = false
            _currentOperation.wrappedValue = nil
        }

        do {
            let predicate = NSPredicate(format: "timestamp >= %@ AND timestamp <= %@",
                                       range.lowerBound as NSDate,
                                       range.upperBound as NSDate)
            let query = CKQuery(recordType: recordType.rawValue, predicate: predicate)

            let (matchResults, queryCursor) = try await privateDatabase.records(matching: query)

            var recordsToDelete: [CKRecord.ID] = []

            for (recordID, result) in matchResults {
                switch result {
                case .success:
                    recordsToDelete.append(recordID)
                case .failure(let error):
                    logger.log("Error fetching record: \(error.localizedDescription)")
                }
            }

            if let cursor = queryCursor {
                try await fetchRecordsWithCursor(cursor, accumalatingInto: &recordsToDelete)
            }

            guard !recordsToDelete.isEmpty else {
                logger.log("No \(recordType.rawValue) records found in date range")
                return
            }

            _currentOperation.wrappedValue = "Deleting \(recordsToDelete.count) records"
            try await deleteBatchRecords(recordsToDelete, recordType: recordType)

            _recordsDeleted.wrappedValue += recordsToDelete.count
            logger.log("Successfully deleted \(recordsToDelete.count) records in date range")

        } catch let error as CKError {
            throw CloudKitResetError.cloudKitError(adaptCloudKitError(error))
        } catch {
            throw CloudKitResetError.deletionFailed(underlying: error)
        }
    }

    // MARK: - Delete Before Date

    /// Delete records older than a specified date
    /// - Parameters:
    ///   - recordType: The CloudKit record type
    ///   - date: Cutoff date
    /// - Throws: CloudKitResetError if deletion fails
    func deleteRecords(ofType recordType: CloudKitRecordType, before date: Date) async throws {
        _isDeleting.wrappedValue = true
        _currentOperation.wrappedValue = "Finding \(recordType.rawValue) records before \(date)"

        defer {
            _isDeleting.wrappedValue = false
            _currentOperation.wrappedValue = nil
        }

        do {
            let predicate = NSPredicate(format: "timestamp < %@", date as NSDate)
            let query = CKQuery(recordType: recordType.rawValue, predicate: predicate)

            let (matchResults, queryCursor) = try await privateDatabase.records(matching: query)

            var recordsToDelete: [CKRecord.ID] = []

            for (recordID, result) in matchResults {
                switch result {
                case .success:
                    recordsToDelete.append(recordID)
                case .failure(let error):
                    logger.log("Error fetching record: \(error.localizedDescription)")
                }
            }

            if let cursor = queryCursor {
                try await fetchRecordsWithCursor(cursor, accumalatingInto: &recordsToDelete)
            }

            guard !recordsToDelete.isEmpty else {
                logger.log("No \(recordType.rawValue) records found before \(date)")
                return
            }

            _currentOperation.wrappedValue = "Deleting \(recordsToDelete.count) records"
            try await deleteBatchRecords(recordsToDelete, recordType: recordType)

            _recordsDeleted.wrappedValue += recordsToDelete.count
            logger.log("Successfully deleted \(recordsToDelete.count) records before \(date)")

        } catch let error as CKError {
            throw CloudKitResetError.cloudKitError(adaptCloudKitError(error))
        } catch {
            throw CloudKitResetError.deletionFailed(underlying: error)
        }
    }

    // MARK: - Complete Database Reset

    /// Perform a complete database reset - deletes all records and clears local cache
    /// - Parameter confirmation: Optional confirmation callback
    /// - Throws: CloudKitResetError if reset fails
    func performDatabaseReset(confirmation: (() async -> Bool)? = nil) async throws {
        _currentOperation.wrappedValue = "Starting complete database reset"

        // Delete all records including baseline
        try await deleteAllRecords(confirmation: confirmation, includeBaseline: true)

        _currentOperation.wrappedValue = "Database reset complete"
        logger.log("Complete database reset finished")
    }

    // MARK: - Helper Methods

    /// Fetch additional records using query cursor
    private func fetchRecordsWithCursor(
        _ cursor: CKQueryOperation.Cursor,
        accumalatingInto records: inout [CKRecord.ID]
    ) async throws {
        var currentCursor = cursor
        let database = privateDatabase  // Capture non-isolated reference
        nonisolated(unsafe) let loggerRef = logger

        while true {
            let operation = CKQueryOperation(cursor: currentCursor)
            operation.desiredKeys = ["recordID"]

            var fetchedRecords: [CKRecord.ID] = []
            var resultCursor: CKQueryOperation.Cursor?

            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                operation.recordMatchedBlock = { recordID, result in
                    switch result {
                    case .success:
                        fetchedRecords.append(recordID)
                    case .failure(let error):
                        loggerRef.log("Error fetching record with cursor: \(error.localizedDescription)")
                    }
                }

                operation.queryResultBlock = { result in
                    switch result {
                    case .success(let cursor):
                        resultCursor = cursor
                        continuation.resume()
                    case .failure(let error):
                        continuation.resume(throwing: error)
                    }
                }

                database.add(operation)
            }

            records.append(contentsOf: fetchedRecords)

            // If no more results, break
            if fetchedRecords.isEmpty {
                break
            }

            // Update cursor for next iteration
            guard let newCursor = resultCursor else {
                break
            }
            currentCursor = newCursor

            // Prevent infinite loops
            if records.count > 10000 {
                loggerRef.log("Reached safety limit while fetching records")
                break
            }
        }
    }

    /// Delete records in batches to avoid rate limiting
    private func deleteBatchRecords(
        _ recordIDs: [CKRecord.ID],
        recordType: CloudKitRecordType,
        batchSize: Int = 300
    ) async throws {
        let batches = stride(from: 0, to: recordIDs.count, by: batchSize).map {
            Array(recordIDs[$0..<min($0 + batchSize, recordIDs.count)])
        }

        var totalDeleted = 0
        let database = privateDatabase  // Capture non-isolated reference

        for (index, batch) in batches.enumerated() {
            let operation = CKModifyRecordsOperation(recordsToSave: nil, recordIDsToDelete: batch)
            operation.isAtomic = false

            let deletedInBatch = (try? await performModifyOperationHelper(operation: operation, database: database, batchCount: batch.count)) ?? batch.count
            totalDeleted += deletedInBatch

            // Update progress
            let progress = Double(index + 1) / Double(batches.count)
            _deleteProgress.wrappedValue = max(_deleteProgress.wrappedValue, progress)

            // Small delay between batches to avoid rate limiting
            try await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
        }

        logger.log("Deleted \(totalDeleted) \(recordType.rawValue) records in \(batches.count) batches")
    }

    private nonisolated func performModifyOperationHelper(
        operation: CKModifyRecordsOperation,
        database: CKDatabase,
        batchCount: Int
    ) async throws -> Int {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Int, Error>) in
            operation.modifyRecordsResultBlock = { result in
                switch result {
                case .success:
                    continuation.resume(returning: batchCount)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
            database.add(operation)
        }
    }

    // MARK: - Error Adaptation

    private func adaptCloudKitError(_ error: CKError) -> CloudKitResetError {
        switch error.code {
        case .networkFailure, .networkUnavailable:
            return .networkUnavailable
        case .notAuthenticated:
            return .notAuthenticated
        case .quotaExceeded:
            return .quotaExceeded
        case .requestRateLimited:
            return .rateLimited
        case .zoneNotFound:
            return .zoneNotFound
        case .unknownItem:
            return .recordNotFound
        default:
            return .cloudKitError(error)
        }
    }

    // MARK: - Statistics

    /// Count records of a specific type
    /// - Parameter recordType: The record type to count
    /// - Returns: Number of records
    func countRecords(ofType recordType: CloudKitRecordType) async throws -> Int {
        let predicate = NSPredicate(value: true)
        let query = CKQuery(recordType: recordType.rawValue, predicate: predicate)
        let database = privateDatabase  // Capture non-isolated reference

        do {
            let (matchResults, queryCursor) = try await privateDatabase.records(matching: query)

            var count = matchResults.count

            if let cursor = queryCursor {
                var currentCursor = cursor
                while true {
                    // Use query operation to count
                    let operation = CKQueryOperation(cursor: currentCursor)
                    var hasMoreResults = false
                    var resultCursor: CKQueryOperation.Cursor?

                    await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
                        operation.recordMatchedBlock = { _, _ in
                            hasMoreResults = true
                        }

                        operation.queryResultBlock = { result in
                            switch result {
                            case .success(let cursor):
                                resultCursor = cursor
                            case .failure:
                                break
                            }
                            continuation.resume()
                        }

                        database.add(operation)
                    }

                    count += 1

                    if !hasMoreResults {
                        break
                    }

                    // Update cursor for next iteration
                    guard let newCursor = resultCursor else {
                        break
                    }
                    currentCursor = newCursor

                    if count > 10000 {
                        break
                    }
                }
            }

            return count

        } catch {
            logger.log("Failed to count records: \(error.localizedDescription)")
            return 0
        }
    }
}

// MARK: - CloudKit Reset Error

enum CloudKitResetError: Error {
    case deletionFailed(underlying: Error)
    case cloudKitError(Error)
    case operationCancelled
    case accountNotAvailable
    case notAuthenticated
    case networkUnavailable
    case quotaExceeded
    case rateLimited
    case zoneNotFound
    case recordNotFound

    var localizedDescription: String {
        switch self {
        case .deletionFailed(let error):
            return "Failed to delete CloudKit data: \(error.localizedDescription)"
        case .cloudKitError(let error):
            return "CloudKit error: \(error.localizedDescription)"
        case .operationCancelled:
            return "Operation was cancelled"
        case .accountNotAvailable:
            return "iCloud account is not available"
        case .notAuthenticated:
            return "Not authenticated with iCloud"
        case .networkUnavailable:
            return "Network is unavailable"
        case .quotaExceeded:
            return "iCloud storage quota exceeded"
        case .rateLimited:
            return "Too many requests. Please try again later."
        case .zoneNotFound:
            return "CloudKit zone not found"
        case .recordNotFound:
            return "Record not found"
        }
    }

    var recoverySuggestion: String? {
        switch self {
        case .accountNotAvailable:
            return "Please sign in to iCloud in Settings"
        case .notAuthenticated:
            return "Please sign in to iCloud"
        case .networkUnavailable:
            return "Please check your internet connection"
        case .quotaExceeded:
            return "Please free up space in iCloud or upgrade your storage plan"
        case .rateLimited:
            return "Please wait a few minutes before trying again"
        default:
            return nil
        }
    }
}

// MARK: - Checked Continuation


// MARK: - CloudKitRecordType Extension

extension CloudKitRecordType: Sendable {}
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/CSVGenerator.swift">
import Foundation

/// Generates CSV export from stress measurements
struct CSVGenerator: Sendable {

    // MARK: - Headers

    private static let headers = [
        "timestamp",
        "stress_level",
        "category",
        "hrv_ms",
        "heart_rate_bpm",
        "confidence"
    ]

    // MARK: - Date Formatting

    private static let dateFormatter: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [
            .withInternetDateTime,
            .withFractionalSeconds
        ]
        formatter.timeZone = TimeZone.current
        return formatter
    }()

    // MARK: - Generate CSV

    /// Generate CSV string from measurements
    /// - Parameter measurements: Array of stress measurements to export
    /// - Returns: CSV formatted string
    func generate(from measurements: [StressMeasurement]) -> String {
        guard !measurements.isEmpty else {
            return ""
        }

        var lines: [String] = []

        // Add header row
        lines.append(Self.headers.joined(separator: ","))

        // Add data rows
        for measurement in measurements {
            let row = generateRow(for: measurement)
            lines.append(row)
        }

        return lines.joined(separator: "\n")
    }

    // MARK: - Generate Row

    /// Generate a single CSV row for a measurement
    /// - Parameter measurement: The stress measurement
    /// - Returns: CSV formatted row string
    private func generateRow(for measurement: StressMeasurement) -> String {
        let timestamp = Self.dateFormatter.string(from: measurement.timestamp)
        let stressLevel = String(format: "%.2f", measurement.stressLevel)
        let category = escapeCSV(measurement.category.rawValue)
        let hrv = String(format: "%.2f", measurement.hrv)
        let heartRate = String(format: "%.1f", measurement.restingHeartRate)

        // Average confidence if available, otherwise 0
        let confidence: String
        if let confidences = measurement.confidences, !confidences.isEmpty {
            let avg = confidences.reduce(0, +) / Double(confidences.count)
            confidence = String(format: "%.3f", avg)
        } else {
            confidence = "0.000"
        }

        return [
            escapeCSV(timestamp),
            stressLevel,
            category,
            hrv,
            heartRate,
            confidence
        ].joined(separator: ",")
    }

    // MARK: - CSV Escaping

    /// Escape a CSV field value if needed
    /// - Parameter value: The field value to escape
    /// - Returns: Properly escaped CSV field
    private func escapeCSV(_ value: String) -> String {
        // If value contains comma, quote, or newline, wrap in quotes and escape quotes
        if value.contains(",") || value.contains("\"") || value.contains("\n") {
            let escaped = value.replacingOccurrences(of: "\"", with: "\"\"")
            return "\"\(escaped)\""
        }
        return value
    }

    // MARK: - Generate with Metadata

    /// Generate CSV with additional metadata comments
    /// - Parameters:
    ///   - measurements: Array of stress measurements to export
    ///   - metadata: Export metadata to include as comments
    /// - Returns: CSV formatted string with metadata comments
    func generateWithMetadata(
        from measurements: [StressMeasurement],
        metadata: ExportMetadata
    ) -> String {
        var csvLines: [String] = []

        // Add metadata as comments (lines starting with #)
        csvLines.append("# Stress Monitor Data Export")
        csvLines.append("# Export Date: \(Self.dateFormatter.string(from: metadata.exportDate))")
        csvLines.append("# Device: \(metadata.deviceName)")
        csvLines.append("# App Version: \(metadata.appVersion)")
        csvLines.append("# Measurements: \(metadata.measurementCount)")
        csvLines.append("# Date Range: \(Self.dateFormatter.string(from: metadata.startDate)) to \(Self.dateFormatter.string(from: metadata.endDate))")
        csvLines.append("# Format: \(metadata.format.rawValue.uppercased())")
        csvLines.append("")

        // Add the CSV data
        csvLines.append(generate(from: measurements))

        return csvLines.joined(separator: "\n")
    }
}

// MARK: - Preview Support

#if DEBUG
extension CSVGenerator {
    /// Generate sample CSV for preview/testing
    static func sample() -> String {
        let generator = CSVGenerator()
        let sampleMeasurements = StressMeasurement.samples()
        return generator.generate(from: sampleMeasurements)
    }
}

extension StressMeasurement {
    /// Create sample measurements for testing
    static func samples() -> [StressMeasurement] {
        let calendar = Calendar.current
        let now = Date()

        return (0..<5).map { index in
            let timestamp = calendar.date(byAdding: .hour, value: -index * 2, to: now) ?? now
            return StressMeasurement(
                timestamp: timestamp,
                stressLevel: Double(index * 15),
                hrv: Double(50 - index * 5),
                restingHeartRate: Double(60 + index * 3),
                confidences: [0.85, 0.90, 0.88]
            )
        }
    }
}
#endif
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/DataDeleter.swift">
import Foundation
import SwiftData

@preconcurrency import SwiftData

@MainActor
protocol DataDeleter: Sendable {
    func deleteAllMeasurements(confirmation: (() async -> Bool)?) async throws
    func deleteMeasurements(before date: Date, confirmation: (() async -> Bool)?) async throws
    func deleteMeasurements(in range: ClosedRange<Date>, confirmation: (() async -> Bool)?) async throws
    func resetCloudKitData(confirmation: (() async -> Bool)?) async throws
    func performFactoryReset(confirmation: (() async -> Bool)?) async throws
}

// Default implementation for convenience
extension DataDeleter {
    func deleteAllMeasurements() async throws {
        try await deleteAllMeasurements(confirmation: nil)
    }

    func deleteMeasurements(before date: Date) async throws {
        try await deleteMeasurements(before: date, confirmation: nil)
    }

    func deleteMeasurements(in range: ClosedRange<Date>) async throws {
        try await deleteMeasurements(in: range, confirmation: nil)
    }

    func resetCloudKitData() async throws {
        try await resetCloudKitData(confirmation: nil)
    }

    func performFactoryReset() async throws {
        try await performFactoryReset(confirmation: nil)
    }
}

// MARK: - Delete Error
enum DeletionError: Error {
    case repositoryError(Error)
    case cloudKitError(Error)
    case unauthorizedAccess
    case operationCancelled
}
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/DataDeleterService.swift">
import Foundation
import CloudKit
import SwiftData
import Observation

@preconcurrency import SwiftData

// MARK: - Data Deleter Service
/// Coordinates deletion operations across local SwiftData and CloudKit storage
@MainActor
@Observable
final class DataDeleterService: DataDeleter {

    // MARK: - Published State

    public private(set) var isDeleting = false
    public private(set) var deleteProgress: Double = 0.0
    public private(set) var currentOperation: String?
    public private(set) var errorMessage: String?

    // MARK: - Dependencies

    private let localWipeService: LocalDataWipeService
    private let cloudKitResetService: CloudKitResetService
    private let repository: StressRepositoryProtocol
    private nonisolated let logger: DataManagementLogger

    // MARK: - Initialization

    init(
        modelContext: ModelContext,
        cloudKitContainer: CKContainer = .default(),
        repository: StressRepositoryProtocol,
        logger: DataManagementLogger = .default
    ) {
        self.localWipeService = LocalDataWipeService(modelContext: modelContext, logger: logger)
        self.cloudKitResetService = CloudKitResetService(container: cloudKitContainer, logger: logger)
        self.repository = repository
        self.logger = logger
    }

    // MARK: - DataDeleter Protocol

    /// Delete all measurements from both local and CloudKit storage
    /// - Parameter confirmation: Optional confirmation callback
    public func deleteAllMeasurements(confirmation: (() async -> Bool)? = nil) async throws {
        isDeleting = true
        deleteProgress = 0.0
        currentOperation = "Preparing to delete all measurements"
        errorMessage = nil

        defer {
            isDeleting = false
            currentOperation = nil
        }

        do {
            // Request confirmation if provided
            if let confirmation = confirmation {
                let confirmed = await confirmation()
                guard confirmed else {
                    logger.log("Delete all cancelled by user")
                    throw DeletionError.operationCancelled
                }
            }

            // Phase 1: Delete from CloudKit (0% - 40%)
            currentOperation = "Deleting from CloudKit"
            deleteProgress = 0.1

            try await cloudKitResetService.deleteRecords(
                ofType: .stressMeasurement,
                expectedProgress: 0.1...0.4
            )

            // Phase 2: Delete from local storage (40% - 100%)
            currentOperation = "Deleting from local storage"
            deleteProgress = 0.5

            try await localWipeService.deleteAllMeasurements()

            // Clear cached baseline
            try await repository.updateBaseline(PersonalBaseline())

            deleteProgress = 1.0
            currentOperation = "Deletion complete"
            logger.log("Successfully deleted all measurements from both storage locations")

        } catch let error as DeletionError {
            errorMessage = error.localizedDescription
            logger.log("Delete all failed: \(error.localizedDescription)")
            throw error
        } catch {
            errorMessage = error.localizedDescription
            logger.log("Delete all failed with unexpected error: \(error.localizedDescription)")
            throw DeletionError.repositoryError(error)
        }
    }

    /// Delete measurements older than a specified date from both storage locations
    /// - Parameters:
    ///   - date: Cutoff date
    ///   - confirmation: Optional confirmation callback
    public func deleteMeasurements(before date: Date, confirmation: (() async -> Bool)? = nil) async throws {
        isDeleting = true
        deleteProgress = 0.0
        currentOperation = "Preparing to delete measurements before \(date)"
        errorMessage = nil

        defer {
            isDeleting = false
            currentOperation = nil
        }

        do {
            // Request confirmation if provided
            if let confirmation = confirmation {
                let confirmed = await confirmation()
                guard confirmed else {
                    logger.log("Delete before cancelled by user")
                    throw DeletionError.operationCancelled
                }
            }

            // Phase 1: Delete from CloudKit
            currentOperation = "Deleting from CloudKit"
            deleteProgress = 0.1

            try await cloudKitResetService.deleteRecords(
                ofType: .stressMeasurement,
                before: date
            )

            // Phase 2: Delete from local storage
            currentOperation = "Deleting from local storage"
            deleteProgress = 0.6

            try await localWipeService.deleteMeasurements(before: date)

            // Recalculate baseline if needed
            try await repository.updateBaseline(PersonalBaseline())

            deleteProgress = 1.0
            currentOperation = "Deletion complete"
            logger.log("Successfully deleted measurements before \(date)")

        } catch let error as DeletionError {
            errorMessage = error.localizedDescription
            logger.log("Delete before failed: \(error.localizedDescription)")
            throw error
        } catch {
            errorMessage = error.localizedDescription
            logger.log("Delete before failed with unexpected error: \(error.localizedDescription)")
            throw DeletionError.repositoryError(error)
        }
    }

    /// Delete measurements within a date range from both storage locations
    /// - Parameters:
    ///   - range: Date range for deletion
    ///   - confirmation: Optional confirmation callback
    public func deleteMeasurements(in range: ClosedRange<Date>, confirmation: (() async -> Bool)? = nil) async throws {
        isDeleting = true
        deleteProgress = 0.0
        currentOperation = "Preparing to delete measurements in range"
        errorMessage = nil

        defer {
            isDeleting = false
            currentOperation = nil
        }

        do {
            // Request confirmation if provided
            if let confirmation = confirmation {
                let confirmed = await confirmation()
                guard confirmed else {
                    logger.log("Delete in range cancelled by user")
                    throw DeletionError.operationCancelled
                }
            }

            // Phase 1: Delete from CloudKit
            currentOperation = "Deleting from CloudKit"
            deleteProgress = 0.1

            try await cloudKitResetService.deleteRecords(
                ofType: .stressMeasurement,
                in: range
            )

            // Phase 2: Delete from local storage
            currentOperation = "Deleting from local storage"
            deleteProgress = 0.6

            try await localWipeService.deleteMeasurements(in: range)

            // Recalculate baseline if needed
            try await repository.updateBaseline(PersonalBaseline())

            deleteProgress = 1.0
            currentOperation = "Deletion complete"
            logger.log("Successfully deleted measurements in range \(range)")

        } catch let error as DeletionError {
            errorMessage = error.localizedDescription
            logger.log("Delete in range failed: \(error.localizedDescription)")
            throw error
        } catch {
            errorMessage = error.localizedDescription
            logger.log("Delete in range failed with unexpected error: \(error.localizedDescription)")
            throw DeletionError.repositoryError(error)
        }
    }

    /// Reset all CloudKit data (measurements, baseline, metadata)
    /// - Parameter confirmation: Optional confirmation callback
    public func resetCloudKitData(confirmation: (() async -> Bool)? = nil) async throws {
        isDeleting = true
        deleteProgress = 0.0
        currentOperation = "Preparing CloudKit reset"
        errorMessage = nil

        defer {
            isDeleting = false
            currentOperation = nil
        }

        do {
            // Request confirmation if provided
            if let confirmation = confirmation {
                let confirmed = await confirmation()
                guard confirmed else {
                    logger.log("CloudKit reset cancelled by user")
                    throw DeletionError.operationCancelled
                }
            }

            // Delete all CloudKit records
            try await cloudKitResetService.deleteAllRecords(
                confirmation: nil, // Already confirmed above
                includeBaseline: true
            )

            deleteProgress = 1.0
            currentOperation = "CloudKit reset complete"
            logger.log("Successfully reset all CloudKit data")

        } catch let error as DeletionError {
            errorMessage = error.localizedDescription
            logger.log("CloudKit reset failed: \(error.localizedDescription)")
            throw error
        } catch let error as CloudKitResetError {
            errorMessage = error.localizedDescription
            logger.log("CloudKit reset failed: \(error.localizedDescription)")
            throw DeletionError.cloudKitError(error)
        } catch {
            errorMessage = error.localizedDescription
            logger.log("CloudKit reset failed with unexpected error: \(error.localizedDescription)")
            throw DeletionError.cloudKitError(error)
        }
    }

    /// Perform a complete factory reset - clears all data from both storage locations
    /// - Parameter confirmation: Optional confirmation callback
    public func performFactoryReset(confirmation: (() async -> Bool)? = nil) async throws {
        isDeleting = true
        deleteProgress = 0.0
        currentOperation = "Preparing factory reset"
        errorMessage = nil

        defer {
            isDeleting = false
            currentOperation = nil
        }

        do {
            // Request confirmation if provided
            if let confirmation = confirmation {
                let confirmed = await confirmation()
                guard confirmed else {
                    logger.log("Factory reset cancelled by user")
                    throw DeletionError.operationCancelled
                }
            }

            // Phase 1: Reset CloudKit (0% - 50%)
            currentOperation = "Resetting CloudKit data"
            deleteProgress = 0.05

            try await cloudKitResetService.performDatabaseReset(confirmation: nil)

            // Phase 2: Reset local storage (50% - 90%)
            currentOperation = "Clearing local data"
            deleteProgress = 0.55

            try await localWipeService.deleteAllMeasurements()

            // Phase 3: Reset baseline (90% - 100%)
            currentOperation = "Resetting baseline"
            deleteProgress = 0.9

            try await repository.updateBaseline(PersonalBaseline())

            deleteProgress = 1.0
            currentOperation = "Factory reset complete"
            logger.log("Successfully performed factory reset")

        } catch let error as DeletionError {
            errorMessage = error.localizedDescription
            logger.log("Factory reset failed: \(error.localizedDescription)")
            throw error
        } catch let error as CloudKitResetError {
            errorMessage = error.localizedDescription
            logger.log("Factory reset failed: \(error.localizedDescription)")
            throw DeletionError.cloudKitError(error)
        } catch {
            errorMessage = error.localizedDescription
            logger.log("Factory reset failed with unexpected error: \(error.localizedDescription)")
            throw DeletionError.repositoryError(error)
        }
    }

    // MARK: - Convenience Methods

    /// Get statistics about measurements that would be affected by deletion
    /// - Parameter date: Cutoff date
    /// - Returns: Count of measurements before the date
    func getDeletionStats(before date: Date) async -> Int {
        return await MainActor.run {
            localWipeService.countMeasurements(before: date)
        }
    }

    /// Get statistics about measurements in a date range
    /// - Parameter range: Date range
    /// - Returns: Count of measurements in the range
    func getDeletionStats(in range: ClosedRange<Date>) async -> Int {
        return await MainActor.run {
            localWipeService.countMeasurements(in: range)
        }
    }

    /// Get total count of all measurements
    /// - Returns: Total count
    func getTotalCount() async -> Int {
        return await MainActor.run {
            localWipeService.totalCount()
        }
    }

    // MARK: - Error Recovery

    /// Clear any pending error state
    func clearError() {
        errorMessage = nil
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/DataExporter.swift">
import Foundation
import UniformTypeIdentifiers

protocol DataExporter: Sendable {
    func exportToCSV(measurements: [StressMeasurement]) async throws -> URL
    func exportToJSON(measurements: [StressMeasurement], baseline: PersonalBaseline) async throws -> URL
    func generateReport(startDate: Date, endDate: Date) async throws -> URL
}
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/DataManagementService.swift">
import Foundation
import UIKit
import SwiftData
import Observation
import CloudKit

/// Main service for data export and deletion operations
@MainActor
@Observable
public final class DataManagementService: DataExporter, DataDeleter {

    // MARK: - Properties

    public var isExporting: Bool = false
    public var exportProgress: Double = 0.0
    public var exportError: Error?

    private let repository: StressRepositoryProtocol
    private let cloudKitManager: CloudKitManager?
    private let fileManager: FileManager
    private let csvGenerator: CSVGenerator
    private let jsonGenerator: JSONGenerator

    private var exportTask: Task<URL, Error>?

    // MARK: - Initialization

    init(
        repository: StressRepositoryProtocol,
        cloudKitManager: CloudKitManager? = nil,
        fileManager: FileManager = .default
    ) {
        self.repository = repository
        self.cloudKitManager = cloudKitManager
        self.fileManager = fileManager
        self.csvGenerator = CSVGenerator()
        self.jsonGenerator = JSONGenerator()
    }

    // MARK: - DataExporter Protocol

    /// Export measurements to CSV format
    /// - Parameter measurements: Array of measurements to export
    /// - Returns: URL to the exported CSV file
    /// - Throws: ExportError if export fails
    public func exportToCSV(measurements: [StressMeasurement]) async throws -> URL {
        guard !measurements.isEmpty else {
            throw ExportError.noData
        }

        isExporting = true
        exportProgress = 0.0
        exportError = nil

        defer {
            isExporting = false
            exportTask = nil
        }

        exportTask = Task<URL, Error> {
            do {
                // Generate CSV content
                exportProgress = 0.2
                let csvContent = csvGenerator.generate(from: measurements)

                // Create export metadata
                exportProgress = 0.4
                let metadata = createMetadata(from: measurements, format: .csv)

                // Add metadata as comments
                let csvWithMetadata = csvGenerator.generateWithMetadata(
                    from: measurements,
                    metadata: metadata
                )

                // Write to temp file
                exportProgress = 0.6
                let fileURL = try createTempFile(
                    fileName: "stress_export_\(metadata.exportDate.timeIntervalSince1970).csv",
                    content: csvWithMetadata
                )

                exportProgress = 1.0
                return fileURL
            } catch {
                exportError = error
                throw error
            }
        }

        guard let task = exportTask else {
            throw ExportError.fileWriteFailed(NSError())
        }

        let result = try await task.value
        guard let fileURL = result as? URL else {
            throw ExportError.encodingFailed
        }
        return fileURL
    }

    /// Export measurements to JSON format
    /// - Parameters:
    ///   - measurements: Array of measurements to export
    ///   - baseline: Personal baseline data to include
    /// - Returns: URL to the exported JSON file
    /// - Throws: ExportError if export fails
    func exportToJSON(
        measurements: [StressMeasurement],
        baseline: PersonalBaseline
    ) async throws -> URL {
        guard !measurements.isEmpty else {
            throw ExportError.noData
        }

        isExporting = true
        exportProgress = 0.0
        exportError = nil

        defer {
            isExporting = false
            exportTask = nil
        }

        exportTask = Task<URL, Error> {
            do {
                // Create export metadata
                exportProgress = 0.2
                let metadata = createMetadata(from: measurements, format: .json)

                // Validate data
                exportProgress = 0.3
                _ = try jsonGenerator.validate(
                    measurements: measurements,
                    baseline: baseline,
                    metadata: metadata
                )

                // Generate JSON content
                exportProgress = 0.5
                let jsonContent = try jsonGenerator.generate(
                    from: measurements,
                    baseline: baseline,
                    metadata: metadata
                )

                // Write to temp file
                exportProgress = 0.8
                let fileURL = try createTempFile(
                    fileName: "stress_export_\(metadata.exportDate.timeIntervalSince1970).json",
                    content: jsonContent
                )

                exportProgress = 1.0
                return fileURL
            } catch {
                exportError = error
                throw error
            }
        }

        guard let task = exportTask else {
            throw ExportError.fileWriteFailed(NSError())
        }

        let result = try await task.value
        guard let fileURL = result as? URL else {
            throw ExportError.encodingFailed
        }
        return fileURL
    }

    /// Generate a report for a date range
    /// - Parameters:
    ///   - startDate: Start date of the report
    ///   - endDate: End date of the report
    /// - Returns: URL to the generated report file
    /// - Throws: ExportError if report generation fails
    public func generateReport(startDate: Date, endDate: Date) async throws -> URL {
        isExporting = true
        exportProgress = 0.0
        exportError = nil

        defer {
            isExporting = false
            exportTask = nil
        }

        exportTask = Task<URL, Error> {
            do {
                // Fetch measurements for date range
                exportProgress = 0.2
                let measurements = try await repository.fetchMeasurements(from: startDate, to: endDate)

                guard !measurements.isEmpty else {
                    throw ExportError.noData
                }

                // Get baseline
                exportProgress = 0.4
                let baseline = try await repository.getBaseline()

                // Generate JSON report
                exportProgress = 0.6
                let metadata = ExportMetadata(
                    exportDate: Date(),
                    deviceName: UIDevice.current.name,
                    appVersion: Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0",
                    measurementCount: measurements.count,
                    startDate: startDate,
                    endDate: endDate,
                    format: .json
                )

                let jsonContent = try jsonGenerator.generate(
                    from: measurements,
                    baseline: baseline,
                    metadata: metadata
                )

                // Write to temp file
                exportProgress = 0.8
                let fileName = "stress_report_\(startDate.timeIntervalSince1970)_\(endDate.timeIntervalSince1970).json"
                let fileURL = try createTempFile(fileName: fileName, content: jsonContent)

                exportProgress = 1.0
                return fileURL
            } catch {
                exportError = error
                throw error
            }
        }

        guard let task = exportTask else {
            throw ExportError.fileWriteFailed(NSError())
        }

        let result = try await task.value
        guard let fileURL = result as? URL else {
            throw ExportError.encodingFailed
        }
        return fileURL
    }

    // MARK: - Helper Methods

    /// Create export metadata from measurements
    /// - Parameters:
    ///   - measurements: Array of measurements
    ///   - format: Export format
    /// - Returns: ExportMetadata struct
    private func createMetadata(
        from measurements: [StressMeasurement],
        format: DataExportFormat
    ) -> ExportMetadata {
        let dates = measurements.map { $0.timestamp }
        let startDate = dates.min() ?? Date()
        let endDate = dates.max() ?? Date()

        return ExportMetadata(
            exportDate: Date(),
            deviceName: UIDevice.current.name,
            appVersion: Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0",
            measurementCount: measurements.count,
            startDate: startDate,
            endDate: endDate,
            format: format
        )
    }

    /// Create a temporary file with content
    /// - Parameters:
    ///   - fileName: Name of the file to create
    ///   - content: String content to write
    /// - Returns: URL to the created file
    /// - Throws: ExportError if file creation fails
    private func createTempFile(fileName: String, content: String) throws -> URL {
        let tempDir = fileManager.temporaryDirectory
        let fileURL = tempDir.appendingPathComponent(fileName)

        do {
            try content.write(to: fileURL, atomically: true, encoding: .utf8)
            return fileURL
        } catch {
            throw ExportError.fileWriteFailed(error)
        }
    }

    /// Clean up temporary export files
    /// - Parameter olderThan: Delete files older than this date
    public func cleanupTempFiles(olderThan: Date) throws {
        let tempDir = fileManager.temporaryDirectory
        let files = try fileManager.contentsOfDirectory(at: tempDir, includingPropertiesForKeys: nil)

        for file in files {
            if file.pathExtension == "csv" || file.pathExtension == "json" {
                let attributes = try file.resourceValues(forKeys: [.contentModificationDateKey])
                if let modDate = attributes.contentModificationDate, modDate < olderThan {
                    try fileManager.removeItem(at: file)
                }
            }
        }
    }

    /// Cancel ongoing export operation
    public func cancelExport() {
        exportTask?.cancel()
        exportTask = nil
        isExporting = false
        exportProgress = 0.0
    }

    /// Get estimated export file size for measurements
    /// - Parameters:
    ///   - measurements: Array of measurements
    ///   - format: Export format
    /// - Returns: Estimated file size in bytes
    public func estimateExportSize(
        for measurements: [StressMeasurement],
        format: DataExportFormat
    ) -> Int {
        // Rough estimation based on measurement count
        let baseSize = 500 // Metadata overhead
        let perItemSize = format == .json ? 300 : 150
        return baseSize + (measurements.count * perItemSize)
    }

    // MARK: - DataDeleter Protocol (with confirmation)

    /// Delete all measurements from local storage
    /// - Parameter confirmation: Optional confirmation callback
    /// - Throws: DeletionError if deletion fails
    public func deleteAllMeasurements(confirmation: (() async -> Bool)?) async throws {
        // If confirmation provided, check it first
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                throw DeletionError.operationCancelled
            }
        }

        do {
            try await repository.deleteAllMeasurements()
        } catch {
            throw DeletionError.repositoryError(error)
        }
    }

    /// Delete measurements older than a specific date
    /// - Parameters:
    ///   - date: Cutoff date - measurements before this will be deleted
    ///   - confirmation: Optional confirmation callback
    /// - Throws: DeletionError if deletion fails
    public func deleteMeasurements(before date: Date, confirmation: (() async -> Bool)?) async throws {
        // If confirmation provided, check it first
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                throw DeletionError.operationCancelled
            }
        }

        do {
            try await repository.deleteOlderThan(date)
        } catch {
            throw DeletionError.repositoryError(error)
        }
    }

    /// Delete measurements within a date range
    /// - Parameters:
    ///   - range: Date range of measurements to delete
    ///   - confirmation: Optional confirmation callback
    /// - Throws: DeletionError if deletion fails
    public func deleteMeasurements(in range: ClosedRange<Date>, confirmation: (() async -> Bool)?) async throws {
        // If confirmation provided, check it first
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                throw DeletionError.operationCancelled
            }
        }

        // Fetch measurements in range
        let measurements = try await repository.fetchMeasurements(
            from: range.lowerBound,
            to: range.upperBound
        )

        // Delete each measurement
        for measurement in measurements {
            try await repository.delete(measurement)
        }
    }

    /// Reset CloudKit data by deleting all remote records
    /// - Parameter confirmation: Optional confirmation callback
    /// - Throws: DeletionError if reset fails
    public func resetCloudKitData(confirmation: (() async -> Bool)?) async throws {
        // If confirmation provided, check it first
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                throw DeletionError.operationCancelled
            }
        }

        guard let cloudKit = cloudKitManager else {
            throw DeletionError.cloudKitError(NSError(
                domain: "CloudKit",
                code: -1,
                userInfo: [NSLocalizedDescriptionKey: "CloudKit manager not available"]
            ))
        }

        do {
            // Fetch all remote measurements
            let remoteMeasurements = try await cloudKit.fetchMeasurements()

            // Delete each remote measurement
            for measurement in remoteMeasurements {
                try await cloudKit.deleteMeasurement(measurement)
            }
        } catch {
            throw DeletionError.cloudKitError(error)
        }
    }

    /// Perform a complete factory reset - local data and CloudKit
    /// - Parameter confirmation: Optional confirmation callback
    /// - Warning: This action cannot be undone
    /// - Throws: DeletionError if reset fails
    public func performFactoryReset(confirmation: (() async -> Bool)?) async throws {
        // If confirmation provided, check it first
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                throw DeletionError.operationCancelled
            }
        }

        // Delete all local measurements
        try await deleteAllMeasurements(confirmation: nil)

        // Reset CloudKit data
        try await resetCloudKitData(confirmation: nil)

        // Clear any cached baseline
        try await repository.updateBaseline(PersonalBaseline())
    }
}

// MARK: - Preview Support

#if DEBUG
extension DataManagementService {
    /// Create a sample service for preview/testing
    static func sample() -> DataManagementService {
        let context = ModelContext(try! ModelContainer(for: StressMeasurement.self))
        let repository = StressRepository(modelContext: context)
        return DataManagementService(repository: repository)
    }
}
#endif
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/DataManagementUtilities.swift">
import Foundation
import os.log

// MARK: - Observer Isolated

/// Helper class for thread-safe state observation in @MainActor classes
@Observable
public class ObserverIsolated<T>: Sendable {
    public var wrappedValue: T

    public init(_ value: T) {
        self.wrappedValue = value
    }
}

// MARK: - Logger

public struct DataManagementLogger {
    public static let `default` = DataManagementLogger()

    public func log(_ message: String, category: String = "DataManagement") {
        #if DEBUG
        print("[\(category)] \(message)")
        #endif
        os_log("%{public}@", log: .default, type: .info, message)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/JSONGenerator.swift">
import Foundation

/// Generates JSON export with full structure including metadata, baseline, measurements, and summary
struct JSONGenerator: Sendable {

    // MARK: - Date Formatting

    private static let dateFormatter: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [
            .withInternetDateTime,
            .withFractionalSeconds
        ]
        formatter.timeZone = TimeZone.current
        return formatter
    }()

    private static let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        return encoder
    }()

    // MARK: - Generate JSON

    /// Generate complete JSON export string
    /// - Parameters:
    ///   - measurements: Array of stress measurements to export
    ///   - baseline: Personal baseline data
    ///   - metadata: Export metadata
    /// - Returns: JSON formatted string
    /// - Throws: ExportError if encoding fails
    func generate(
        from measurements: [StressMeasurement],
        baseline: PersonalBaseline,
        metadata: ExportMetadata
    ) throws -> String {
        guard !measurements.isEmpty else {
            throw ExportError.noData
        }

        // Create snapshots
        let snapshots = measurements.map { StressSnapshot(from: $0) }

        // Create summary
        let summary = ExportSummary(from: measurements)

        // Create baseline data
        let baselineData = BaselineData(from: baseline)

        // Create full export structure
        let export = JSONExport(
            metadata: metadata,
            baseline: baselineData,
            measurements: snapshots,
            summary: summary
        )

        // Encode to JSON
        do {
            let jsonData = try Self.encoder.encode(export)
            guard let jsonString = String(data: jsonData, encoding: .utf8) else {
                throw ExportError.encodingFailed
            }
            return jsonString
        } catch {
            throw ExportError.encodingFailed
        }
    }

    // MARK: - Generate with Custom Sorting

    /// Generate JSON with custom field ordering for better readability
    /// - Parameters:
    ///   - measurements: Array of stress measurements to export
    ///   - baseline: Personal baseline data
    ///   - metadata: Export metadata
    /// - Returns: JSON formatted string with custom field ordering
    /// - Throws: ExportError if encoding fails
    func generateWithCustomSorting(
        from measurements: [StressMeasurement],
        baseline: PersonalBaseline,
        metadata: ExportMetadata
    ) throws -> String {
        let json = try generate(from: measurements, baseline: baseline, metadata: metadata)

        // Apply custom formatting if needed
        return formatJSONString(json)
    }

    // MARK: - Format JSON String

    /// Apply additional formatting to JSON string
    /// - Parameter jsonString: Raw JSON string
    /// - Returns: Formatted JSON string
    private func formatJSONString(_ jsonString: String) -> String {
        // Add export header comment
        let header = """
        {
          "_comment": "Stress Monitor Data Export",
          "_formatVersion": "1.0",
        """

        // Insert header after opening brace
        let formatted = jsonString.hasPrefix("{") ? header + String(jsonString.dropFirst()) : jsonString

        return formatted
    }

    // MARK: - Generate Minimal JSON

    /// Generate minimal JSON without pretty printing for smaller file size
    /// - Parameters:
    ///   - measurements: Array of stress measurements to export
    ///   - baseline: Personal baseline data
    ///   - metadata: Export metadata
    /// - Returns: Compact JSON formatted string
    /// - Throws: ExportError if encoding fails
    func generateMinimal(
        from measurements: [StressMeasurement],
        baseline: PersonalBaseline,
        metadata: ExportMetadata
    ) throws -> String {
        guard !measurements.isEmpty else {
            throw ExportError.noData
        }

        let encoder: JSONEncoder = {
            let encoder = JSONEncoder()
            encoder.dateEncodingStrategy = .iso8601
            encoder.outputFormatting = [] // No pretty printing
            return encoder
        }()

        let snapshots = measurements.map { StressSnapshot(from: $0) }
        let summary = ExportSummary(from: measurements)
        let baselineData = BaselineData(from: baseline)

        let export = JSONExport(
            metadata: metadata,
            baseline: baselineData,
            measurements: snapshots,
            summary: summary
        )

        do {
            let jsonData = try encoder.encode(export)
            guard let jsonString = String(data: jsonData, encoding: .utf8) else {
                throw ExportError.encodingFailed
            }
            return jsonString
        } catch {
            throw ExportError.encodingFailed
        }
    }

    // MARK: - Generate Measurement Array Only

    /// Generate JSON containing only measurements array
    /// - Parameter measurements: Array of stress measurements to export
    /// - Returns: JSON formatted string
    /// - Throws: ExportError if encoding fails
    func generateMeasurementsOnly(from measurements: [StressMeasurement]) throws -> String {
        guard !measurements.isEmpty else {
            throw ExportError.noData
        }

        let snapshots = measurements.map { StressSnapshot(from: $0) }

        do {
            let jsonData = try Self.encoder.encode(snapshots)
            guard let jsonString = String(data: jsonData, encoding: .utf8) else {
                throw ExportError.encodingFailed
            }
            return jsonString
        } catch {
            throw ExportError.encodingFailed
        }
    }

    // MARK: - Validate JSON

    /// Validate JSON structure before export
    /// - Parameters:
    ///   - measurements: Array of stress measurements
    ///   - baseline: Personal baseline data
    ///   - metadata: Export metadata
    /// - Returns: True if valid, throws error otherwise
    /// - Throws: ExportError if validation fails
    func validate(
        measurements: [StressMeasurement],
        baseline: PersonalBaseline,
        metadata: ExportMetadata
    ) throws -> Bool {
        guard !measurements.isEmpty else {
            throw ExportError.noData
        }

        // Validate date range
        guard metadata.startDate <= metadata.endDate else {
            throw ExportError.invalidPath
        }

        // Validate measurement count matches metadata
        guard metadata.measurementCount == measurements.count else {
            throw ExportError.encodingFailed
        }

        // Validate baseline values
        guard baseline.restingHeartRate > 0 && baseline.baselineHRV > 0 else {
            throw ExportError.encodingFailed
        }

        return true
    }
}

// MARK: - Preview Support

#if DEBUG
extension JSONGenerator {
    /// Generate sample JSON for preview/testing
    static func sample() throws -> String {
        let generator = JSONGenerator()
        let sampleMeasurements = StressMeasurement.samples()
        let baseline = PersonalBaseline(
            restingHeartRate: 62.0,
            baselineHRV: 48.0,
            lastUpdated: Date()
        )
        let metadata = ExportMetadata(
            exportDate: Date(),
            deviceName: "iPhone 15 Pro",
            appVersion: "1.0.0",
            measurementCount: sampleMeasurements.count,
            startDate: sampleMeasurements.last?.timestamp ?? Date(),
            endDate: sampleMeasurements.first?.timestamp ?? Date(),
            format: .json
        )

        return try generator.generate(
            from: sampleMeasurements,
            baseline: baseline,
            metadata: metadata
        )
    }
}
#endif
</file>

<file path="StressMonitor/StressMonitor/Services/DataManagement/LocalDataWipeService.swift">
import Foundation
import SwiftData
import os.log

// MARK: - Local Data Wipe Service
/// Handles batch deletion of stress measurements from SwiftData local storage
@MainActor
final class LocalDataWipeService: Sendable {

    // MARK: - Properties

    private let modelContext: ModelContext
    private nonisolated let logger: DataManagementLogger

    // MARK: - Progress Tracking

    private var _isDeleting: ObserverIsolated<Bool> = ObserverIsolated(false)
    private var _deleteProgress: ObserverIsolated<Double> = ObserverIsolated(0.0)
    private var _currentOperation: ObserverIsolated<String?> = ObserverIsolated(nil)

    var isDeleting: Bool { _isDeleting.wrappedValue }
    var deleteProgress: Double { _deleteProgress.wrappedValue }
    var currentOperation: String? { _currentOperation.wrappedValue }

    // MARK: - Initialization

    init(modelContext: ModelContext, logger: DataManagementLogger = .default) {
        self.modelContext = modelContext
        self.logger = logger
    }

    // MARK: - Delete Operations

    /// Delete all stress measurements from local storage
    /// - Parameter confirmation: Optional confirmation callback before proceeding
    /// - Throws: LocalDataError if deletion fails
    func deleteAllMeasurements(confirmation: (() async -> Bool)? = nil) async throws {
        _isDeleting.wrappedValue = true
        _deleteProgress.wrappedValue = 0.0
        _currentOperation.wrappedValue = "Preparing to delete all measurements"

        defer {
            _isDeleting.wrappedValue = false
            _currentOperation.wrappedValue = nil
        }

        // Request confirmation if callback provided
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                logger.log("Deletion cancelled by user")
                throw LocalDataError.operationCancelled
            }
        }

        do {
            _currentOperation.wrappedValue = "Fetching all measurements"
            _deleteProgress.wrappedValue = 0.1

            let descriptor = FetchDescriptor<StressMeasurement>()
            let allMeasurements = try modelContext.fetch(descriptor)

            guard !allMeasurements.isEmpty else {
                logger.log("No measurements to delete")
                _deleteProgress.wrappedValue = 1.0
                return
            }

            _currentOperation.wrappedValue = "Deleting \(allMeasurements.count) measurements"
            logger.log("Deleting \(allMeasurements.count) measurements from local storage")

            let total = Double(allMeasurements.count)
            for (index, measurement) in allMeasurements.enumerated() {
                modelContext.delete(measurement)

                // Update progress every 10% or for the last item
                let progress = Double(index + 1) / total
                if progress > _deleteProgress.wrappedValue + 0.1 || index == allMeasurements.count - 1 {
                    _deleteProgress.wrappedValue = progress
                }
            }

            _currentOperation.wrappedValue = "Saving changes"
            _deleteProgress.wrappedValue = 0.9
            try modelContext.save()

            _deleteProgress.wrappedValue = 1.0
            logger.log("Successfully deleted all \(allMeasurements.count) measurements")

        } catch {
            logger.log("Failed to delete all measurements: \(error.localizedDescription)")
            throw LocalDataError.deletionFailed(underlying: error)
        }
    }

    /// Delete measurements older than a specified date
    /// - Parameters:
    ///   - date: Cutoff date - measurements before this date will be deleted
    ///   - confirmation: Optional confirmation callback before proceeding
    /// - Throws: LocalDataError if deletion fails
    func deleteMeasurements(before date: Date, confirmation: (() async -> Bool)? = nil) async throws {
        _isDeleting.wrappedValue = true
        _deleteProgress.wrappedValue = 0.0
        _currentOperation.wrappedValue = "Preparing to delete old measurements"

        defer {
            _isDeleting.wrappedValue = false
            _currentOperation.wrappedValue = nil
        }

        // Request confirmation if callback provided
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                logger.log("Deletion cancelled by user")
                throw LocalDataError.operationCancelled
            }
        }

        do {
            _currentOperation.wrappedValue = "Finding measurements before \(date)"
            _deleteProgress.wrappedValue = 0.1

            let descriptor = FetchDescriptor<StressMeasurement>(
                predicate: #Predicate<StressMeasurement> { $0.timestamp < date }
            )
            let oldMeasurements = try modelContext.fetch(descriptor)

            guard !oldMeasurements.isEmpty else {
                logger.log("No measurements found before \(date)")
                _deleteProgress.wrappedValue = 1.0
                return
            }

            _currentOperation.wrappedValue = "Deleting \(oldMeasurements.count) measurements"
            logger.log("Deleting \(oldMeasurements.count) measurements from before \(date)")

            let total = Double(oldMeasurements.count)
            for (index, measurement) in oldMeasurements.enumerated() {
                modelContext.delete(measurement)

                let progress = Double(index + 1) / total
                if progress > _deleteProgress.wrappedValue + 0.1 || index == oldMeasurements.count - 1 {
                    _deleteProgress.wrappedValue = progress
                }
            }

            _currentOperation.wrappedValue = "Saving changes"
            _deleteProgress.wrappedValue = 0.9
            try modelContext.save()

            _deleteProgress.wrappedValue = 1.0
            logger.log("Successfully deleted \(oldMeasurements.count) measurements")

        } catch {
            logger.log("Failed to delete measurements before \(date): \(error.localizedDescription)")
            throw LocalDataError.deletionFailed(underlying: error)
        }
    }

    /// Delete measurements within a specific date range
    /// - Parameters:
    ///   - range: ClosedRange of dates defining the deletion window
    ///   - confirmation: Optional confirmation callback before proceeding
    /// - Throws: LocalDataError if deletion fails
    func deleteMeasurements(in range: ClosedRange<Date>, confirmation: (() async -> Bool)? = nil) async throws {
        _isDeleting.wrappedValue = true
        _deleteProgress.wrappedValue = 0.0
        _currentOperation.wrappedValue = "Preparing to delete measurements in range"

        defer {
            _isDeleting.wrappedValue = false
            _currentOperation.wrappedValue = nil
        }

        // Request confirmation if callback provided
        if let confirmation = confirmation {
            let confirmed = await confirmation()
            guard confirmed else {
                logger.log("Deletion cancelled by user")
                throw LocalDataError.operationCancelled
            }
        }

        do {
            _currentOperation.wrappedValue = "Finding measurements in date range"
            _deleteProgress.wrappedValue = 0.1

            let descriptor = FetchDescriptor<StressMeasurement>(
                predicate: #Predicate<StressMeasurement> { measurement in
                    measurement.timestamp >= range.lowerBound && measurement.timestamp <= range.upperBound
                }
            )
            let rangeMeasurements = try modelContext.fetch(descriptor)

            guard !rangeMeasurements.isEmpty else {
                logger.log("No measurements found in range \(range.lowerBound) to \(range.upperBound)")
                _deleteProgress.wrappedValue = 1.0
                return
            }

            _currentOperation.wrappedValue = "Deleting \(rangeMeasurements.count) measurements"
            logger.log("Deleting \(rangeMeasurements.count) measurements in range")

            let total = Double(rangeMeasurements.count)
            for (index, measurement) in rangeMeasurements.enumerated() {
                modelContext.delete(measurement)

                let progress = Double(index + 1) / total
                if progress > _deleteProgress.wrappedValue + 0.1 || index == rangeMeasurements.count - 1 {
                    _deleteProgress.wrappedValue = progress
                }
            }

            _currentOperation.wrappedValue = "Saving changes"
            _deleteProgress.wrappedValue = 0.9
            try modelContext.save()

            _deleteProgress.wrappedValue = 1.0
            logger.log("Successfully deleted \(rangeMeasurements.count) measurements")

        } catch {
            logger.log("Failed to delete measurements in range: \(error.localizedDescription)")
            throw LocalDataError.deletionFailed(underlying: error)
        }
    }

    // MARK: - Batch Operations

    /// Delete a specific batch of measurements
    /// - Parameter measurements: Array of measurements to delete
    /// - Throws: LocalDataError if deletion fails
    func deleteBatch(_ measurements: [StressMeasurement]) async throws {
        guard !measurements.isEmpty else { return }

        _isDeleting.wrappedValue = true
        _currentOperation.wrappedValue = "Deleting batch of \(measurements.count) measurements"

        defer {
            _isDeleting.wrappedValue = false
            _currentOperation.wrappedValue = nil
        }

        do {
            for measurement in measurements {
                modelContext.delete(measurement)
            }
            try modelContext.save()

            logger.log("Successfully deleted batch of \(measurements.count) measurements")

        } catch {
            logger.log("Failed to delete batch: \(error.localizedDescription)")
            throw LocalDataError.deletionFailed(underlying: error)
        }
    }

    // MARK: - Statistics

    /// Get count of measurements that would be deleted before a given date
    /// - Parameter date: Cutoff date
    /// - Returns: Count of measurements before the date
    func countMeasurements(before date: Date) -> Int {
        do {
            let descriptor = FetchDescriptor<StressMeasurement>(
                predicate: #Predicate<StressMeasurement> { $0.timestamp < date }
            )
            return try modelContext.fetchCount(descriptor)
        } catch {
            logger.log("Failed to count measurements: \(error.localizedDescription)")
            return 0
        }
    }

    /// Get count of measurements in a date range
    /// - Parameter range: Date range to query
    /// - Returns: Count of measurements in the range
    func countMeasurements(in range: ClosedRange<Date>) -> Int {
        do {
            let descriptor = FetchDescriptor<StressMeasurement>(
                predicate: #Predicate<StressMeasurement> { measurement in
                    measurement.timestamp >= range.lowerBound && measurement.timestamp <= range.upperBound
                }
            )
            return try modelContext.fetchCount(descriptor)
        } catch {
            logger.log("Failed to count measurements: \(error.localizedDescription)")
            return 0
        }
    }

    /// Get total count of all measurements
    /// - Returns: Total count
    func totalCount() -> Int {
        do {
            let descriptor = FetchDescriptor<StressMeasurement>()
            return try modelContext.fetchCount(descriptor)
        } catch {
            logger.log("Failed to count measurements: \(error.localizedDescription)")
            return 0
        }
    }
}

// MARK: - Local Data Error

enum LocalDataError: Error {
    case deletionFailed(underlying: Error)
    case operationCancelled
    case unauthorizedAccess
    case contextNotFound

    var localizedDescription: String {
        switch self {
        case .deletionFailed(let error):
            return "Failed to delete data: \(error.localizedDescription)"
        case .operationCancelled:
            return "Operation was cancelled"
        case .unauthorizedAccess:
            return "Unauthorized access to data"
        case .contextNotFound:
            return "Data context not found"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/HealthKit/HealthKitManager.swift">
import Foundation
import HealthKit

@MainActor
@Observable
final class HealthKitManager: HealthKitServiceProtocol {
    private let healthStore: HKHealthStore

    private let hrvType = HKQuantityType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!
    private let heartRateType = HKQuantityType.quantityType(forIdentifier: .heartRate)!

    init(healthStore: HKHealthStore = .init()) {
        self.healthStore = healthStore
    }

    func requestAuthorization() async throws {
        let types: Set<HKObjectType> = [hrvType, heartRateType]

        try await healthStore.requestAuthorization(toShare: [] as Set<HKSampleType>, read: types)
    }

    func fetchLatestHRV() async throws -> HRVMeasurement? {
        let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)

        return try await withCheckedThrowingContinuation { continuation in
            var queryHasReturned = false

            let wrappedQuery = HKSampleQuery(
                sampleType: self.hrvType,
                predicate: nil,
                limit: 1,
                sortDescriptors: [sortDescriptor]
            ) { _, samples, error in
                guard !queryHasReturned else { return }
                queryHasReturned = true

                if let error {
                    continuation.resume(throwing: error)
                    return
                }

                guard let sample = samples?.first as? HKQuantitySample else {
                    continuation.resume(returning: nil)
                    return
                }

                let value = sample.quantity.doubleValue(for: HKUnit.secondUnit(with: .milli))
                let measurement = HRVMeasurement(value: value, timestamp: sample.endDate)
                continuation.resume(returning: measurement)
            }

            self.healthStore.execute(wrappedQuery)
        }
    }

    func fetchHeartRate(samples: Int) async throws -> [HeartRateSample] {
        let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)

        return try await withCheckedThrowingContinuation { continuation in
            var queryHasReturned = false

            let query = HKSampleQuery(
                sampleType: self.heartRateType,
                predicate: nil,
                limit: samples,
                sortDescriptors: [sortDescriptor]
            ) { _, samples, error in
                guard !queryHasReturned else { return }
                queryHasReturned = true

                if let error {
                    continuation.resume(throwing: error)
                    return
                }

                guard let samples = samples as? [HKQuantitySample] else {
                    continuation.resume(returning: [])
                    return
                }

                let heartRates = samples.map { sample in
                    let value = sample.quantity.doubleValue(for: HKUnit.count().unitDivided(by: .minute()))
                    return HeartRateSample(value: value, timestamp: sample.endDate)
                }

                continuation.resume(returning: heartRates)
            }

            self.healthStore.execute(query)
        }
    }

    func fetchHRVHistory(since: Date) async throws -> [HRVMeasurement] {
        let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)
        let predicate = HKQuery.predicateForSamples(withStart: since, end: nil, options: .strictStartDate)

        return try await withCheckedThrowingContinuation { continuation in
            var queryHasReturned = false

            let query = HKSampleQuery(
                sampleType: self.hrvType,
                predicate: predicate,
                limit: HKObjectQueryNoLimit,
                sortDescriptors: [sortDescriptor]
            ) { _, samples, error in
                guard !queryHasReturned else { return }
                queryHasReturned = true

                if let error {
                    continuation.resume(throwing: error)
                    return
                }

                guard let samples = samples as? [HKQuantitySample] else {
                    continuation.resume(returning: [])
                    return
                }

                let measurements = samples.map { sample in
                    let value = sample.quantity.doubleValue(for: HKUnit.secondUnit(with: .milli))
                    return HRVMeasurement(value: value, timestamp: sample.endDate)
                }

                continuation.resume(returning: measurements)
            }

            self.healthStore.execute(query)
        }
    }

    func observeHeartRateUpdates() -> AsyncStream<HeartRateSample?> {
        return AsyncStream { continuation in
            let query = HKObserverQuery(sampleType: self.heartRateType, predicate: nil) { _, _, error in
                if let error {
                    continuation.yield(nil)
                    return
                }

                Task {
                    do {
                        let samples = try await self.fetchHeartRate(samples: 1)
                        continuation.yield(samples.first)
                    } catch {
                        continuation.yield(nil)
                    }
                }
            }

            self.healthStore.execute(query)

            continuation.onTermination = { @Sendable _ in
                self.healthStore.stop(query)
            }
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/Protocols/CloudKitServiceProtocol.swift">
import CloudKit
import Foundation

protocol CloudKitServiceProtocol: Sendable {
    // Sync Status
    var syncStatus: SyncStatus { get }
    var lastSyncDate: Date? { get }

    // Operations
    func saveMeasurement(_ measurement: StressMeasurement) async throws
    func fetchMeasurements(since date: Date?) async throws -> [StressMeasurement]
    func deleteMeasurement(_ measurement: StressMeasurement) async throws
    func sync() async throws

    // Subscriptions
    func setupPushSubscription() async throws

    // Account Status
    func checkAccountStatus() async throws -> CloudKitAccountStatus
}

// MARK: - Sync Status
public enum SyncStatus: Sendable {
    case idle
    case syncing(progress: Double)
    case success
    case error(Error)
    case unavailable(NetworkReason)
}

public enum NetworkReason: Sendable {
    case noInternet
    case iCloudNotSignedIn
    case cloudKitDisabled
    case quotaExceeded
}

public enum CloudKitAccountStatus: Sendable {
    case available
    case noAccount
    case restricted
    case unknown
}

// MARK: - Conflict Resolution
public enum ResolutionStrategy: Sendable {
    case timestamp
    case server
    case client
    case devicePriority
}

public enum MergeDecision: Sendable {
    case keepLocal
    case keepRemote
    case merge
}
</file>

<file path="StressMonitor/StressMonitor/Services/Protocols/StressAlgorithmServiceProtocol.swift">
import Foundation

protocol StressAlgorithmServiceProtocol: Sendable {
    func calculateStress(hrv: Double, heartRate: Double) async throws -> StressResult
    func calculateConfidence(hrv: Double, heartRate: Double, samples: Int) -> Double
}
</file>

<file path="StressMonitor/StressMonitor/Services/Sync/ConflictResolver.swift">
import Foundation
import UIKit

public final class ConflictResolver {
    // MARK: - Properties

    public let strategy: ResolutionStrategy
    private let deviceType: DeviceType

    // MARK: - Initialization

    public init(strategy: ResolutionStrategy = .devicePriority) {
        self.strategy = strategy
        self.deviceType = Self.determineDeviceType()
    }

    // MARK: - Device Type Detection

    private static func determineDeviceType() -> DeviceType {
        #if os(watchOS)
        return .watch
        #elseif os(iOS)
        #if targetEnvironment(macCatalyst)
        return .iPad
        #else
        return UIDevice.current.userInterfaceIdiom == .pad ? .iPad : .iPhone
        #endif
        #else
        return .iPhone
        #endif
    }

    // MARK: - Public Resolution Methods

    public func resolve(
        local: StressMeasurement,
        remote: StressMeasurement,
        remoteDeviceID: String? = nil
    ) -> MergeDecision {
        switch strategy {
        case .timestamp:
            return resolveByTimestamp(local: local, remote: remote)
        case .server:
            return .keepRemote
        case .client:
            return .keepLocal
        case .devicePriority:
            return resolveByDevicePriority(
                local: local,
                remote: remote,
                remoteDeviceID: remoteDeviceID
            )
        }
    }

    // MARK: - Timestamp-Based Resolution

    private func resolveByTimestamp(local: StressMeasurement, remote: StressMeasurement) -> MergeDecision {
        let timeDifference = abs(local.timestamp.timeIntervalSince(remote.timestamp))

        // Same timestamp - use merge logic
        if timeDifference < 1.0 {
            return mergeMeasurements(local: local, remote: remote)
        }

        return local.timestamp > remote.timestamp ? .keepLocal : .keepRemote
    }

    // MARK: - Device Priority Resolution

    private func resolveByDevicePriority(
        local: StressMeasurement,
        remote: StressMeasurement,
        remoteDeviceID: String?
    ) -> MergeDecision {
        guard let remoteDeviceID = remoteDeviceID else {
            return resolveByTimestamp(local: local, remote: remote)
        }

        let remoteDeviceType = DeviceType.from(deviceID: remoteDeviceID)
        let comparison = deviceType.compareTo(remoteDeviceType)

        switch comparison {
        case .higher:
            return .keepLocal
        case .lower:
            return .keepRemote
        case .equal:
            return resolveByTimestamp(local: local, remote: remote)
        }
    }

    // MARK: - Merge Logic

    private func mergeMeasurements(local: StressMeasurement, remote: StressMeasurement) -> MergeDecision {
        // If same timestamp and similar values, keep either
        let timeDifference = abs(local.timestamp.timeIntervalSince(remote.timestamp))
        guard timeDifference < 1.0 else {
            return resolveByTimestamp(local: local, remote: remote)
        }

        // Merge by taking max values for each field
        let merged = StressMeasurement(
            timestamp: max(local.timestamp, remote.timestamp),
            stressLevel: max(local.stressLevel, remote.stressLevel),
            hrv: max(local.hrv, remote.hrv),
            restingHeartRate: max(local.restingHeartRate, remote.restingHeartRate),
            confidences: mergeConfidences(local: local.confidences, remote: remote.confidences)
        )

        // Use the category from the measurement with higher stress
        merged.categoryRawValue = local.stressLevel >= remote.stressLevel
            ? local.categoryRawValue
            : remote.categoryRawValue

        // Store merged result
        _ = merged

        return .merge
    }

    private func mergeConfidences(local: [Double]?, remote: [Double]?) -> [Double]? {
        guard let local = local, let remote = remote else {
            return local ?? remote
        }

        let maxLength = max(local.count, remote.count)
        var merged: [Double] = []

        for i in 0..<maxLength {
            let localValue = i < local.count ? local[i] : 0
            let remoteValue = i < remote.count ? remote[i] : 0
            merged.append(max(localValue, remoteValue))
        }

        return merged
    }

    // MARK: - Deleted Record Handling

    public func resolveDeleted(local: StressMeasurement?, remote: StressMeasurement?) -> MergeDecision {
        switch (local, remote) {
        case (nil, nil):
            return .keepLocal
        case (nil, _?):
            return .keepRemote
        case (_?, nil):
            return .keepLocal
        case let (local?, remote?):
            return resolve(local: local, remote: remote, remoteDeviceID: nil)
        }
    }

    // MARK: - Batch Conflict Resolution

    public func resolveBatch(
        localMeasurements: [StressMeasurement],
        remoteMeasurements: [StressMeasurement]
    ) -> [ConflictResolution] {
        var resolutions: [ConflictResolution] = []

        // Create lookup by timestamp for O(n) matching
        let remoteDict = Dictionary(grouping: remoteMeasurements) { measurement in
            Int(measurement.timestamp.timeIntervalSince1970)
        }.compactMapValues { $0.first }

        for local in localMeasurements {
            let timestampKey = Int(local.timestamp.timeIntervalSince1970)
            if let remote = remoteDict[timestampKey] {
                let decision = resolve(local: local, remote: remote)
                resolutions.append(ConflictResolution(
                    local: local,
                    remote: remote,
                    decision: decision
                ))
            } else {
                // No conflict - local only
                resolutions.append(ConflictResolution(
                    local: local,
                    remote: nil,
                    decision: .keepLocal
                ))
            }
        }

        return resolutions
    }
}

// MARK: - Device Type

public enum DeviceType: Int, Sendable {
    case iPhone = 3
    case iPad = 2
    case watch = 1

    func compareTo(_ other: DeviceType) -> DeviceComparisonResult {
        if rawValue > other.rawValue {
            return .higher
        } else if rawValue < other.rawValue {
            return .lower
        } else {
            return .equal
        }
    }

    static func from(deviceID: String) -> DeviceType {
        // Extract device type from device ID prefix
        if deviceID.hasPrefix("watch-") {
            return .watch
        } else if deviceID.hasPrefix("ipad-") {
            return .iPad
        } else {
            return .iPhone
        }
    }
}

public enum DeviceComparisonResult {
    case higher
    case lower
    case equal
}

// MARK: - Conflict Resolution Result

public struct ConflictResolution: Sendable {
    public let local: StressMeasurement
    public let remote: StressMeasurement?
    public let decision: MergeDecision

    public init(local: StressMeasurement, remote: StressMeasurement?, decision: MergeDecision) {
        self.local = local
        self.remote = remote
        self.decision = decision
    }

    public var hasConflict: Bool {
        return remote != nil
    }

    public var winningMeasurement: StressMeasurement {
        switch decision {
        case .keepLocal:
            return local
        case .keepRemote:
            return remote ?? local
        case .merge:
            return local
        }
    }
}

// MARK: - Merge Decision Extension

extension MergeDecision {
    public var shouldKeepLocal: Bool {
        if case .keepLocal = self { return true }
        return false
    }

    public var shouldKeepRemote: Bool {
        if case .keepRemote = self { return true }
        return false
    }

    public var shouldMerge: Bool {
        if case .merge = self { return true }
        return false
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/Sync/SyncManager.swift">
import CloudKit
import Foundation
import Observation
import SwiftUI

@MainActor
@Observable
public final class SyncManager {
    // MARK: - Properties

    public private(set) var syncStatus: SyncStatus = .idle
    public private(set) var lastSyncDate: Date?
    public private(set) var syncError: Error?

    private let cloudKitManager: CloudKitManager
    private let syncEngine: CloudKitSyncEngine
    private let conflictResolver: ConflictResolver

    private var syncTask: Task<Void, Never>?
    private var backgroundTask: UIBackgroundTaskIdentifier = .invalid

    // MARK: - Initialization

    public init(
        cloudKitManager: CloudKitManager,
        conflictResolver: ConflictResolver = ConflictResolver()
    ) {
        self.cloudKitManager = cloudKitManager
        self.conflictResolver = conflictResolver
        self.syncEngine = CloudKitSyncEngine(cloudKitManager: cloudKitManager)

        // Initialize from cloud kit manager state
        self.syncStatus = .idle
        self.lastSyncDate = nil
    }

    public static func create() -> SyncManager {
        return SyncManager(
            cloudKitManager: CloudKitManager(),
            conflictResolver: ConflictResolver()
        )
    }

    // MARK: - Public Sync Methods

    public func sync(localMeasurements: [StressMeasurement]) async throws {
        guard syncTask == nil else {
            throw SyncError.syncInProgress
        }

        syncStatus = .syncing(progress: 0.0)
        syncError = nil

        syncTask = Task {
            do {
                // Check account status first
                let accountStatus = try await cloudKitManager.checkAccountStatus()
                guard accountStatus == .available else {
                    self.syncStatus = .unavailable(.iCloudNotSignedIn)
                    self.syncError = SyncError.accountNotAvailable
                    self.syncTask = nil
                    return
                }

                // Perform bidirectional sync
                let remoteMeasurements = try await syncEngine.sync(localMeasurements: localMeasurements)

                // Resolve any conflicts
                let resolutions = conflictResolver.resolveBatch(
                    localMeasurements: localMeasurements,
                    remoteMeasurements: remoteMeasurements
                )

                // Apply resolutions
                var syncedMeasurements: [StressMeasurement] = []
                for resolution in resolutions {
                    switch resolution.decision {
                    case .keepLocal:
                        syncedMeasurements.append(resolution.local)
                    case .keepRemote:
                        if let remote = resolution.remote {
                            syncedMeasurements.append(remote)
                        }
                    case .merge:
                        syncedMeasurements.append(resolution.winningMeasurement)
                    }
                }

                // Upload merged results if needed
                let needsUpload = resolutions.contains { $0.decision == .merge || $0.decision == .keepLocal }
                if needsUpload {
                    try await cloudKitManager.saveMeasurement(localMeasurements.first!)
                }

                lastSyncDate = Date()
                syncStatus = .success
            } catch {
                syncError = error
                syncStatus = .error(error)
            }

            syncTask = nil
        }

        await syncTask?.value
    }

    public func quickSync() async throws {
        syncStatus = .syncing(progress: 0.0)
        syncError = nil

        do {
            try await cloudKitManager.sync()
            lastSyncDate = Date()
            syncStatus = .success
        } catch {
            syncError = error
            syncStatus = .error(error)
            throw error
        }
    }

    // MARK: - Lifecycle Event Handlers

    public func handleAppWillEnterForeground() async {
        // Trigger sync when app comes to foreground
        try? await quickSync()
    }

    public func handleAppWillResignActive() async {
        // Perform quick sync before going to background
        await beginBackgroundSync()
    }

    public func handleAppDidBecomeActive() async {
        // Cancel background sync and do a fresh sync
        endBackgroundSync()
        try? await quickSync()
    }

    // MARK: - Background Sync

    private func beginBackgroundSync() async {
        guard backgroundTask == .invalid else { return }

        backgroundTask = UIApplication.shared.beginBackgroundTask { [weak self] in
            self?.endBackgroundSync()
        }

        // Perform background sync
        do {
            try await syncEngine.performBackgroundSync()
            lastSyncDate = Date()
        } catch {
            syncError = error
        }

        endBackgroundSync()
    }

    private func endBackgroundSync() {
        guard backgroundTask != .invalid else { return }

        UIApplication.shared.endBackgroundTask(backgroundTask)
        backgroundTask = .invalid
    }

    // MARK: - Remote Change Handling

    public func handleRemoteNotification(_ userInfo: [AnyHashable: Any]) async {
        guard CKNotification(fromRemoteNotificationDictionary: userInfo) != nil else {
            return
        }

        do {
            try await quickSync()
        } catch {
            syncError = error
        }
    }

    // MARK: - Manual Sync Trigger

    public func manualSync() async throws {
        try await sync(localMeasurements: [])
    }

    // MARK: - Status Checks

    public var isSyncing: Bool {
        if case .syncing = syncStatus {
            return true
        }
        return false
    }

    public var syncProgress: Double {
        if case .syncing(let progress) = syncStatus {
            return progress
        }
        return 0.0
    }

    public var canSync: Bool {
        if case .unavailable = syncStatus {
            return false
        }
        return true
    }

    // MARK: - Setup

    public func setup() async throws {
        // Setup push subscription for remote changes
        try await cloudKitManager.setupPushSubscription()

        // Check initial account status
        let accountStatus = try await cloudKitManager.checkAccountStatus()

        if accountStatus != .available {
            syncStatus = .unavailable(.iCloudNotSignedIn)
        }
    }

    // MARK: - Reset

    public func reset() {
        syncTask?.cancel()
        syncTask = nil
        syncStatus = .idle
        syncError = nil
        syncEngine.reset()
    }
}

// MARK: - Sync Errors

public enum SyncError: Error, Sendable {
    case syncInProgress
    case accountNotAvailable
    case networkUnavailable
    case quotaExceeded
    case unknown(Error)

    public var localizedDescription: String {
        switch self {
        case .syncInProgress:
            return "A sync operation is already in progress"
        case .accountNotAvailable:
            return "iCloud account is not available"
        case .networkUnavailable:
            return "Network is not available"
        case .quotaExceeded:
            return "iCloud storage quota exceeded"
        case .unknown(let error):
            return error.localizedDescription
        }
    }
}

// MARK: - SyncManager Environment Key

struct SyncManagerKey: EnvironmentKey {
    static let defaultValue: SyncManager? = nil
}

extension EnvironmentValues {
    public var syncManager: SyncManager? {
        get { self[SyncManagerKey.self] }
        set { self[SyncManagerKey.self] = newValue }
    }
}

extension View {
    public func syncManager(_ manager: SyncManager) -> some View {
        environment(\.syncManager, manager)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/InsightGeneratorService.swift">
import Foundation

/// Local rules engine for generating stress insights
enum InsightGenerator {

    /// Generate an insight from current stress and historical data
    static func generate(from stress: StressResult, history: [StressMeasurement]) -> AIInsight? {
        // Check for high stress
        if stress.level > 75 {
            return AIInsight(
                title: "High Stress Detected",
                message: "Your stress level is elevated. Consider taking a short break or trying a breathing exercise.",
                actionTitle: "Start Breathing",
                trendData: extractTrendData(from: history)
            )
        }

        // Check for improving trend
        if let trend = calculateTrend(from: history), trend < -5 {
            return AIInsight(
                title: "Improving Trend",
                message: "Your stress levels have been decreasing. Keep up the good work with your wellness routine.",
                actionTitle: nil,
                trendData: extractTrendData(from: history)
            )
        }

        // Check for worsening trend
        if let trend = calculateTrend(from: history), trend > 5 {
            return AIInsight(
                title: "Rising Stress",
                message: "Your stress has been increasing over recent measurements. Consider stress-reduction techniques.",
                actionTitle: nil,
                trendData: extractTrendData(from: history)
            )
        }

        // Check for excellent HRV
        if stress.hrv > 60 {
            return AIInsight(
                title: "Excellent Recovery",
                message: "Your HRV is great today, indicating good recovery. This is a good time for challenging activities.",
                actionTitle: nil,
                trendData: extractTrendData(from: history)
            )
        }

        // Default insight for relaxed state
        if stress.level <= 25 {
            return AIInsight(
                title: "Feeling Calm",
                message: "You're in a relaxed state. Great time for focused work or creative activities.",
                actionTitle: nil,
                trendData: extractTrendData(from: history)
            )
        }

        // No specific insight
        return nil
    }

    // MARK: - Helpers

    /// Calculate trend direction from history (negative = improving, positive = worsening)
    private static func calculateTrend(from history: [StressMeasurement]) -> Double? {
        guard history.count >= 3 else { return nil }

        let recent = Array(history.suffix(3))
        let older = Array(history.dropLast(3).suffix(3))

        guard !older.isEmpty else { return nil }

        let recentAvg = recent.map(\.stressLevel).reduce(0, +) / Double(recent.count)
        let olderAvg = older.map(\.stressLevel).reduce(0, +) / Double(older.count)

        return recentAvg - olderAvg
    }

    /// Extract trend data for sparkline chart
    private static func extractTrendData(from history: [StressMeasurement]) -> [Double] {
        Array(history.suffix(6).map(\.stressLevel))
    }
}
</file>

<file path="StressMonitor/StressMonitor/Theme/DesignTokens.swift">
import SwiftUI

enum DesignTokens {
    enum Spacing {
        static let xs: CGFloat = 4
        static let sm: CGFloat = 8
        static let md: CGFloat = 16
        static let lg: CGFloat = 24
        static let xl: CGFloat = 32
        static let xxl: CGFloat = 48
        static let xxxl: CGFloat = 64
    }

    enum Layout {
        static let cornerRadius: CGFloat = 12
        static let minTouchTarget: CGFloat = 44
        static let cardPadding: CGFloat = 16
        static let sectionSpacing: CGFloat = 24
    }

    enum Typography {
        static let heroSize: CGFloat = 72
        static let largeTitle: CGFloat = 48
        static let title: CGFloat = 34
        static let headline: CGFloat = 22
        static let body: CGFloat = 17
        static let caption: CGFloat = 13
    }

    enum Animation {
        static let defaultDuration: Double = 0.3
        static let slowDuration: Double = 1.0
    }
}
</file>

<file path="StressMonitor/StressMonitor/Theme/Font+WellnessType.swift">
import SwiftUI

// MARK: - Wellness Typography System
extension Font {
    /// Wellness-themed custom fonts with fallbacks to SF Pro
    struct WellnessType {
        // MARK: - Google Fonts Constants

        private static let loraFontName = "Lora"
        private static let ralewayFontName = "Raleway"

        // MARK: - Heading Fonts (Lora - Organic curves, wellness vibe)

        /// Hero number for stress ring center
        static let heroNumber = custom(loraFontName, size: 72, weight: .bold)

        /// Large metric display
        static let largeMetric = custom(loraFontName, size: 48, weight: .bold)

        /// Card titles
        static let cardTitle = custom(loraFontName, size: 28, weight: .bold)

        /// Section headers
        static let sectionHeader = custom(loraFontName, size: 22, weight: .semibold)

        // MARK: - Body Fonts (Raleway - Elegant simplicity, accessible)

        /// Primary content
        static let body = custom(ralewayFontName, size: 17, weight: .regular)

        /// Emphasized text
        static let bodyEmphasized = custom(ralewayFontName, size: 17, weight: .semibold)

        /// Captions and labels
        static let caption = custom(ralewayFontName, size: 13, weight: .regular)

        /// Tiny text
        static let caption2 = custom(ralewayFontName, size: 11, weight: .regular)

        // MARK: - Helper Function

        /// Create custom font with fallback to SF Pro
        private static func custom(_ name: String, size: CGFloat, weight: Font.Weight) -> Font {
            // Try to use custom font first
            if UIFont.familyNames.contains(where: { $0.contains(name) }) {
                return .custom(name, size: size)
            }

            // Fallback to SF Pro system font with same weight
            return .system(size: size, weight: weight, design: .default)
        }
    }
}

// MARK: - Dynamic Type Support
extension View {
    /// Apply Dynamic Type scaling with accessibility support
    /// Limits scaling to accessibility3 and allows minimum 70% scale factor
    func accessibleWellnessType() -> some View {
        self
            .dynamicTypeSize(...DynamicTypeSize.accessibility3)
            .minimumScaleFactor(0.7)
            .lineLimit(nil)
    }

    /// Apply Dynamic Type with single line constraint
    /// Useful for buttons and labels that must stay single-line
    func accessibleWellnessTypeSingleLine() -> some View {
        self
            .dynamicTypeSize(...DynamicTypeSize.accessibility3)
            .minimumScaleFactor(0.7)
            .lineLimit(1)
    }

    /// Apply Dynamic Type with specific line limit
    /// - Parameter lines: Maximum number of lines
    func accessibleWellnessType(lines: Int) -> some View {
        self
            .dynamicTypeSize(...DynamicTypeSize.accessibility3)
            .minimumScaleFactor(0.7)
            .lineLimit(lines)
    }
}

// MARK: - Fallback System Fonts
extension Font {
    /// iOS System Fallback fonts when custom fonts are unavailable
    struct SystemFallback {
        /// Large Title (34pt, Bold)
        static let largeTitle = Font.system(size: 34, weight: .bold)

        /// Title (28pt, Bold)
        static let title = Font.system(size: 28, weight: .bold)

        /// Title 2 (22pt, Bold)
        static let title2 = Font.system(size: 22, weight: .bold)

        /// Body (17pt, Regular)
        static let body = Font.system(size: 17, weight: .regular)

        /// Caption (13pt, Regular)
        static let caption = Font.system(size: 13, weight: .regular)
    }
}

// MARK: - Font Registration Helper
/// Helper to check if custom fonts are loaded
struct WellnessFontLoader {
    /// Check if Lora font family is available
    static var isLoraAvailable: Bool {
        UIFont.familyNames.contains { $0.contains("Lora") }
    }

    /// Check if Raleway font family is available
    static var isRalewayAvailable: Bool {
        UIFont.familyNames.contains { $0.contains("Raleway") }
    }

    /// Check if all wellness fonts are available
    static var areAllFontsAvailable: Bool {
        isLoraAvailable && isRalewayAvailable
    }

    /// Get list of available font families (for debugging)
    static var availableFamilies: [String] {
        UIFont.familyNames.sorted()
    }

    /// Print font status to console (useful for debugging)
    static func printFontStatus() {
        print("=== Wellness Font Status ===")
        print("Lora available: \(isLoraAvailable)")
        print("Raleway available: \(isRalewayAvailable)")
        print("All fonts loaded: \(areAllFontsAvailable)")

        if !areAllFontsAvailable {
            print("⚠️ Using SF Pro system fonts as fallback")
        } else {
            print("✓ All wellness fonts loaded successfully")
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Theme/Gradients.swift">
import SwiftUI

// MARK: - Gradient Extensions
extension LinearGradient {
    /// Calm wellness gradient for backgrounds
    /// Combines calm blue and health green for soothing effect
    static let calmWellness = LinearGradient(
        colors: [
            Color.Wellness.calmBlue.opacity(0.1),
            Color.Wellness.healthGreen.opacity(0.05),
            Color.clear
        ],
        startPoint: .topLeading,
        endPoint: .bottomTrailing
    )

    /// Stress spectrum gradient that maps to stress levels
    /// - Parameter category: The stress category
    /// - Returns: Gradient representing the stress level
    static func stressSpectrum(for category: StressCategory) -> LinearGradient {
        let baseColor = Color.stressColor(for: category)
        return LinearGradient(
            colors: [
                baseColor.opacity(0.6),
                baseColor.opacity(0.3),
                baseColor.opacity(0.1)
            ],
            startPoint: .top,
            endPoint: .bottom
        )
    }

    /// Background tint gradient for cards based on stress level
    /// - Parameter category: The stress category
    /// - Returns: Subtle gradient for card backgrounds
    static func stressBackgroundTint(for category: StressCategory) -> LinearGradient {
        let baseColor = Color.stressColor(for: category)
        return LinearGradient(
            colors: [
                baseColor.opacity(0.08),
                Color.clear
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }

    /// Mindfulness gradient (gentle purple to calm blue)
    static let mindfulness = LinearGradient(
        colors: [
            Color.Wellness.gentlePurple.opacity(0.15),
            Color.Wellness.calmBlue.opacity(0.1),
            Color.clear
        ],
        startPoint: .topLeading,
        endPoint: .bottomTrailing
    )

    /// Relaxation gradient (health green to transparent)
    static let relaxation = LinearGradient(
        colors: [
            Color.Wellness.healthGreen.opacity(0.15),
            Color.Wellness.healthGreen.opacity(0.05),
            Color.clear
        ],
        startPoint: .top,
        endPoint: .bottom
    )
}

// MARK: - Gradient View Modifiers
extension View {
    /// Apply wellness background gradient
    func wellnessBackground() -> some View {
        self.background(LinearGradient.calmWellness)
    }

    /// Apply stress-level specific background gradient
    /// - Parameter category: The stress category
    func stressBackground(for category: StressCategory) -> some View {
        self.background(LinearGradient.stressBackgroundTint(for: category))
    }

    /// Apply card background with stress spectrum gradient overlay
    /// - Parameters:
    ///   - category: The stress category
    ///   - baseColor: Base color for the card (default: surface)
    func stressCard(for category: StressCategory, baseColor: Color = Color.Wellness.surface) -> some View {
        self
            .background {
                ZStack {
                    baseColor
                    LinearGradient.stressBackgroundTint(for: category)
                }
            }
            .clipShape(RoundedRectangle(cornerRadius: 12))
    }
}
</file>

<file path="StressMonitor/StressMonitor/Utilities/AccessibilityModifiers.swift">
import SwiftUI

/// Accessibility modifiers and helpers for WCAG compliance
extension View {
    /// Applies dual coding for stress levels (color + icon + text)
    /// Required for WCAG AA compliance
    func stressDualCoding(_ category: StressCategory) -> some View {
        modifier(StressDualCodingModifier(category: category))
    }

    /// Ensures minimum touch target size (44x44pt)
    func minimumTouchTarget(_ size: CGFloat = 44) -> some View {
        modifier(MinimumTouchTargetModifier(minSize: size))
    }

    /// Animation that respects accessibility reduce motion preference
    func accessibleAnimation(_ animation: Animation = .easeOut(duration: 0.2)) -> some View {
        modifier(AccessibleAnimationModifier(animation: animation))
    }

    /// Press effect that respects reduce motion
    func pressEffect() -> some View {
        modifier(PressEffectModifier())
    }
}

// MARK: - Dual Coding Modifier

struct StressDualCodingModifier: ViewModifier {
    let category: StressCategory

    func body(content: Content) -> some View {
        HStack(spacing: 6) {
            content

            Image(systemName: category.icon)
                .accessibilityHidden(true)

            Text(category.displayName)
                .font(.caption)
                .foregroundColor(category.color)
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(category.displayName) stress level")
    }
}

// MARK: - Minimum Touch Target Modifier

struct MinimumTouchTargetModifier: ViewModifier {
    let minSize: CGFloat

    func body(content: Content) -> some View {
        content
            .frame(minWidth: minSize, minHeight: minSize)
            .contentShape(Rectangle())
    }
}

// MARK: - Accessible Animation Modifier

struct AccessibleAnimationModifier: ViewModifier {
    let animation: Animation
    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    func body(content: Content) -> some View {
        if reduceMotion {
            content
        } else {
            content.animation(animation, value: UUID())
        }
    }
}

// MARK: - Press Effect Modifier

struct PressEffectModifier: ViewModifier {
    @State private var isPressed = false
    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    func body(content: Content) -> some View {
        content
            .scaleEffect(isPressed ? 0.96 : 1.0)
            .animation(reduceMotion ? .none : .easeOut(duration: 0.1), value: isPressed)
            .simultaneousGesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { _ in isPressed = true }
                    .onEnded { _ in isPressed = false }
            )
    }
}

// MARK: - VoiceOver Labels

enum VoiceOverLabels {
    // Dashboard
    static let stressRing = "Stress level ring showing current stress as percentage"
    static let measureButton = "Measure current stress level"
    static let hrvCard = "Heart rate variability metric card"
    static let heartRateCard = "Heart rate metric card"

    // Stress Levels
    static func stressLevel(_ level: Double, category: StressCategory) -> String {
        "Stress level \(Int(level)) percent, \(category.displayName)"
    }

    static func stressTrend(_ trend: String) -> String {
        "Stress trend: \(trend)"
    }

    // Timeline
    static func timelinePoint(hour: Int, stress: Double) -> String {
        "At \(hour) hours, stress level was \(Int(stress)) percent"
    }

    // Learning Phase
    static func learningProgress(samples: Int, total: Int, days: Int) -> String {
        "Learning phase: \(samples) of \(total) samples collected, \(days) days remaining"
    }

    // Permissions
    static let permissionCard = "Health access required. Double tap to grant permission."
    static let settingsButton = "Open device settings"
}

// MARK: - Accessibility View Extensions

extension View {
    /// Sets accessibility value and hint for stress level displays
    func accessibilityStressLevel(_ level: Double, category: StressCategory) -> some View {
        self
            .accessibilityValue("\(Int(level)) percent")
            .accessibilityHint(category.accessibilityDescription)
    }

    /// Sets accessibility for chart elements
    func accessibilityChart(description: String, value: String) -> some View {
        self
            .accessibilityElement(children: .combine)
            .accessibilityLabel(description)
            .accessibilityValue(value)
            .accessibilityAddTraits(.updatesFrequently)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Utilities/Animation+Wellness.swift">
import SwiftUI

// MARK: - Reduce Motion Support

extension Animation {
    /// Wellness animation with Reduce Motion support
    /// Returns nil if Reduce Motion is enabled, allowing static fallback
    /// - Parameters:
    ///   - duration: Animation duration in seconds
    ///   - reduceMotion: Whether Reduce Motion is enabled
    /// - Returns: Animation or nil if motion should be reduced
    static func wellness(
        duration: Double = 1.0,
        reduceMotion: Bool = false
    ) -> Animation? {
        reduceMotion ? nil : .easeInOut(duration: duration)
    }

    /// Breathing animation (slow, gentle)
    static func breathing(reduceMotion: Bool = false) -> Animation? {
        reduceMotion ? nil : .easeInOut(duration: 4.0).repeatForever(autoreverses: true)
    }

    /// Fidget animation (quick, subtle)
    static func fidget(reduceMotion: Bool = false) -> Animation? {
        reduceMotion ? nil : .easeInOut(duration: 0.5)
    }

    /// Shake animation (fast, alert)
    static func shake(reduceMotion: Bool = false) -> Animation? {
        reduceMotion ? nil : .easeInOut(duration: 0.5).repeatCount(3, autoreverses: true)
    }

    /// Dizzy animation (continuous rotation)
    static func dizzy(reduceMotion: Bool = false) -> Animation? {
        reduceMotion ? nil : .linear(duration: 1.5).repeatForever(autoreverses: false)
    }
}

// MARK: - Reduce Motion-Aware Modifier

/// View modifier that applies animation only when Reduce Motion is disabled
struct ReduceMotionAwareModifier<V: Equatable>: ViewModifier {
    @Environment(\.accessibilityReduceMotion) var reduceMotion
    let animation: Animation?
    let value: V

    func body(content: Content) -> some View {
        if reduceMotion {
            // Static - no animation
            content
        } else {
            // Animated
            content
                .animation(animation, value: value)
        }
    }
}

extension View {
    /// Apply animation only when Reduce Motion is disabled
    /// - Parameters:
    ///   - animation: Animation to apply
    ///   - value: Value to trigger animation
    /// - Returns: View with conditional animation
    func animateIfMotionAllowed<V: Equatable>(
        _ animation: Animation?,
        value: V
    ) -> some View {
        modifier(ReduceMotionAwareModifier(animation: animation, value: value))
    }
}

// MARK: - Accessibility-Safe Transition

extension AnyTransition {
    /// Safe opacity transition that respects Reduce Motion
    static func accessibleOpacity(reduceMotion: Bool) -> AnyTransition {
        if reduceMotion {
            return .identity // No transition
        } else {
            return .opacity
        }
    }

    /// Safe scale transition that respects Reduce Motion
    static func accessibleScale(reduceMotion: Bool) -> AnyTransition {
        if reduceMotion {
            return .identity
        } else {
            return .scale
        }
    }

    /// Safe slide transition that respects Reduce Motion
    static func accessibleSlide(reduceMotion: Bool, edge: Edge = .bottom) -> AnyTransition {
        if reduceMotion {
            return .identity
        } else {
            return .move(edge: edge)
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Utilities/AnimationPresets.swift">
import SwiftUI

/// Animation presets for consistent timing across the app
/// All durations follow 150-300ms guidelines for micro-interactions
extension Animation {
    /// Quick micro-interaction (100ms)
    static let micro = Animation.easeOut(duration: 0.1)

    /// Standard micro-interaction (150ms)
    static let quick = Animation.easeOut(duration: 0.15)

    /// Standard interaction (250ms)
    static let standard = Animation.easeOut(duration: 0.25)

    /// Emphasis animation (350ms)
    static let emphasis = Animation.easeOut(duration: 0.35)

    /// Spring animation for bouncy feel
    static let springy = Animation.spring(response: 0.3, dampingFraction: 0.7)

    /// Stiff spring for quick feedback
    static let stiffSpring = Animation.spring(response: 0.2, dampingFraction: 0.8)

    /// Slow spring for dramatic effect
    static let slowSpring = Animation.spring(response: 0.5, dampingFraction: 0.6)

    /// Smooth ease for state transitions
    static let smooth = Animation.easeInOut(duration: 0.3)
}

// MARK: - Staggered Animation Modifier

struct StaggeredAppearModifier: ViewModifier {
    let index: Int
    let totalItems: Int
    let baseDelay: Double

    @State private var appeared = false
    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    private var delay: Double {
        baseDelay * Double(index)
    }

    func body(content: Content) -> some View {
        content
            .opacity(appeared ? 1 : 0)
            .offset(y: appeared ? 0 : 20)
            .onAppear {
                if reduceMotion {
                    appeared = true
                } else {
                    withAnimation(.easeOut(duration: 0.3).delay(delay)) {
                        appeared = true
                    }
                }
            }
    }
}

extension View {
    /// Applies staggered appear animation for list items
    func staggeredAppear(index: Int, total: Int, delay: Double = 0.05) -> some View {
        modifier(StaggeredAppearModifier(index: index, totalItems: total, baseDelay: delay))
    }
}

// MARK: - Shimmer Loading Effect

struct ShimmerLoadingModifier: ViewModifier {
    @State private var phase: CGFloat = 0
    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    func body(content: Content) -> some View {
        if reduceMotion {
            content.redacted(reason: .placeholder)
        } else {
            content
                .overlay(
                    ShimmerEffectView(phase: $phase)
                )
                .redacted(reason: .placeholder)
                .onAppear {
                    withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                        phase = 1
                    }
                }
        }
    }
}

struct ShimmerEffectView: View {
    @Binding var phase: CGFloat

    var body: some View {
        GeometryReader { geometry in
            Rectangle()
                .fill(
                    LinearGradient(
                        stops: [
                            .init(color: .clear, location: 0),
                            .init(color: Color.white.opacity(0.3), location: 0.5),
                            .init(color: .clear, location: 1)
                        ],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .offset(x: phase * geometry.size.width * 2 - geometry.size.width)
        }
        .mask(Rectangle())
    }
}

extension View {
    /// Applies shimmer loading effect
    func shimmerLoading() -> some View {
        modifier(ShimmerLoadingModifier())
    }
}

// MARK: - Preview

#Preview("Animation Presets Demo") {
    VStack(spacing: 20) {
        Text("Animation Presets")
            .font(.headline)

        Text("Micro, Quick, Standard, Emphasis")
            .font(.caption)
            .foregroundColor(.secondary)
    }
    .padding()
    .background(Color.oledBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Utilities/ColorBlindnessSimulator.swift">
import SwiftUI

#if DEBUG

// MARK: - Color Blindness Simulator (DEBUG ONLY)

/// Simulates different types of color blindness for testing accessibility
/// Only available in DEBUG builds for design validation
public enum ColorBlindnessType: String, CaseIterable {
    case deuteranopia  // Red-green (most common, 5% of males)
    case protanopia    // Red-green (1% of males)
    case tritanopia    // Blue-yellow (rare, 0.01%)
    case normal        // No simulation

    // MARK: - Display Name

    public var displayName: String {
        switch self {
        case .deuteranopia: return "Deuteranopia (Red-Green)"
        case .protanopia: return "Protanopia (Red-Green)"
        case .tritanopia: return "Tritanopia (Blue-Yellow)"
        case .normal: return "Normal Vision"
        }
    }

    // MARK: - Color Simulation

    /// Simulate color-blind vision for a given color
    /// - Parameter color: Original color
    /// - Returns: Simulated color as seen by color-blind users
    public func simulate(_ color: Color) -> Color {
        guard self != .normal else { return color }

        let uiColor = UIColor(color)
        var red: CGFloat = 0
        var green: CGFloat = 0
        var blue: CGFloat = 0
        var alpha: CGFloat = 0

        uiColor.getRed(&red, green: &green, blue: &blue, alpha: &alpha)

        // Apply color blindness transformation matrix
        let (r, g, b) = transformRGB(red: red, green: green, blue: blue)

        return Color(
            .sRGB,
            red: Double(r),
            green: Double(g),
            blue: Double(b),
            opacity: Double(alpha)
        )
    }

    // MARK: - RGB Transformation

    /// Transform RGB values based on color blindness type
    /// - Parameters:
    ///   - red: Red component (0-1)
    ///   - green: Green component (0-1)
    ///   - blue: Blue component (0-1)
    /// - Returns: Transformed RGB tuple
    private func transformRGB(red: CGFloat, green: CGFloat, blue: CGFloat) -> (CGFloat, CGFloat, CGFloat) {
        switch self {
        case .deuteranopia:
            // Deuteranopia transformation matrix
            let r = red * 0.625 + green * 0.375
            let g = red * 0.7 + green * 0.3
            let b = blue * 1.0
            return (r, g, b)

        case .protanopia:
            // Protanopia transformation matrix
            let r = red * 0.567 + green * 0.433
            let g = red * 0.558 + green * 0.442
            let b = blue * 1.0
            return (r, g, b)

        case .tritanopia:
            // Tritanopia transformation matrix
            let r = red * 0.95 + green * 0.05
            let g = green * 1.0
            let b = red * 0.433 + blue * 0.567
            return (r, g, b)

        case .normal:
            return (red, green, blue)
        }
    }
}

// MARK: - Color Blindness Simulator Modifier

/// View modifier that simulates color blindness
public struct ColorBlindnessSimulatorModifier: ViewModifier {
    let type: ColorBlindnessType

    public init(type: ColorBlindnessType) {
        self.type = type
    }

    public func body(content: Content) -> some View {
        if type == .normal {
            content
        } else {
            content
                .colorMultiply(simulationColor)
                .overlay {
                    // Add visual indicator that simulation is active
                    VStack {
                        Spacer()
                        Text("Color Blindness Simulation: \(type.displayName)")
                            .font(.caption2)
                            .padding(4)
                            .background(Color.black.opacity(0.7))
                            .foregroundColor(.white)
                            .cornerRadius(4)
                    }
                }
        }
    }

    private var simulationColor: Color {
        // Approximation using color multiply
        switch type {
        case .deuteranopia:
            return Color(red: 0.8, green: 0.9, blue: 1.0)
        case .protanopia:
            return Color(red: 0.75, green: 0.85, blue: 1.0)
        case .tritanopia:
            return Color(red: 1.0, green: 0.95, blue: 0.8)
        case .normal:
            return .white
        }
    }
}

// MARK: - View Extension

extension View {
    /// Simulate color blindness for testing (DEBUG only)
    /// - Parameter type: Type of color blindness to simulate
    /// - Returns: View with color blindness simulation
    public func simulateColorBlindness(_ type: ColorBlindnessType) -> some View {
        modifier(ColorBlindnessSimulatorModifier(type: type))
    }
}

// MARK: - Preview Helper

/// Preview helper for testing accessibility with different color blindness types
public struct ColorBlindnessPreviewContainer<Content: View>: View {
    let content: Content

    public init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    public var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                ForEach(ColorBlindnessType.allCases, id: \.self) { type in
                    VStack(alignment: .leading, spacing: 8) {
                        Text(type.displayName)
                            .font(.headline)
                            .padding(.horizontal)

                        content
                            .simulateColorBlindness(type)
                    }
                }
            }
            .padding()
        }
    }
}

// MARK: - Stress Color Validator

/// Validates stress colors for color blindness accessibility
public struct StressColorValidator {
    /// Test stress colors against all color blindness types
    /// - Returns: Validation results
    public static func validateStressColors() -> [String: [ColorBlindnessType: Color]] {
        let categories: [StressCategory] = [.relaxed, .mild, .moderate, .high]
        var results: [String: [ColorBlindnessType: Color]] = [:]

        for category in categories {
            let color = category.color
            var categoryResults: [ColorBlindnessType: Color] = [:]

            for type in ColorBlindnessType.allCases {
                categoryResults[type] = type.simulate(color)
            }

            results[category.rawValue] = categoryResults
        }

        return results
    }

    /// Print validation results to console
    public static func printValidationResults() {
        let results = validateStressColors()
        print("🎨 Stress Color Validation for Color Blindness:")
        print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

        for (category, simulations) in results {
            print("\n\(category.uppercased()):")
            for (type, color) in simulations {
                print("  - \(type.displayName): \(color)")
            }
        }

        print("\n✓ Validation complete. Review visual differences in Preview.")
    }
}

#endif
</file>

<file path="StressMonitor/StressMonitor/Utilities/DynamicTypeScaling.swift">
import SwiftUI

// MARK: - Dynamic Type Scaling for Accessibility

/// View modifier that enables dynamic type scaling with minimum scale factor
/// Ensures text remains readable while preventing truncation
public struct DynamicTypeScalingModifier: ViewModifier {
    let minimumScale: CGFloat

    public init(minimumScale: CGFloat = 0.75) {
        self.minimumScale = minimumScale
    }

    public func body(content: Content) -> some View {
        content
            .minimumScaleFactor(minimumScale)
            .lineLimit(nil) // Allow wrapping
    }
}

// MARK: - View Extension

extension View {
    /// Apply scalable text with dynamic type support
    /// - Parameter minimumScale: Minimum scale factor (default: 0.75)
    /// - Returns: View with scalable text
    public func scalableText(minimumScale: CGFloat = 0.75) -> some View {
        modifier(DynamicTypeScalingModifier(minimumScale: minimumScale))
    }
}

// MARK: - Adaptive Text Size Modifier

/// Modifier that adjusts text size based on Dynamic Type setting
public struct AdaptiveTextSizeModifier: ViewModifier {
    @Environment(\.dynamicTypeSize) var dynamicTypeSize

    let baseSize: CGFloat
    let weight: Font.Weight
    let design: Font.Design

    public init(baseSize: CGFloat, weight: Font.Weight = .regular, design: Font.Design = .default) {
        self.baseSize = baseSize
        self.weight = weight
        self.design = design
    }

    public func body(content: Content) -> some View {
        content
            .font(.system(size: scaledSize, weight: weight, design: design))
            .minimumScaleFactor(0.7)
            .lineLimit(nil)
    }

    private var scaledSize: CGFloat {
        // Scale based on Dynamic Type setting
        switch dynamicTypeSize {
        case .xSmall:
            return baseSize * 0.8
        case .small:
            return baseSize * 0.9
        case .medium:
            return baseSize
        case .large:
            return baseSize * 1.1
        case .xLarge:
            return baseSize * 1.2
        case .xxLarge:
            return baseSize * 1.3
        case .xxxLarge:
            return baseSize * 1.4
        case .accessibility1:
            return baseSize * 1.6
        case .accessibility2:
            return baseSize * 1.8
        case .accessibility3:
            return baseSize * 2.0
        case .accessibility4:
            return baseSize * 2.3
        case .accessibility5:
            return baseSize * 2.6
        @unknown default:
            return baseSize
        }
    }
}

extension View {
    /// Apply adaptive text sizing with Dynamic Type support
    /// - Parameters:
    ///   - baseSize: Base font size
    ///   - weight: Font weight (default: .regular)
    ///   - design: Font design (default: .default)
    /// - Returns: View with adaptive text size
    public func adaptiveTextSize(_ baseSize: CGFloat, weight: Font.Weight = .regular, design: Font.Design = .default) -> some View {
        modifier(AdaptiveTextSizeModifier(baseSize: baseSize, weight: weight, design: design))
    }
}

// MARK: - Limited Dynamic Type Modifier

/// Modifier that limits Dynamic Type to accessibility level 3
/// Prevents extreme scaling that could break layout
public struct LimitedDynamicTypeModifier: ViewModifier {
    public func body(content: Content) -> some View {
        content
            .dynamicTypeSize(...DynamicTypeSize.accessibility3)
    }
}

extension View {
    /// Limit Dynamic Type to accessibility level 3
    /// - Returns: View with limited Dynamic Type scaling
    public func limitedDynamicType() -> some View {
        modifier(LimitedDynamicTypeModifier())
    }
}

// MARK: - Accessible Dynamic Type Modifier

/// Comprehensive Dynamic Type modifier with best practices
public struct AccessibleDynamicTypeModifier: ViewModifier {
    let minimumScale: CGFloat
    let maxDynamicTypeSize: DynamicTypeSize

    public init(minimumScale: CGFloat = 0.75, maxDynamicTypeSize: DynamicTypeSize = .accessibility3) {
        self.minimumScale = minimumScale
        self.maxDynamicTypeSize = maxDynamicTypeSize
    }

    public func body(content: Content) -> some View {
        content
            .dynamicTypeSize(...maxDynamicTypeSize)
            .minimumScaleFactor(minimumScale)
            .lineLimit(nil)
    }
}

extension View {
    /// Apply accessible Dynamic Type with scaling limits
    /// - Parameters:
    ///   - minimumScale: Minimum scale factor (default: 0.75)
    ///   - maxDynamicTypeSize: Maximum Dynamic Type size (default: .accessibility3)
    /// - Returns: View with accessible Dynamic Type
    public func accessibleDynamicType(minimumScale: CGFloat = 0.75, maxDynamicTypeSize: DynamicTypeSize = .accessibility3) -> some View {
        modifier(AccessibleDynamicTypeModifier(minimumScale: minimumScale, maxDynamicTypeSize: maxDynamicTypeSize))
    }
}
</file>

<file path="StressMonitor/StressMonitor/Utilities/HighContrastModifier.swift">
import SwiftUI

// MARK: - High Contrast Border for Accessibility

/// View modifier that adds high contrast border when "Differentiate Without Color" is enabled
/// Ensures interactive elements are visible for users who cannot distinguish colors
public struct HighContrastBorderModifier: ViewModifier {
    @Environment(\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor

    let isInteractive: Bool
    let cornerRadius: CGFloat

    public init(isInteractive: Bool = true, cornerRadius: CGFloat = 8) {
        self.isInteractive = isInteractive
        self.cornerRadius = cornerRadius
    }

    public func body(content: Content) -> some View {
        content
            .overlay {
                if differentiateWithoutColor && isInteractive {
                    RoundedRectangle(cornerRadius: cornerRadius)
                        .strokeBorder(Color.primary, lineWidth: 2)
                }
            }
    }
}

// MARK: - View Extension

extension View {
    /// Add high contrast border for interactive elements
    /// - Parameters:
    ///   - interactive: Whether the element is interactive (default: true)
    ///   - cornerRadius: Corner radius for border (default: 8)
    /// - Returns: View with conditional high contrast border
    public func highContrastBorder(interactive: Bool = true, cornerRadius: CGFloat = 8) -> some View {
        modifier(HighContrastBorderModifier(isInteractive: interactive, cornerRadius: cornerRadius))
    }
}

// MARK: - High Contrast Card Modifier

/// Enhanced card modifier with high contrast support
public struct HighContrastCardModifier: ViewModifier {
    @Environment(\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor
    @Environment(\.colorScheme) var colorScheme

    let backgroundColor: Color?
    let cornerRadius: CGFloat

    public init(backgroundColor: Color? = nil, cornerRadius: CGFloat = 12) {
        self.backgroundColor = backgroundColor
        self.cornerRadius = cornerRadius
    }

    public func body(content: Content) -> some View {
        content
            .background(cardBackground)
            .clipShape(RoundedRectangle(cornerRadius: cornerRadius))
            .overlay {
                if differentiateWithoutColor {
                    RoundedRectangle(cornerRadius: cornerRadius)
                        .strokeBorder(Color.primary.opacity(0.3), lineWidth: 2)
                }
            }
    }

    private var cardBackground: Color {
        if let backgroundColor = backgroundColor {
            return backgroundColor
        }
        return colorScheme == .dark ? Color(hex: "#1C1C1E") : .white
    }
}

extension View {
    /// Apply high contrast card styling
    /// - Parameters:
    ///   - backgroundColor: Custom background color (optional)
    ///   - cornerRadius: Corner radius (default: 12)
    /// - Returns: View with high contrast card styling
    public func highContrastCard(backgroundColor: Color? = nil, cornerRadius: CGFloat = 12) -> some View {
        modifier(HighContrastCardModifier(backgroundColor: backgroundColor, cornerRadius: cornerRadius))
    }
}

// MARK: - High Contrast Button Modifier

/// Button modifier with enhanced high contrast styling
public struct HighContrastButtonModifier: ViewModifier {
    @Environment(\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor

    let style: ButtonStyle

    public enum ButtonStyle {
        case primary
        case secondary
        case tertiary
    }

    public init(style: ButtonStyle = .primary) {
        self.style = style
    }

    public func body(content: Content) -> some View {
        content
            .overlay {
                if differentiateWithoutColor {
                    RoundedRectangle(cornerRadius: 10)
                        .strokeBorder(borderColor, lineWidth: 2)
                }
            }
    }

    private var borderColor: Color {
        switch style {
        case .primary:
            return .primary
        case .secondary:
            return .secondary
        case .tertiary:
            return Color.primary.opacity(0.5)
        }
    }
}

extension View {
    /// Apply high contrast button styling
    /// - Parameter style: Button style (default: .primary)
    /// - Returns: View with high contrast button styling
    public func highContrastButton(style: HighContrastButtonModifier.ButtonStyle = .primary) -> some View {
        modifier(HighContrastButtonModifier(style: style))
    }
}
</file>

<file path="StressMonitor/StressMonitor/Utilities/PatternOverlay.swift">
import SwiftUI

// MARK: - Stress Pattern for Dual Coding

/// Visual patterns to supplement color for stress levels
/// Ensures accessibility for color-blind users (WCAG 2.1 compliance)
public enum StressPattern: String, CaseIterable {
    case solid       // No pattern (relaxed)
    case diagonal    // Diagonal lines (mild)
    case dots        // Dot pattern (moderate)
    case crosshatch  // Crosshatch lines (high)

    // MARK: - Pattern Mapping

    /// Get pattern for stress category
    /// - Parameter category: Stress category
    /// - Returns: Corresponding pattern
    public static func pattern(for category: StressCategory) -> StressPattern {
        switch category {
        case .relaxed: return .solid
        case .mild: return .diagonal
        case .moderate: return .dots
        case .high: return .crosshatch
        }
    }

    // MARK: - ShapeStyle

    /// ShapeStyle for pattern rendering
    public var shapeStyle: AnyShapeStyle {
        switch self {
        case .solid:
            return AnyShapeStyle(Color.clear)
        case .diagonal:
            return AnyShapeStyle(DiagonalPattern())
        case .dots:
            return AnyShapeStyle(DotPattern())
        case .crosshatch:
            return AnyShapeStyle(CrosshatchPattern())
        }
    }

    // MARK: - Overlay View

    /// Create pattern overlay view
    /// - Parameters:
    ///   - color: Base color for pattern
    ///   - opacity: Pattern opacity (default 0.3)
    /// - Returns: Pattern overlay view
    @ViewBuilder
    public func overlay(color: Color, opacity: Double = 0.3) -> some View {
        switch self {
        case .solid:
            // No pattern - just solid color
            EmptyView()
        case .diagonal:
            DiagonalLinesView(color: color, opacity: opacity)
        case .dots:
            DotsView(color: color, opacity: opacity)
        case .crosshatch:
            CrosshatchView(color: color, opacity: opacity)
        }
    }
}

// MARK: - Pattern Shapes

/// Diagonal lines pattern
private struct DiagonalPattern: ShapeStyle {
    func resolve(in environment: EnvironmentValues) -> some ShapeStyle {
        Color.primary.opacity(0.2)
    }
}

/// Dot pattern
private struct DotPattern: ShapeStyle {
    func resolve(in environment: EnvironmentValues) -> some ShapeStyle {
        Color.primary.opacity(0.2)
    }
}

/// Crosshatch pattern
private struct CrosshatchPattern: ShapeStyle {
    func resolve(in environment: EnvironmentValues) -> some ShapeStyle {
        Color.primary.opacity(0.2)
    }
}

// MARK: - Pattern Views

/// Diagonal lines overlay
private struct DiagonalLinesView: View {
    let color: Color
    let opacity: Double

    var body: some View {
        GeometryReader { geometry in
            Path { path in
                let spacing: CGFloat = 8
                let width = geometry.size.width
                let height = geometry.size.height
                let diagonal = sqrt(width * width + height * height)

                var offset: CGFloat = -diagonal
                while offset < diagonal {
                    path.move(to: CGPoint(x: offset, y: 0))
                    path.addLine(to: CGPoint(x: offset + height, y: height))
                    offset += spacing
                }
            }
            .stroke(color.opacity(opacity), lineWidth: 1)
        }
    }
}

/// Dots overlay
private struct DotsView: View {
    let color: Color
    let opacity: Double

    var body: some View {
        GeometryReader { geometry in
            let spacing: CGFloat = 8
            let columns = Int(geometry.size.width / spacing)
            let rows = Int(geometry.size.height / spacing)

            Canvas { context, size in
                for row in 0...rows {
                    for col in 0...columns {
                        let x = CGFloat(col) * spacing
                        let y = CGFloat(row) * spacing
                        let rect = CGRect(x: x, y: y, width: 2, height: 2)
                        context.fill(
                            Path(ellipseIn: rect),
                            with: .color(color.opacity(opacity))
                        )
                    }
                }
            }
        }
    }
}

/// Crosshatch overlay
private struct CrosshatchView: View {
    let color: Color
    let opacity: Double

    var body: some View {
        GeometryReader { geometry in
            Path { path in
                let spacing: CGFloat = 6
                let width = geometry.size.width
                let height = geometry.size.height

                // Horizontal lines
                var y: CGFloat = 0
                while y < height {
                    path.move(to: CGPoint(x: 0, y: y))
                    path.addLine(to: CGPoint(x: width, y: y))
                    y += spacing
                }

                // Vertical lines
                var x: CGFloat = 0
                while x < width {
                    path.move(to: CGPoint(x: x, y: 0))
                    path.addLine(to: CGPoint(x: x, y: height))
                    x += spacing
                }
            }
            .stroke(color.opacity(opacity), lineWidth: 1)
        }
    }
}

// MARK: - Pattern Overlay Modifier

/// View modifier to apply stress pattern overlay
public struct PatternOverlayModifier: ViewModifier {
    let pattern: StressPattern
    let color: Color

    public func body(content: Content) -> some View {
        content
            .overlay {
                pattern.overlay(color: color)
            }
    }
}

// MARK: - View Extension

extension View {
    /// Apply stress pattern overlay for dual coding
    /// - Parameters:
    ///   - pattern: Pattern type
    ///   - color: Base color for pattern
    /// - Returns: View with pattern overlay
    public func stressPattern(_ pattern: StressPattern, color: Color) -> some View {
        modifier(PatternOverlayModifier(pattern: pattern, color: color))
    }

    /// Apply stress pattern based on category
    /// - Parameter category: Stress category
    /// - Returns: View with pattern overlay
    public func stressPattern(for category: StressCategory) -> some View {
        let pattern = StressPattern.pattern(for: category)
        return modifier(PatternOverlayModifier(pattern: pattern, color: category.color))
    }
}
</file>

<file path="StressMonitor/StressMonitor/ViewModels/DataManagementViewModel.swift">
import Foundation
import SwiftData
import Observation
import UniformTypeIdentifiers

@preconcurrency import SwiftData

// MARK: - Data Management View Model
/// Observable view model for data management UI operations
@MainActor
@Observable
public final class DataManagementViewModel: Sendable {

    // MARK: - Export State

    public private(set) var isExporting = false
    public private(set) var exportProgress: Double = 0.0
    public private(set) var exportOperation: String?
    public private(set) var exportedFileURL: URL?

    // MARK: - Delete State

    public private(set) var isDeleting = false
    public private(set) var deleteProgress: Double = 0.0
    public private(set) var deleteOperation: String?

    // MARK: - Error State

    public private(set) var errorMessage: String?
    public private(set) var errorTitle: String?

    // MARK: - Success State

    public private(set) var showSuccessAlert = false
    public private(set) var successMessage: String?

    // MARK: - Confirmation State

    public private(set) var showDeleteConfirmation = false
    public private(set) var pendingDeleteOperation: DeleteOperation?

    // MARK: - Data Statistics

    public private(set) var totalMeasurementCount = 0
    public private(set) var oldestMeasurementDate: Date?
    public private(set) var newestMeasurementDate: Date?

    // MARK: - Dependencies

    private let dataManagementService: DataManagementService
    private let dataDeleterService: DataDeleterService
    private let repository: StressRepositoryProtocol
    private nonisolated let logger: Logger

    // MARK: - Completion Callbacks

    var onExportComplete: ((URL) -> Void)?
    var onDeleteComplete: (() -> Void)?

    // MARK: - Initialization

    init(
        modelContext: ModelContext,
        cloudKitContainer: CKContainer = .default(),
        dataManagementService: DataManagementService? = nil,
        dataDeleterService: DataDeleterService? = nil,
        repository: StressRepositoryProtocol? = nil,
        logger: Logger = .default
    ) {
        self.repository = repository ?? StressRepository(modelContext: modelContext)
        self.logger = logger

        // Initialize services or create defaults
        if let service = dataManagementService {
            self.dataManagementService = service
        } else {
            self.dataManagementService = DataManagementService(
                repository: self.repository
            )
        }

        if let deleter = dataDeleterService {
            self.dataDeleterService = deleter
        } else {
            self.dataDeleterService = DataDeleterService(
                modelContext: modelContext,
                cloudKitContainer: cloudKitContainer,
                repository: self.repository
            )
        }
    }

    // MARK: - Load Data Statistics

    /// Load statistics about stored measurements
    public func loadStatistics() async {
        do {
            let measurements = try await repository.fetchAll()

            await MainActor.run {
                totalMeasurementCount = measurements.count

                if let oldest = measurements.last?.timestamp {
                    oldestMeasurementDate = oldest
                }

                if let newest = measurements.first?.timestamp {
                    newestMeasurementDate = newest
                }
            }

            logger.log("Loaded statistics: \(measurements.count) measurements")

        } catch {
            logger.log("Failed to load statistics: \(error.localizedDescription)")
        }
    }

    // MARK: - Export Operations

    /// Export measurements to CSV format
    /// - Parameters:
    ///   - startDate: Start date for export range
    ///   - endDate: End date for export range
    public func exportToCSV(startDate: Date? = nil, endDate: Date? = nil) async {
        isExporting = true
        exportProgress = 0.0
        exportOperation = "Preparing CSV export"
        errorMessage = nil
        exportedFileURL = nil

        defer {
            isExporting = false
        }

        do {
            let measurements = try await fetchMeasurements(forStart: startDate, end: endDate)

            guard !measurements.isEmpty else {
                showError("No Data", "No measurements found in the selected date range.")
                return
            }

            exportOperation = "Generating CSV file"
            exportProgress = 0.2

            let fileURL = try await dataManagementService.exportToCSV(measurements: measurements)

            exportProgress = 1.0
            exportedFileURL = fileURL
            exportOperation = nil

            showSuccess("Successfully exported \(measurements.count) measurements to CSV")
            onExportComplete?(fileURL)

            logger.log("CSV export completed: \(fileURL.path)")

        } catch let error as ExportError {
            showError("Export Failed", error.localizedDescription)
            logger.log("CSV export failed: \(error.localizedDescription)")
        } catch {
            showError("Export Failed", error.localizedDescription)
            logger.log("CSV export failed: \(error.localizedDescription)")
        }
    }

    /// Export measurements to JSON format
    /// - Parameters:
    ///   - startDate: Start date for export range
    ///   - endDate: End date for export range
    public func exportToJSON(startDate: Date? = nil, endDate: Date? = nil) async {
        isExporting = true
        exportProgress = 0.0
        exportOperation = "Preparing JSON export"
        errorMessage = nil
        exportedFileURL = nil

        defer {
            isExporting = false
        }

        do {
            let measurements = try await fetchMeasurements(forStart: startDate, end: endDate)

            guard !measurements.isEmpty else {
                showError("No Data", "No measurements found in the selected date range.")
                return
            }

            exportOperation = "Fetching baseline data"
            exportProgress = 0.2

            let baseline = try await repository.getBaseline()

            exportOperation = "Generating JSON file"
            exportProgress = 0.4

            let fileURL = try await dataManagementService.exportToJSON(
                measurements: measurements,
                baseline: baseline
            )

            exportProgress = 1.0
            exportedFileURL = fileURL
            exportOperation = nil

            showSuccess("Successfully exported \(measurements.count) measurements to JSON")
            onExportComplete?(fileURL)

            logger.log("JSON export completed: \(fileURL.path)")

        } catch let error as ExportError {
            showError("Export Failed", error.localizedDescription)
            logger.log("JSON export failed: \(error.localizedDescription)")
        } catch {
            showError("Export Failed", error.localizedDescription)
            logger.log("JSON export failed: \(error.localizedDescription)")
        }
    }

    /// Generate a stress report for a date range
    /// - Parameters:
    ///   - startDate: Report start date
    ///   - endDate: Report end date
    public func generateReport(startDate: Date, endDate: Date) async {
        isExporting = true
        exportProgress = 0.0
        exportOperation = "Generating stress report"
        errorMessage = nil
        exportedFileURL = nil

        defer {
            isExporting = false
        }

        do {
            exportOperation = "Collecting data for report"
            exportProgress = 0.2

            let fileURL = try await dataManagementService.generateReport(
                startDate: startDate,
                endDate: endDate
            )

            exportProgress = 1.0
            exportedFileURL = fileURL
            exportOperation = nil

            showSuccess("Successfully generated stress report")
            onExportComplete?(fileURL)

            logger.log("Report generation completed: \(fileURL.path)")

        } catch let error as ExportError {
            showError("Report Failed", error.localizedDescription)
            logger.log("Report generation failed: \(error.localizedDescription)")
        } catch {
            showError("Report Failed", error.localizedDescription)
            logger.log("Report generation failed: \(error.localizedDescription)")
        }
    }

    // MARK: - Delete Operations

    /// Show confirmation dialog for delete all operation
    public func confirmDeleteAll() {
        pendingDeleteOperation = .deleteAll
        showDeleteConfirmation = true
    }

    /// Show confirmation dialog for delete before date operation
    /// - Parameter date: Cutoff date
    public func confirmDeleteBefore(date: Date) {
        pendingDeleteOperation = .deleteBefore(date)
        showDeleteConfirmation = true
    }

    /// Show confirmation dialog for delete in range operation
    /// - Parameter range: Date range
    public func confirmDeleteInRange(range: ClosedRange<Date>) {
        pendingDeleteOperation = .deleteInRange(range)
        showDeleteConfirmation = true
    }

    /// Show confirmation dialog for CloudKit reset operation
    public func confirmCloudKitReset() {
        pendingDeleteOperation = .resetCloudKit
        showDeleteConfirmation = true
    }

    /// Show confirmation dialog for factory reset operation
    public func confirmFactoryReset() {
        pendingDeleteOperation = .factoryReset
        showDeleteConfirmation = true
    }

    /// Execute the pending delete operation
    public func executePendingDelete() async {
        guard let operation = pendingDeleteOperation else {
            logger.log("No pending delete operation")
            return
        }

        showDeleteConfirmation = false
        await executeDelete(operation)
        pendingDeleteOperation = nil
    }

    /// Cancel the pending delete operation
    public func cancelPendingDelete() {
        showDeleteConfirmation = false
        pendingDeleteOperation = nil
    }

    /// Execute a specific delete operation
    private func executeDelete(_ operation: DeleteOperation) async {
        isDeleting = true
        deleteProgress = 0.0
        errorMessage = nil

        defer {
            isDeleting = false
        }

        do {
            switch operation {
            case .deleteAll:
                deleteOperation = "Deleting all measurements"
                try await dataDeleterService.deleteAllMeasurements()
                showSuccess("All measurements have been deleted")

            case .deleteBefore(let date):
                deleteOperation = "Deleting measurements before \(date)"
                try await dataDeleterService.deleteMeasurements(before: date)
                let count = await dataDeleterService.getTotalCount()
                showSuccess("Old measurements have been deleted. \(count) measurements remaining.")

            case .deleteInRange(let range):
                deleteOperation = "Deleting measurements in range"
                try await dataDeleterService.deleteMeasurements(in: range)
                showSuccess("Measurements in selected range have been deleted")

            case .resetCloudKit:
                deleteOperation = "Resetting CloudKit data"
                try await dataDeleterService.resetCloudKitData()
                showSuccess("CloudKit data has been reset")

            case .factoryReset:
                deleteOperation = "Performing factory reset"
                try await dataDeleterService.performFactoryReset()
                showSuccess("Factory reset complete. All data has been cleared.")
            }

            deleteProgress = 1.0
            deleteOperation = nil

            // Refresh statistics
            await loadStatistics()

            onDeleteComplete?()

            logger.log("Delete operation completed: \(operation)")

        } catch let error as DeletionError {
            showError("Delete Failed", error.localizedDescription)
            logger.log("Delete operation failed: \(error.localizedDescription)")
        } catch let error as CloudKitResetError {
            showError("Delete Failed", error.localizedDescription)
            logger.log("Delete operation failed: \(error.localizedDescription)")
        } catch {
            showError("Delete Failed", error.localizedDescription)
            logger.log("Delete operation failed: \(error.localizedDescription)")
        }
    }

    // MARK: - Helper Methods

    /// Fetch measurements within optional date range
    private func fetchMeasurements(forStart startDate: Date?, end endDate: Date?) async throws -> [StressMeasurement] {
        if let start = startDate, let end = endDate {
            return try await repository.fetchMeasurements(from: start, to: end)
        } else if let start = startDate {
            return try await repository.fetchMeasurements(from: start, to: Date())
        } else if let end = endDate {
            return try await repository.fetchAll().filter { $0.timestamp <= end }
        } else {
            return try await repository.fetchAll()
        }
    }

    /// Show error alert
    private func showError(_ title: String, _ message: String) {
        errorTitle = title
        errorMessage = message
    }

    /// Show success alert
    private func showSuccess(_ message: String) {
        successMessage = message
        showSuccessAlert = true
    }

    /// Clear error state
    public func clearError() {
        errorMessage = nil
        errorTitle = nil
    }

    /// Clear success state
    public func clearSuccess() {
        successMessage = nil
        showSuccessAlert = false
    }
}

// MARK: - Delete Operation

public enum DeleteOperation: Equatable, Sendable {
    case deleteAll
    case deleteBefore(Date)
    case deleteInRange(ClosedRange<Date>)
    case resetCloudKit
    case factoryReset

    public static func == (lhs: DeleteOperation, rhs: DeleteOperation) -> Bool {
        switch (lhs, rhs) {
        case (.deleteAll, .deleteAll):
            return true
        case (.deleteBefore(let lDate), .deleteBefore(let rDate)):
            return lDate == rDate
        case (.deleteInRange(let lRange), .deleteInRange(let rRange)):
            return lRange.lowerBound == rRange.lowerBound && lRange.upperBound == rRange.upperBound
        case (.resetCloudKit, .resetCloudKit):
            return true
        case (.factoryReset, .factoryReset):
            return true
        default:
            return false
        }
    }
}

// MARK: - Logger

struct Logger {
    static let `default` = Logger()

    func log(_ message: String) {
        #if DEBUG
        print("[DataManagementViewModel] \(message)")
        #endif
        os_log("%{public}@", log: .default, type: .info, message)
    }
}

// MARK: - Imports

import CloudKit
import os
</file>

<file path="StressMonitor/StressMonitor/Views/Breathing/Components/BeforeAfterChart.swift">
import SwiftUI

struct BeforeAfterChart: View {
    let beforeValue: Double
    let afterValue: Double

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Before / After")
                .font(Typography.headline)

            HStack(alignment: .bottom, spacing: 16) {
                VStack(spacing: 8) {
                    BarView(
                        value: beforeValue,
                        maxValue: max(beforeValue, afterValue) * 1.2,
                        color: .stressHigh
                    )

                    Text("\(Int(beforeValue)) ms")
                        .font(Typography.caption1)
                        .foregroundColor(.secondary)
                }

                VStack(spacing: 8) {
                    BarView(
                        value: afterValue,
                        maxValue: max(beforeValue, afterValue) * 1.2,
                        color: afterValue > beforeValue ? .stressRelaxed : .stressHigh
                    )

                    Text("\(Int(afterValue)) ms")
                        .font(Typography.caption1)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }
}

struct BarView: View {
    let value: Double
    let maxValue: Double
    let color: Color

    var body: some View {
        GeometryReader { geometry in
            VStack(spacing: 0) {
                Spacer()

                RoundedRectangle(cornerRadius: 8)
                    .fill(color)
                    .frame(height: geometry.size.height * (value / maxValue))

                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.secondary.opacity(0.2))
            }
        }
        .frame(width: 60, height: 150)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Breathing/Components/BreathingCircleView.swift">
import SwiftUI

struct BreathingCircleView: View {
    let phase: BreathingSessionViewModel.BreathingPhase
    let scale: Double
    let color: Color

    @State private var pulseAnimation = false

    var body: some View {
        ZStack {
            Circle()
                .stroke(
                    color.opacity(0.2),
                    style: StrokeStyle(lineWidth: 4, lineCap: .round)
                )
                .frame(width: 280, height: 280)
                .scaleEffect(pulseAnimation ? 1.05 : 1.0)
                .animation(
                    .easeInOut(duration: breathingDuration).repeatForever(autoreverses: true),
                    value: pulseAnimation
                )

            Circle()
                .fill(
                    LinearGradient(
                        colors: [color, color.opacity(0.6)],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 200, height: 200)
                .scaleEffect(scale)
                .shadow(color: color.opacity(0.3), radius: 20)

            Circle()
                .fill(Color.white.opacity(0.3))
                .frame(width: 150, height: 150)
                .scaleEffect(scale)
                .blur(radius: 10)

            Circle()
                .fill(Color.white.opacity(0.5))
                .frame(width: 60, height: 60)
                .scaleEffect(scale)
        }
        .onAppear {
            pulseAnimation = true
        }
    }

    private var breathingDuration: Double {
        switch phase {
        case .inhale: return 4.0
        case .hold: return 1.0
        case .exhale: return 6.0
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Breathing/BreathingExerciseView.swift">
import SwiftUI

// MARK: - Breathing Exercise View

/// 4-7-8 Breathing Exercise Screen
/// Implements: 4s inhale, 7s hold, 8s exhale, 1s pause between cycles
/// Full Reduce Motion support with static circle and text instructions
struct BreathingExerciseView: View {
    @Environment(\.accessibilityReduceMotion) var reduceMotion
    @Environment(\.dismiss) var dismiss
    @State private var phase: BreathingPhase = .inhale
    @State private var cycleCount: Int = 0
    @State private var isPaused: Bool = false
    @State private var timer: Timer?
    @State private var progress: Double = 0
    @State private var isCancelled = false

    private let totalCycles = 4
    private let maxCycles = 4

    var body: some View {
        ZStack {
            Color.Wellness.background
                .ignoresSafeArea()

            ScrollView {
                VStack(spacing: DesignTokens.Spacing.lg) {
                    headerSection

                    breathingCircleSection

                    progressSection

                    instructionSection

                    tipsSection

                    Spacer()
                }
                .padding(DesignTokens.Spacing.md)
            }

            controlButtons
        }
        .onAppear {
            startBreathingSession()
        }
        .onDisappear {
            stopBreathingSession()
        }
    }

    // MARK: - Header Section

    private var headerSection: some View {
        VStack(spacing: DesignTokens.Spacing.sm) {
            HStack {
                Button(action: {
                    HapticManager.shared.buttonPress()
                    dismiss()
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.title2)
                        .foregroundStyle(.secondary)
                }
                .frame(width: DesignTokens.Layout.minTouchTarget, height: DesignTokens.Layout.minTouchTarget)
                .accessibilityLabel("Close breathing exercise")

                Spacer()

                Text("Breathing Exercise")
                    .font(Typography.title2)
                    .fontWeight(.bold)

                Spacer()

                Color.clear
                    .frame(width: DesignTokens.Layout.minTouchTarget, height: DesignTokens.Layout.minTouchTarget)
            }

            Text("4-7-8 Breathing Technique")
                .font(Typography.callout)
                .foregroundStyle(.secondary)
        }
    }

    // MARK: - Breathing Circle Section

    private var breathingCircleSection: some View {
        VStack(spacing: DesignTokens.Spacing.md) {
            if reduceMotion {
                staticBreathingCircle
            } else {
                animatedBreathingCircle
            }

            Text(phase.displayText)
                .font(Typography.title1)
                .fontWeight(.bold)
                .foregroundStyle(phase.color)
                .accessibilityLabel("Breathing phase: \(phase.displayText)")
                .accessibilityAddTraits(.updatesFrequently)
        }
        .frame(height: 300)
    }

    @ViewBuilder
    private var staticBreathingCircle: some View {
        ZStack {
            Circle()
                .fill(phase.color.opacity(0.2))
                .frame(width: 200, height: 200)

            Circle()
                .stroke(phase.color, lineWidth: 4)
                .frame(width: 200, height: 200)

            VStack(spacing: DesignTokens.Spacing.sm) {
                Image(systemName: phase.icon)
                    .font(.system(size: 60))
                    .foregroundStyle(phase.color)

                Text(phase.instruction)
                    .font(Typography.headline)
                    .foregroundStyle(.secondary)
                    .multilineTextAlignment(.center)
            }
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(phase.displayText). \(phase.instruction)")
    }

    @ViewBuilder
    private var animatedBreathingCircle: some View {
        ZStack {
            Circle()
                .fill(phase.color.opacity(0.2))
                .frame(width: 200, height: 200)
                .scaleEffect(circleScale)

            Circle()
                .stroke(phase.color, lineWidth: 4)
                .frame(width: 200, height: 200)
                .scaleEffect(circleScale)

            Image(systemName: phase.icon)
                .font(.system(size: 60))
                .foregroundStyle(phase.color)
        }
        .accessibilityHidden(true)
    }

    private var circleScale: CGFloat {
        switch phase {
        case .inhale:
            return progress
        case .hold:
            return 1.2
        case .exhale:
            return 1.2 - (progress * 0.4)
        case .pause:
            return 0.8
        }
    }

    // MARK: - Progress Section

    private var progressSection: some View {
        VStack(spacing: DesignTokens.Spacing.sm) {
            HStack {
                Text("Cycle \(cycleCount + 1) of \(totalCycles)")
                    .font(Typography.callout)
                    .foregroundStyle(.secondary)

                Spacer()

                Text("\(Int(progress * phase.duration))s")
                    .font(Typography.callout)
                    .foregroundStyle(.secondary)
                    .monospacedDigit()
            }

            ProgressView(value: progress)
                .tint(phase.color)
                .accessibilityLabel("Cycle progress: \(cycleCount + 1) of \(totalCycles)")
                .accessibilityValue("\(Int(progress * 100)) percent complete")
        }
        .padding(DesignTokens.Spacing.md)
        .background(Color.Wellness.surface)
        .cornerRadius(DesignTokens.Layout.cornerRadius)
    }

    // MARK: - Instruction Section

    private var instructionSection: some View {
        VStack(alignment: .leading, spacing: DesignTokens.Spacing.md) {
            Text("Breathing Pattern")
                .font(Typography.headline)
                .fontWeight(.semibold)

            VStack(alignment: .leading, spacing: DesignTokens.Spacing.sm) {
                patternRow(icon: "arrow.down.circle.fill", text: "Inhale for 4 seconds", color: .blue)
                patternRow(icon: "pause.circle.fill", text: "Hold for 7 seconds", color: .purple)
                patternRow(icon: "arrow.up.circle.fill", text: "Exhale for 8 seconds", color: .green)
                patternRow(icon: "moon.circle.fill", text: "Pause for 1 second", color: .secondary)
            }
        }
        .padding(DesignTokens.Spacing.md)
        .background(Color.Wellness.surface)
        .cornerRadius(DesignTokens.Layout.cornerRadius)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Breathing pattern: Inhale 4 seconds, Hold 7 seconds, Exhale 8 seconds, Pause 1 second")
    }

    private func patternRow(icon: String, text: String, color: Color) -> some View {
        HStack(spacing: DesignTokens.Spacing.sm) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundStyle(color)
                .frame(width: DesignTokens.Layout.minTouchTarget)

            Text(text)
                .font(Typography.callout)
                .foregroundStyle(.primary)
        }
    }

    // MARK: - Tips Section

    private var tipsSection: some View {
        VStack(alignment: .leading, spacing: DesignTokens.Spacing.md) {
            Text("Tips")
                .font(Typography.headline)
                .fontWeight(.semibold)

            VStack(alignment: .leading, spacing: DesignTokens.Spacing.sm) {
                tipRow(icon: "heart.fill", text: "Focus on slow, deep breaths")
                tipRow(icon: "figure.mind.and.body", text: "Relax your shoulders and jaw")
                tipRow(icon: "moon.stars.fill", text: "Find a quiet, comfortable place")
            }
        }
        .padding(DesignTokens.Spacing.md)
        .background(Color.Wellness.surface)
        .cornerRadius(DesignTokens.Layout.cornerRadius)
    }

    private func tipRow(icon: String, text: String) -> some View {
        HStack(spacing: DesignTokens.Spacing.sm) {
            Image(systemName: icon)
                .font(.body)
                .foregroundStyle(Color.Wellness.calmBlue)
                .frame(width: 30)

            Text(text)
                .font(Typography.callout)
                .foregroundStyle(.secondary)
        }
    }

    // MARK: - Control Buttons

    private var controlButtons: some View {
        VStack {
            Spacer()

            Button(action: togglePause) {
                HStack {
                    Image(systemName: isPaused ? "play.fill" : "pause.fill")
                        .font(.title3)

                    Text(isPaused ? "Resume" : "Pause")
                        .font(Typography.headline)
                }
                .foregroundStyle(.white)
                .frame(maxWidth: .infinity)
                .frame(height: 52)
                .background(Color.Wellness.calmBlue)
                .cornerRadius(26)
                .shadow(color: Color.black.opacity(0.1), radius: 8, y: 4)
            }
            .padding(.horizontal, DesignTokens.Spacing.lg)
            .padding(.bottom, DesignTokens.Spacing.xl)
            .accessibilityLabel(isPaused ? "Resume breathing exercise" : "Pause breathing exercise")
        }
    }

    // MARK: - Breathing Logic

    private func startBreathingSession() {
        guard !isPaused else { return }

        cycleCount = 0
        phase = .inhale
        progress = 0

        startPhaseTimer()
    }

    private func stopBreathingSession() {
        isCancelled = true
        timer?.invalidate()
        timer = nil
    }

    private func togglePause() {
        HapticManager.shared.buttonPress()
        isPaused.toggle()

        if isPaused {
            timer?.invalidate()
        } else {
            startPhaseTimer()
        }
    }

    private func startPhaseTimer() {
        timer?.invalidate()

        let updateInterval = 0.1
        var elapsed: Double = 0

        timer = Timer.scheduledTimer(withTimeInterval: updateInterval, repeats: true) { _ in
            guard !isCancelled && !isPaused else { return }

            elapsed += updateInterval
            progress = min(elapsed / phase.duration, 1.0)

            if elapsed >= phase.duration {
                advancePhase()
                elapsed = 0
                progress = 0
            }
        }
    }

    private func advancePhase() {
        HapticManager.shared.breathingCue()

        switch phase {
        case .inhale:
            phase = .hold
        case .hold:
            phase = .exhale
        case .exhale:
            phase = .pause
        case .pause:
            cycleCount += 1
            if cycleCount >= totalCycles {
                sessionComplete()
            } else {
                phase = .inhale
            }
        }
    }

    private func sessionComplete() {
        timer?.invalidate()
        HapticManager.shared.success()

        // Show completion state
        isPaused = true
    }
}

// MARK: - Breathing Phase

enum BreathingPhase {
    case inhale
    case hold
    case exhale
    case pause

    var duration: Double {
        switch self {
        case .inhale: return 4.0
        case .hold: return 7.0
        case .exhale: return 8.0
        case .pause: return 1.0
        }
    }

    var displayText: String {
        switch self {
        case .inhale: return "Inhale"
        case .hold: return "Hold"
        case .exhale: return "Exhale"
        case .pause: return "Pause"
        }
    }

    var instruction: String {
        switch self {
        case .inhale: return "Breathe in slowly through your nose"
        case .hold: return "Hold your breath gently"
        case .exhale: return "Breathe out slowly through your mouth"
        case .pause: return "Relax and prepare"
        }
    }

    var icon: String {
        switch self {
        case .inhale: return "arrow.down.circle.fill"
        case .hold: return "pause.circle.fill"
        case .exhale: return "arrow.up.circle.fill"
        case .pause: return "moon.circle.fill"
        }
    }

    var color: Color {
        switch self {
        case .inhale: return .blue
        case .hold: return .purple
        case .exhale: return .green
        case .pause: return .secondary
        }
    }
}

// MARK: - Preview

#Preview {
    BreathingExerciseView()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Breathing/BreathingSessionView.swift">
import SwiftUI
import SwiftData

struct BreathingSessionView: View {
    @State private var viewModel: BreathingSessionViewModel?
    @Environment(\.dismiss) private var dismiss
    @State private var showSummary = false

    var body: some View {
        ZStack {
            LinearGradient(
                colors: breathingGradient,
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()

            VStack(spacing: 32) {
                HStack {
                    Spacer()

                    Button(action: {
                        viewModel?.endSession()
                        dismiss()
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title)
                            .foregroundColor(.secondary)
                    }
                }
                .padding(.trailing)

                Spacer()

                if let viewModel = viewModel {
                    BreathingCircleView(
                        phase: viewModel.breathingPhase,
                        scale: viewModel.circleScale,
                        color: breathingColor
                    )
                    .frame(height: 320)
                }

                VStack(spacing: 8) {
                    Text(instructionText)
                        .font(.system(size: 32, weight: .bold, design: .rounded))
                        .foregroundColor(.primary)

                    Text(subtitleText)
                        .font(Typography.body)
                        .foregroundColor(.secondary)
                }
                .animation(.easeInOut, value: viewModel?.breathingPhase)

                Spacer()

                Text(timeRemainingText)
                    .font(.system(size: 48, weight: .bold, design: .rounded))
                    .foregroundColor(.primary)

                Button(action: {
                    viewModel?.endSession()
                    showSummary = true
                }) {
                    Text("End Session")
                        .font(Typography.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 52)
                        .background(Color.secondary.opacity(0.3))
                        .cornerRadius(26)
                        .overlay(
                            RoundedRectangle(cornerRadius: 26)
                                .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                        )
                }
                .padding(.horizontal, 32)
                .padding(.bottom, 32)
            }
        }
        .onAppear {
            viewModel = BreathingSessionViewModel()
            viewModel?.startSession()
        }
        .onDisappear {
            viewModel?.endSession()
        }
        .navigationDestination(isPresented: $showSummary) {
            if let result = viewModel?.sessionResult {
                BreathingSummaryView(result: result)
            }
        }
    }

    private var breathingGradient: [Color] {
        @Environment(\.colorScheme) var colorScheme
        if colorScheme == .dark {
            return [
                Color(red: 0.1, green: 0.1, blue: 0.15),
                Color(red: 0.05, green: 0.05, blue: 0.1)
            ]
        } else {
            return [
                Color(red: 0.97, green: 0.97, blue: 0.98),
                Color.white
            ]
        }
    }

    private var breathingColor: Color {
        guard let phase = viewModel?.breathingPhase else { return .stressRelaxed }
        switch phase {
        case .inhale:
            return .stressRelaxed
        case .hold:
            return .stressMild
        case .exhale:
            return .stressRelaxed.opacity(0.6)
        }
    }

    private var instructionText: String {
        guard let viewModel = viewModel else { return "" }
        switch viewModel.breathingPhase {
        case .inhale: return "Inhale..."
        case .hold: return "Hold..."
        case .exhale: return "Exhale..."
        }
    }

    private var subtitleText: String {
        guard let viewModel = viewModel else { return "" }
        switch viewModel.breathingPhase {
        case .inhale: return "Deeply through your nose"
        case .hold: return "Gently hold"
        case .exhale: return "Slowly out through your mouth"
        }
    }

    private var timeRemainingText: String {
        guard let viewModel = viewModel else { return "02:00" }
        let minutes = Int(viewModel.remainingTime) / 60
        let seconds = Int(viewModel.remainingTime) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Breathing/BreathingSummaryView.swift">
import SwiftUI

struct BreathingSummaryView: View {
    let result: BreathingSessionResult
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
                Spacer()
                    .frame(height: 32)

                ZStack {
                    Circle()
                        .fill(Color.stressRelaxed.opacity(0.1))
                        .frame(width: 100, height: 100)

                    Image(systemName: "checkmark.circle.fill")
                        .font(.system(size: 60))
                        .foregroundColor(.stressRelaxed)
                }

                Text("Session Complete")
                    .font(Typography.title1)
                    .fontWeight(.bold)

                improvementCard

                BeforeAfterChart(
                    beforeValue: result.preSessionHRV,
                    afterValue: result.postSessionHRV
                )
                .padding(.horizontal, 24)

                stressChangeBadge

                Spacer()

                VStack(spacing: 12) {
                    Button(action: { dismiss() }) {
                        Text("Done")
                            .font(Typography.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .frame(height: 52)
                            .background(Color.primaryBlue)
                            .cornerRadius(26)
                    }
                    .padding(.horizontal, 24)

                    Button(action: { shareResult() }) {
                        HStack {
                            Image(systemName: "square.and.arrow.up")
                            Text("Share Result")
                        }
                        .font(Typography.subheadline)
                        .foregroundColor(.primaryBlue)
                    }
                }
                .padding(.bottom, 32)
            }
        }
        .background(Color.backgroundLight)
        .navigationBarHidden(true)
    }

    private var improvementCard: some View {
        VStack(spacing: 16) {
            Text("HRV Improvement")
                .font(Typography.headline)
                .foregroundColor(.secondary)

            HStack(alignment: .firstTextBaseline, spacing: 4) {
                Text(sign)
                    .font(.system(size: 56, weight: .bold, design: .rounded))
                    .foregroundColor(improvementColor)

                Text("\(Int(abs(result.improvement)))ms")
                    .font(.system(size: 36, weight: .semibold, design: .rounded))
                    .foregroundColor(improvementColor)

                Text("(\(Int(result.percentageImprovement))%)")
                    .font(Typography.title3)
                    .foregroundColor(.secondary)
            }

            Text("Based on pre- and post-session measurements")
                .font(Typography.caption1)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
        .padding(24)
        .background(
            RoundedRectangle(cornerRadius: 20)
                .fill(Color.secondary.opacity(0.1))
        )
        .padding(.horizontal, 24)
    }

    private var stressChangeBadge: some View {
        HStack(spacing: 8) {
            VStack(spacing: 4) {
                Text("Before")
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)

                HStack(spacing: 4) {
                    Image(systemName: stressIcon(for: .high))
                        .font(Typography.caption1)

                    Text("Elevated")
                        .font(Typography.caption1)
                        .strikethrough()
                }
                .foregroundColor(.stressHigh)
            }

            Image(systemName: "arrow.right")
                .foregroundColor(.secondary)

            VStack(spacing: 4) {
                Text("After")
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)

                HStack(spacing: 4) {
                    Image(systemName: stressIcon(for: .mild))
                        .font(Typography.caption1)

                    Text("Normal")
                        .font(Typography.caption1)
                }
                .foregroundColor(.stressMild)
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
        .padding(.horizontal, 24)
    }

    private var sign: String {
        result.improvement >= 0 ? "+" : ""
    }

    private var improvementColor: Color {
        switch result.stressChange {
        case .improved: return .stressRelaxed
        case .stable: return .stressMild
        case .declined: return .stressHigh
        }
    }

    private func stressIcon(for category: StressCategory) -> String {
        Color.stressIcon(for: category)
    }

    private func shareResult() {
        let text = """
        Breathing Session Complete 🧘

        Duration: \(Int(result.duration / 60)) minutes
        Cycles: \(result.cyclesCompleted)

        HRV Improvement: \(sign)\(Int(result.improvement))ms (\(Int(result.percentageImprovement))%)
        """

        let activityVC = UIActivityViewController(
            activityItems: [text],
            applicationActivities: nil
        )

        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(activityVC, animated: true)
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Breathing/BreathingViewModel.swift">
import SwiftUI
import SwiftData

@Observable
@MainActor
class BreathingSessionViewModel {
    var sessionDuration: TimeInterval = 120
    var remainingTime: TimeInterval = 120
    var breathingPhase: BreathingPhase = .inhale
    var circleScale: Double = 1.0
    var isActive = false
    var sessionResult: BreathingSessionResult?

    private let healthKit: HealthKitServiceProtocol
    private var timer: Timer?
    private var breathingTimer: Timer?
    private var preSessionHRV: Double?
    private var postSessionHRV: Double?

    enum BreathingPhase {
        case inhale
        case hold
        case exhale
    }

    init(healthKit: HealthKitServiceProtocol) {
        self.healthKit = healthKit
    }

    convenience init() {
        self.init(healthKit: HealthKitManager())
    }

    func startSession() {
        isActive = true
        remainingTime = sessionDuration
        circleScale = 1.0

        Task {
            if let hrv = try? await healthKit.fetchLatestHRV() {
                preSessionHRV = hrv.value
            }
        }

        startBreathingCycle()
        startCountdown()
    }

    func endSession() {
        isActive = false
        timer?.invalidate()
        breathingTimer?.invalidate()

        Task {
            if let hrv = try? await healthKit.fetchLatestHRV() {
                postSessionHRV = hrv.value
            }

            if let pre = preSessionHRV, let post = postSessionHRV {
                sessionResult = BreathingSessionResult(
                    preSessionHRV: pre,
                    postSessionHRV: post,
                    duration: sessionDuration - remainingTime,
                    cyclesCompleted: Int((sessionDuration - remainingTime) / 10)
                )
            }
        }
    }

    private func startBreathingCycle() {
        guard isActive else { return }

        breathingPhase = .inhale
        animateCircle(to: 1.4, duration: 4.0)

        DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) { [weak self] in
            guard let self = self, self.isActive else { return }

            self.breathingPhase = .hold

            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
                guard let self = self, self.isActive else { return }

                self.breathingPhase = .exhale
                self.animateCircle(to: 0.6, duration: 6.0)

                DispatchQueue.main.asyncAfter(deadline: .now() + 6.0) { [weak self] in
                    self?.startBreathingCycle()
                }
            }
        }
    }

    private func animateCircle(to scale: Double, duration: TimeInterval) {
        withAnimation(.easeInOut(duration: duration)) {
            circleScale = scale
        }
    }

    private func startCountdown() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                guard let self = self, self.remainingTime > 0 else {
                    return
                }

                self.remainingTime -= 1

                if self.remainingTime <= 0 {
                    self.endSession()
                    NotificationCenter.default.post(name: .breathingSessionComplete, object: self.sessionResult)
                }
            }
        }
    }
}

struct BreathingSessionResult {
    let preSessionHRV: Double
    let postSessionHRV: Double
    let duration: TimeInterval
    let cyclesCompleted: Int

    var improvement: Double {
        postSessionHRV - preSessionHRV
    }

    var percentageImprovement: Double {
        (improvement / preSessionHRV) * 100
    }

    var stressChange: StressChangeCategory {
        if improvement > 10 { return .improved }
        if improvement < -10 { return .declined }
        return .stable
    }
}

enum StressChangeCategory {
    case improved
    case stable
    case declined
}

extension Notification.Name {
    static let breathingSessionComplete = Notification.Name("breathingSessionComplete")
}
</file>

<file path="StressMonitor/StressMonitor/Views/Components/MeasureButton.swift">
import SwiftUI

struct MeasureButton: View {
    let isLoading: Bool
    let title: String
    let action: () async -> Void

    @State private var isTriggering = false

    init(isLoading: Bool = false, title: String = "Measure Now", action: @escaping () async -> Void) {
        self.isLoading = isLoading
        self.title = title
        self.action = action
    }

    var body: some View {
        Button {
            trigger()
        } label: {
            HStack {
                if isLoading || isTriggering {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(1.2)
                } else {
                    Text(title)
                        .font(.system(size: DesignTokens.Typography.body, weight: .semibold))
                }
            }
            .frame(maxWidth: .infinity)
            .frame(height: DesignTokens.Layout.minTouchTarget)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .clipShape(RoundedRectangle(cornerRadius: DesignTokens.Layout.cornerRadius))
        }
        .disabled(isLoading || isTriggering)
        .accessibilityLabel("Measure stress now")
        .accessibilityHint(isLoading ? "Measuring stress level" : "Tap to measure current stress level")
    }

    private func trigger() {
        isTriggering = true
        Task {
            await action()
            isTriggering = false
        }
    }
}

#Preview {
    VStack(spacing: DesignTokens.Spacing.lg) {
        MeasureButton(isLoading: false) {
            try? await Task.sleep(nanoseconds: 2_000_000_000)
        }
        MeasureButton(isLoading: true) {
            try? await Task.sleep(nanoseconds: 2_000_000_000)
        }
    }
    .padding()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Components/PrimaryMetricCard.swift">
import SwiftUI

struct PrimaryMetricCard: View {
    let stressLevel: StressCategory
    let hrvValue: Double
    let confidence: Double
    let lastUpdate: Date

    var body: some View {
        VStack(alignment: .leading, spacing: DesignTokens.Spacing.md) {
            HStack(spacing: DesignTokens.Spacing.sm) {
                Image(systemName: stressLevel.icon)
                    .font(.system(size: 40))
                    .foregroundColor(Color.stressColor(for: stressLevel))

                VStack(alignment: .leading, spacing: DesignTokens.Spacing.xs) {
                    Text(stressLevel.rawValue.capitalized)
                        .font(.system(size: DesignTokens.Typography.headline, weight: .bold))
                        .foregroundColor(Color.stressColor(for: stressLevel))

                    HStack(spacing: DesignTokens.Spacing.sm) {
                        Text("\(Int(confidence * 100))% confidence")
                            .font(.system(size: DesignTokens.Typography.caption))
                            .foregroundColor(.secondary)

                        Text("•")
                            .foregroundColor(.secondary)

                        Text(formattedTime)
                            .font(.system(size: DesignTokens.Typography.caption))
                            .foregroundColor(.secondary)
                    }
                }

                Spacer()
            }

            Divider()

            HStack(alignment: .firstTextBaseline, spacing: DesignTokens.Spacing.xs) {
                Text(String(format: "%.0f", hrvValue))
                    .font(.system(size: DesignTokens.Typography.largeTitle, weight: .medium))
                    .foregroundColor(.primary)

                Text("ms")
                    .font(.system(size: DesignTokens.Typography.body))
                    .foregroundColor(.secondary)
            }
        }
        .padding(DesignTokens.Layout.cardPadding)
        .background(Color(.systemBackground))
        .clipShape(RoundedRectangle(cornerRadius: DesignTokens.Layout.cornerRadius))
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("HRV measurement")
        .accessibilityValue("\(String(format: "%.0f", hrvValue)) milliseconds, \(stressLevel.rawValue) stress level")
    }

    private var formattedTime: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: lastUpdate, relativeTo: Date())
    }
}

#Preview {
    VStack(spacing: DesignTokens.Spacing.lg) {
        PrimaryMetricCard(
            stressLevel: .relaxed,
            hrvValue: 65,
            confidence: 0.95,
            lastUpdate: Date()
        )
        PrimaryMetricCard(
            stressLevel: .high,
            hrvValue: 25,
            confidence: 0.72,
            lastUpdate: Date().addingTimeInterval(-3600)
        )
    }
    .padding()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/AIInsightCard.swift">
import SwiftUI

struct AIInsight: Sendable {
    let title: String
    let message: String
    let actionTitle: String?
    let trendData: [Double]?
}

struct AIInsightCard: View {
    let insight: AIInsight
    var onTapAction: (() -> Void)?

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            header

            VStack(alignment: .leading, spacing: 8) {
                Text(insight.title)
                    .font(.subheadline)
                    .fontWeight(.semibold)

                Text(insight.message)
                    .font(.body)
                    .foregroundColor(.secondary)
            }

            if let actionTitle = insight.actionTitle {
                Button(action: { onTapAction?() }) {
                    HStack {
                        Text(actionTitle)
                            .font(.subheadline)
                            .fontWeight(.semibold)

                        Spacer()

                        Image(systemName: "chevron.right")
                            .font(.caption)
                    }
                    .foregroundColor(.primaryBlue)
                    .padding(.vertical, 8)
                }
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(Color.primaryBlue.opacity(0.2), lineWidth: 1)
        )
    }

    private var header: some View {
        HStack {
            Image(systemName: "sparkles")
                .foregroundColor(.primaryBlue)
                .font(.title3)

            Text("AI Insight")
                .font(.headline)

            Spacer()

            if let trendData = insight.trendData, !trendData.isEmpty {
                MiniSparkline(data: trendData)
                    .frame(width: 60, height: 30)
            }
        }
    }
}

struct MiniSparkline: View {
    let data: [Double]

    var body: some View {
        GeometryReader { geometry in
            let normalized = normalize(data: data)
            let points = zip(normalized.indices, normalized).map { index, value in
                CGPoint(
                    x: CGFloat(index) / CGFloat(max(1, normalized.count - 1)) * geometry.size.width,
                    y: geometry.size.height - (value * geometry.size.height)
                )
            }

            Path { path in
                if let first = points.first {
                    path.move(to: first)
                }
                for point in points.dropFirst() {
                    path.addLine(to: point)
                }
            }
            .stroke(Color.primaryBlue, lineWidth: 2)
        }
    }

    private func normalize(data: [Double]) -> [Double] {
        guard let min = data.min(), let max = data.max(), max > min else { return data }
        let range = max - min
        return data.map { ($0 - min) / range }
    }
}

#Preview {
    VStack(spacing: 16) {
        AIInsightCard(insight: AIInsight(
            title: "High Stress Detected",
            message: "Your stress is elevated. Consider a breathing exercise.",
            actionTitle: "Start Breathing",
            trendData: [0.3, 0.5, 0.7, 0.6, 0.8, 0.9]
        ))

        AIInsightCard(insight: AIInsight(
            title: "Great Recovery",
            message: "Your HRV is excellent today. Keep up the good work!",
            actionTitle: nil,
            trendData: nil
        ))
    }
    .padding()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/DailyTimelineView.swift">
import SwiftUI

/// Timeline view showing intraday stress patterns
/// Displays 24-hour timeline with markers at 6-hour intervals
struct DailyTimelineView: View {
    let measurements: [StressMeasurement]
    let isExpanded: Bool

    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    private let hourMarkers: [Int] = [0, 6, 12, 18, 24]
    private let collapsedHeight: CGFloat = 60
    private let expandedHeight: CGFloat = 120

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Today's Timeline")
                        .font(.subheadline.bold())
                        .foregroundColor(.white)

                    if !measurements.isEmpty {
                        Text(averageText)
                            .font(.caption)
                            .foregroundColor(.oledTextSecondary)
                    }
                }

                Spacer()

                if measurements.isEmpty {
                    Text("No data")
                        .font(.caption)
                        .foregroundColor(.oledTextSecondary)
                } else {
                    Text("\(measurements.count) measurements")
                        .font(.caption)
                        .foregroundColor(.oledTextSecondary)
                }
            }

            // Timeline
            if measurements.isEmpty {
                emptyTimeline
            } else {
                timelineContent
            }
        }
        .padding(16)
        .background(Color.oledCardBackground)
        .cornerRadius(12)
        .accessibilityElement(children: .combine)
        .accessibilityLabel(accessibilityDescription)
    }

    // MARK: - Empty State

    private var emptyTimeline: some View {
        VStack(spacing: 8) {
            HStack(spacing: 8) {
                ForEach(hourMarkers.dropLast(), id: \.self) { hour in
                    Text(formatHour(hour))
                        .font(.caption2)
                        .foregroundColor(.oledTextSecondary)
                    Spacer()
                }
                Text("24")
                    .font(.caption2)
                    .foregroundColor(.oledTextSecondary)
            }

            Rectangle()
                .fill(Color.oledCardSecondary)
                .frame(height: 40)
                .cornerRadius(8)
                .overlay(
                    Text("Measure throughout the day to see patterns")
                        .font(.caption)
                        .foregroundColor(.oledTextSecondary)
                )
        }
    }

    // MARK: - Timeline Content

    private var timelineContent: some View {
        GeometryReader { geometry in
            let chartHeight = isExpanded ? expandedHeight : collapsedHeight

            ZStack(alignment: .top) {
                // Hour markers and grid lines
                HStack(spacing: 0) {
                    ForEach(Array(hourMarkers.enumerated()), id: \.element) { index, hour in
                        VStack(alignment: .leading, spacing: 4) {
                            Text(formatHour(hour))
                                .font(.system(size: 9))
                                .foregroundColor(.oledTextSecondary)

                            Rectangle()
                                .fill(Color.oledCardSecondary)
                                .frame(width: 1, height: chartHeight - 16)
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)

                        if index < hourMarkers.count - 1 {
                            Spacer()
                        }
                    }
                }

                // Data points
                ForEach(groupedByHour(), id: \.hour) { group in
                    dataPoint(for: group, in: geometry.size)
                }

                // Current time indicator
                currentTimeIndicator(in: geometry.size, chartHeight: chartHeight)
            }
        }
        .frame(height: isExpanded ? expandedHeight + 24 : collapsedHeight + 24)
        .clipped()
    }

    // MARK: - Data Point View

    private func dataPoint(for group: HourlyDataGroup, in size: CGSize) -> some View {
        let chartHeight = isExpanded ? expandedHeight : collapsedHeight
        let xPosition = (size.width / 24) * CGFloat(group.hour)
        let yPosition = chartHeight - (chartHeight * (group.averageStress / 100))

        return Circle()
            .fill(Color.stressColor(for: group.averageStress))
            .frame(width: pointSize(for: group.count), height: pointSize(for: group.count))
            .overlay(
                Text("\(group.count)")
                    .font(.system(size: 8, weight: .bold))
                    .foregroundColor(.white)
                    .opacity(group.count > 1 ? 1 : 0)
            )
            .position(x: xPosition, y: yPosition)
            .accessibilityHidden(true)
    }

    private func pointSize(for count: Int) -> CGFloat {
        min(10 + CGFloat(count * 3), 24)
    }

    // MARK: - Current Time Indicator

    private func currentTimeIndicator(in size: CGSize, chartHeight: CGFloat) -> some View {
        let currentHour = Calendar.current.component(.hour, from: Date())
        let currentMinute = Calendar.current.component(.minute, from: Date())
        let hourFraction = Double(currentHour) + Double(currentMinute) / 60.0
        let xPosition = (size.width / 24) * hourFraction

        return VStack(spacing: 0) {
            Triangle()
                .fill(Color.primaryBlue)
                .frame(width: 10, height: 5)

            Rectangle()
                .fill(Color.primaryBlue)
                .frame(width: 2, height: chartHeight - 16)
        }
        .position(x: xPosition, y: chartHeight / 2)
        .accessibilityHidden(true)
    }

    // MARK: - Helpers

    private func formatHour(_ hour: Int) -> String {
        switch hour {
        case 0: return "12 AM"
        case 6: return "6 AM"
        case 12: return "12 PM"
        case 18: return "6 PM"
        case 24: return "12 AM"
        default: return "\(hour)"
        }
    }

    private func groupedByHour() -> [HourlyDataGroup] {
        let calendar = Calendar.current
        let groups = Dictionary(grouping: measurements) { measurement -> Int in
            calendar.component(.hour, from: measurement.timestamp)
        }

        return groups.map { hour, measurements in
            HourlyDataGroup(
                hour: hour,
                averageStress: measurements.map(\.stressLevel).reduce(0, +) / Double(measurements.count),
                count: measurements.count
            )
        }.sorted { $0.hour < $1.hour }
    }

    private var averageText: String {
        guard !measurements.isEmpty else { return "" }
        let avg = measurements.map(\.stressLevel).reduce(0, +) / Double(measurements.count)
        return "Avg: \(Int(avg))%"
    }

    private var accessibilityDescription: String {
        if measurements.isEmpty {
            return "Today's timeline: No measurements yet"
        }

        let avg = measurements.map(\.stressLevel).reduce(0, +) / Double(measurements.count)
        return "Today's timeline: \(measurements.count) measurements, average stress \(Int(avg)) percent"
    }
}

// MARK: - Supporting Types

struct HourlyDataGroup {
    let hour: Int
    let averageStress: Double
    let count: Int
}

// MARK: - Triangle Shape

struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        path.closeSubpath()
        return path
    }
}

// MARK: - Preview

#Preview("Timeline - Empty") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()
        DailyTimelineView(measurements: [], isExpanded: false)
            .padding()
    }
}

#Preview("Timeline - With Data") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()

        let measurements = (0..<10).map { i in
            StressMeasurement(
                timestamp: Calendar.current.date(byAdding: .hour, value: i * 2, to: Date()) ?? Date(),
                stressLevel: Double.random(in: 20...70),
                hrv: Double.random(in: 30...80),
                restingHeartRate: 60,
                confidences: [0.8]
            )
        }

        DailyTimelineView(measurements: measurements, isExpanded: false)
            .padding()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/DashboardInsightCard.swift">
import SwiftUI

/// AI insight card for dashboard with title and description
struct DashboardInsightCard: View {
    let title: String
    let description: String

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.system(size: 15, weight: .semibold))
                .foregroundColor(Color.Wellness.insightTitle)

            Text(description)
                .font(.system(size: 14, weight: .regular))
                .foregroundColor(Color.Wellness.insightText)
                .lineLimit(nil)
        }
        .padding(16)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color.Wellness.adaptiveCardBackground)
        .cornerRadius(12)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Insight: \(title). \(description)")
    }
}

#Preview("DashboardInsightCard") {
    VStack {
        DashboardInsightCard(
            title: "Daily Insight",
            description: "Your stress levels have been lower this week. Keep up the good work with your breathing exercises."
        )
        Spacer()
    }
    .padding()
    .background(Color.Wellness.adaptiveBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/EmptyDashboardView.swift">
import SwiftUI

/// Empty state view for dashboard when no data available
/// Shows friendly character illustration and action CTAs
struct EmptyDashboardView: View {
    let onMeasure: () -> Void
    let onLearnMore: () -> Void

    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    var body: some View {
        VStack(spacing: 32) {
            Spacer()

            // Character illustration using existing StressCharacterCard
            StressCharacterCard(
                mood: .calm,
                stressLevel: 0,
                hrv: nil,
                size: .dashboard
            )
            .frame(width: 140, height: 140)
            .accessibilityHidden(true)

            // Message
            VStack(spacing: 12) {
                Text("No Stress Data Yet")
                    .font(.title2.bold())
                    .foregroundColor(.white)
                    .accessibilityAddTraits(.isHeader)

                Text("Start your first measurement to begin tracking your stress levels and see personalized insights.")
                    .font(.subheadline)
                    .foregroundColor(.oledTextSecondary)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)
            }
            .padding(.horizontal, 16)

            // CTA buttons
            VStack(spacing: 16) {
                Button(action: onMeasure) {
                    Label("Take First Measurement", systemImage: "waveform.path.ecg")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(Color.primaryBlue)
                        .foregroundColor(.white)
                        .cornerRadius(14)
                }
                .frame(minWidth: 44, minHeight: 44)
                .accessibilityLabel("Take your first stress measurement")
                .accessibilityHint("Double tap to start measuring your stress level")

                Button(action: onLearnMore) {
                    HStack(spacing: 4) {
                        Text("Learn How It Works")
                            .font(.subheadline)
                        Image(systemName: "chevron.right")
                            .font(.caption)
                    }
                    .foregroundColor(.primaryBlue)
                }
                .frame(minWidth: 44, minHeight: 44)
                .accessibilityLabel("Learn how stress monitoring works")
            }
            .padding(.horizontal, 24)

            Spacer()
        }
        .frame(maxWidth: .infinity)
        .accessibilityElement(children: .contain)
        .accessibilityLabel("No stress data available. Tap to take your first measurement.")
    }
}

// MARK: - Preview

#Preview("Empty State - Dark") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()
        EmptyDashboardView(
            onMeasure: {},
            onLearnMore: {}
        )
    }
}

#Preview("Empty State - Light") {
    ZStack {
        Color.backgroundLight.ignoresSafeArea()
        EmptyDashboardView(
            onMeasure: {},
            onLearnMore: {}
        )
    }
    .preferredColorScheme(.light)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/HealthDataSection.swift">
import SwiftUI

// MARK: - Health Data Section

/// Health stats display showing exercise, sleep, and daylight data
struct HealthDataSection: View {
    var body: some View {
        VStack(alignment: .leading, spacing: DesignTokens.Spacing.md) {
            // Section header
            HStack(spacing: DesignTokens.Spacing.sm) {
                Text("Your health data")
                    .font(Typography.headline)
                    .foregroundStyle(Color.Wellness.adaptiveSecondaryText)

                Button(action: {
                    HapticManager.shared.buttonPress()
                    // TODO: Show health data info
                }) {
                    Image(systemName: "info.circle")
                        .font(.body)
                        .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
                }
                .accessibilityLabel("Health data information")
            }

            // Health data items
            HStack(spacing: DesignTokens.Spacing.md) {
                HealthDataItem(
                    icon: "figure.run",
                    label: "Exercise",
                    value: "32",
                    unit: "min",
                    color: Color.Wellness.exerciseCyan
                )

                HealthDataItem(
                    icon: "bed.double.fill",
                    label: "Sleep",
                    value: "7.5",
                    unit: "hrs",
                    color: Color.Wellness.sleepPurple
                )

                HealthDataItem(
                    icon: "sun.max.fill",
                    label: "Daylight",
                    value: "45",
                    unit: "min",
                    color: Color.Wellness.daylightYellow
                )
            }
        }
        .accessibilityElement(children: .contain)
    }
}

// MARK: - Health Data Item

/// Individual health metric display with circular progress indicator placeholder
struct HealthDataItem: View {
    let icon: String
    let label: String
    let value: String
    let unit: String
    let color: Color

    var body: some View {
        VStack(spacing: DesignTokens.Spacing.sm) {
            // Circular progress indicator placeholder with icon
            ZStack {
                Circle()
                    .stroke(color.opacity(0.2), lineWidth: 3)
                    .frame(width: 48, height: 48)

                // Progress arc placeholder (static for now)
                Circle()
                    .trim(from: 0, to: 0.6)
                    .stroke(color, style: StrokeStyle(lineWidth: 3, lineCap: .round))
                    .frame(width: 48, height: 48)
                    .rotationEffect(.degrees(-90))

                Image(systemName: icon)
                    .font(.body)
                    .foregroundStyle(color)
            }

            // Value and unit
            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text(value)
                    .font(Typography.headline)
                    .fontWeight(.bold)
                    .foregroundStyle(.primary)

                Text(unit)
                    .font(Typography.caption1)
                    .foregroundStyle(.secondary)
            }

            // Label
            Text(label)
                .font(Typography.caption1)
                .foregroundStyle(.secondary)
                .lineLimit(1)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, DesignTokens.Spacing.sm)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(label): \(value) \(unit)")
    }
}

// MARK: - Preview

#Preview {
    HealthDataSection()
        .padding()
        .background(Color.Wellness.background)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/LearningPhaseCard.swift">
import SwiftUI

/// Card component showing learning phase progress during baseline calibration
/// Displays days remaining, sample count, and progress bar
struct LearningPhaseCard: View {
    let daysRemaining: Int
    let sampleCount: Int
    let minimumSamples: Int
    let onLearnMore: () -> Void

    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    private var progress: Double {
        min(Double(sampleCount) / Double(minimumSamples), 1.0)
    }

    private var statusText: String {
        if daysRemaining <= 0 {
            return "Baseline Established"
        } else if sampleCount < 10 {
            return "Collecting Initial Data"
        } else {
            return "Building Your Baseline"
        }
    }

    private var statusColor: Color {
        if daysRemaining <= 0 {
            return .primaryGreen
        } else if sampleCount < 10 {
            return .warning
        } else {
            return .primaryBlue
        }
    }

    var body: some View {
        VStack(spacing: 16) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    HStack(spacing: 8) {
                        Text("Learning Phase")
                            .font(.headline)
                            .foregroundColor(.white)

                        if daysRemaining > 0 {
                            Text("\(daysRemaining) days left")
                                .font(.caption.bold())
                                .foregroundColor(statusColor)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 3)
                                .background(statusColor.opacity(0.15))
                                .cornerRadius(6)
                        }
                    }

                    Text(statusText)
                        .font(.caption)
                        .foregroundColor(.oledTextSecondary)
                }

                Spacer()

                // Progress indicator
                ZStack {
                    Circle()
                        .stroke(Color.oledCardSecondary, lineWidth: 3)

                    Circle()
                        .trim(from: 0, to: progress)
                        .stroke(
                            statusColor,
                            style: StrokeStyle(lineWidth: 3, lineCap: .round)
                        )
                        .rotationEffect(.degrees(-90))
                        .animation(
                            reduceMotion ? .none : .easeOut(duration: 0.5),
                            value: progress
                        )

                    Text("\(Int(progress * 100))%")
                        .font(.system(size: 10, weight: .bold))
                        .foregroundColor(.white)
                }
                .frame(width: 36, height: 36)
            }

            // Progress bar
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.oledCardSecondary)
                        .frame(height: 8)

                    RoundedRectangle(cornerRadius: 4)
                        .fill(
                            LinearGradient(
                                colors: [.primaryBlue, statusColor],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * progress, height: 8)
                        .animation(
                            reduceMotion ? .none : .easeOut(duration: 0.5),
                            value: progress
                        )
                }
            }
            .frame(height: 8)

            // Sample count
            HStack {
                Text("\(sampleCount) of \(minimumSamples) samples")
                    .font(.caption2)
                    .foregroundColor(.oledTextSecondary)

                Spacer()

                Text("\(Int(progress * 100))% complete")
                    .font(.caption2.bold())
                    .foregroundColor(statusColor)
            }

            // Description
            Text("Individual HRV patterns vary greatly. We're learning your unique baseline to provide accurate stress insights.")
                .font(.caption)
                .foregroundColor(.oledTextSecondary)
                .multilineTextAlignment(.leading)
                .fixedSize(horizontal: false, vertical: true)

            // Learn more button
            Button(action: onLearnMore) {
                HStack(spacing: 4) {
                    Text("How It Works")
                        .font(.subheadline)
                    Image(systemName: "chevron.right")
                        .font(.caption)
                }
                .foregroundColor(.primaryBlue)
            }
            .frame(minWidth: 44, minHeight: 44)
        }
        .padding(20)
        .background(Color.oledCardBackground)
        .cornerRadius(16)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Learning Phase: \(statusText). \(sampleCount) of \(minimumSamples) samples collected, \(Int(progress * 100)) percent complete.")
    }
}

// MARK: - Preview

#Preview("Learning Phase - Early") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()
        LearningPhaseCard(
            daysRemaining: 7,
            sampleCount: 5,
            minimumSamples: 50,
            onLearnMore: {}
        )
        .padding()
    }
}

#Preview("Learning Phase - Mid") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()
        LearningPhaseCard(
            daysRemaining: 3,
            sampleCount: 30,
            minimumSamples: 50,
            onLearnMore: {}
        )
        .padding()
    }
}

#Preview("Learning Phase - Complete") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()
        LearningPhaseCard(
            daysRemaining: 0,
            sampleCount: 55,
            minimumSamples: 50,
            onLearnMore: {}
        )
        .padding()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/MiniLineChartView.swift">
import SwiftUI

/// Simple mini line chart for metric cards
struct MiniLineChartView: View {
    let dataPoints: [Double]
    let color: Color
    var showGradient: Bool = true

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                if showGradient {
                    // Gradient fill under the line
                    pathForFill(in: geometry.size)
                        .fill(
                            LinearGradient(
                                colors: [color.opacity(0.3), color.opacity(0.05)],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                }

                // Line
                pathForLine(in: geometry.size)
                    .stroke(color, style: StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round))
            }
        }
        .frame(height: 40)
    }

    // MARK: - Path Generation

    private func pathForLine(in size: CGSize) -> Path {
        var path = Path()
        guard !dataPoints.isEmpty else { return path }

        // Guard against single data point (division by zero)
        guard dataPoints.count > 1 else {
            // Draw a single dot for single data point
            let x = size.width / 2
            let y = size.height / 2
            path.addEllipse(in: CGRect(x: x - 2, y: y - 2, width: 4, height: 4))
            return path
        }

        let stepX = size.width / CGFloat(dataPoints.count - 1)
        let minValue = dataPoints.min() ?? 0
        let maxValue = dataPoints.max() ?? 1
        let range = max(maxValue - minValue, 1)

        for (index, value) in dataPoints.enumerated() {
            let x = CGFloat(index) * stepX
            let normalizedY = (value - minValue) / range
            let y = size.height - (normalizedY * size.height * 0.8) - (size.height * 0.1)

            if index == 0 {
                path.move(to: CGPoint(x: x, y: y))
            } else {
                path.addLine(to: CGPoint(x: x, y: y))
            }
        }

        return path
    }

    private func pathForFill(in size: CGSize) -> Path {
        var path = pathForLine(in: size)

        // Close the path to create a fill area
        guard dataPoints.count > 1 else { return path }

        let stepX = size.width / CGFloat(dataPoints.count - 1)
        let lastX = CGFloat(dataPoints.count - 1) * stepX

        path.addLine(to: CGPoint(x: lastX, y: size.height))
        path.addLine(to: CGPoint(x: 0, y: size.height))
        path.closeSubpath()

        return path
    }
}

#Preview("Mini Line Chart") {
    VStack(spacing: 20) {
        MiniLineChartView(
            dataPoints: [45, 52, 48, 55, 50, 58, 62],
            color: .hrvAccent
        )
        .frame(width: 100, height: 40)

        MiniLineChartView(
            dataPoints: [72, 68, 70, 65, 68, 72, 70],
            color: .heartRateAccent
        )
        .frame(width: 100, height: 40)

        MiniLineChartView(
            dataPoints: [20, 35, 28, 42, 38, 45, 52],
            color: .stressMild
        )
        .frame(width: 100, height: 40)
    }
    .padding()
    .background(Color.oledCardBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/NoDataCard.swift">
import SwiftUI

/// Reusable card component for displaying no data states
/// Used for individual metrics like HRV, Heart Rate, etc.
struct NoDataCard: View {
    let dataType: DataType
    let onAction: () -> Void

    enum DataType: String, CaseIterable {
        case hrv
        case heartRate
        case stress
        case timeline

        var icon: String {
            switch self {
            case .hrv: return "heart.circle"
            case .heartRate: return "waveform.path.ecg"
            case .stress: return "brain.head.profile"
            case .timeline: return "clock"
            }
        }

        var title: String {
            switch self {
            case .hrv: return "No HRV Data"
            case .heartRate: return "No Heart Rate Data"
            case .stress: return "No Stress Data"
            case .timeline: return "No Timeline Data"
            }
        }

        var description: String {
            switch self {
            case .hrv: return "HRV data will appear here after your first measurement."
            case .heartRate: return "Heart rate data will sync from Apple Watch."
            case .stress: return "Measure stress to see your patterns here."
            case .timeline: return "Timeline will populate as you take measurements."
            }
        }

        var actionTitle: String {
            switch self {
            case .hrv, .heartRate, .stress: return "Measure Now"
            case .timeline: return "Get Started"
            }
        }
    }

    var body: some View {
        VStack(spacing: 16) {
            // Icon
            Image(systemName: dataType.icon)
                .font(.system(size: 36, weight: .light))
                .foregroundColor(.oledTextSecondary)
                .accessibilityHidden(true)

            // Text content
            VStack(spacing: 6) {
                Text(dataType.title)
                    .font(.headline)
                    .foregroundColor(.white)

                Text(dataType.description)
                    .font(.caption)
                    .foregroundColor(.oledTextSecondary)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)
            }

            // Action button
            Button(action: onAction) {
                Text(dataType.actionTitle)
                    .font(.subheadline.bold())
                    .foregroundColor(.primaryBlue)
            }
            .frame(minWidth: 44, minHeight: 44)
        }
        .padding(24)
        .frame(maxWidth: .infinity)
        .background(Color.oledCardBackground)
        .cornerRadius(16)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(dataType.title). \(dataType.description)")
        .accessibilityHint("Double tap to \(dataType.actionTitle.lowercased())")
    }
}

// MARK: - Preview

#Preview("All No Data Cards") {
    ScrollView {
        VStack(spacing: 16) {
            ForEach(NoDataCard.DataType.allCases, id: \.self) { type in
                NoDataCard(dataType: type, onAction: {})
            }
        }
        .padding()
    }
    .background(Color.oledBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/PermissionErrorCard.swift">
import SwiftUI
import HealthKit

/// Card component for displaying HealthKit permission errors
/// Provides clear CTAs to grant access or open Settings
struct PermissionErrorCard: View {
    let permissionType: PermissionType
    let onGrantAccess: () -> Void

    @Environment(\.openURL) private var openURL

    enum PermissionType: String {
        case healthKit
        case heartRate
        case hrv

        var icon: String {
            switch self {
            case .healthKit: return "heart.text.square.fill"
            case .heartRate: return "waveform.path.ecg"
            case .hrv: return "heart.circle.fill"
            }
        }

        var title: String {
            switch self {
            case .healthKit: return "Health Access Required"
            case .heartRate: return "Heart Rate Access Needed"
            case .hrv: return "HRV Access Needed"
            }
        }

        var description: String {
            switch self {
            case .healthKit: return "StressMonitor needs access to read your health data for stress calculations. Your data stays private on your device."
            case .heartRate: return "Heart rate data is essential for accurate stress calculation. Grant access to enable monitoring."
            case .hrv: return "Heart Rate Variability is the primary indicator for stress levels. Allow access to continue."
            }
        }
    }

    var body: some View {
        VStack(spacing: 20) {
            // Icon with background
            ZStack {
                Circle()
                    .fill(Color.error.opacity(0.15))
                    .frame(width: 64, height: 64)

                Image(systemName: permissionType.icon)
                    .font(.system(size: 28))
                    .foregroundColor(.error)
            }
            .accessibilityHidden(true)

            // Text content
            VStack(spacing: 8) {
                Text(permissionType.title)
                    .font(.headline)
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)

                Text(permissionType.description)
                    .font(.subheadline)
                    .foregroundColor(.oledTextSecondary)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)
            }

            // CTA buttons
            VStack(spacing: 12) {
                Button(action: onGrantAccess) {
                    Text("Grant Access to Health")
                        .font(.subheadline.bold())
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 14)
                        .background(Color.primaryGreen)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                }
                .frame(minWidth: 44, minHeight: 44)
                .accessibilityLabel("Grant access to Health data")

                Button(action: openSettings) {
                    HStack(spacing: 4) {
                        Image(systemName: "gear")
                            .font(.caption)
                        Text("Open Settings")
                            .font(.subheadline)
                    }
                    .foregroundColor(.primaryBlue)
                }
                .frame(minWidth: 44, minHeight: 44)
                .accessibilityLabel("Open device Settings")
            }
        }
        .padding(24)
        .background(Color.oledCardBackground)
        .cornerRadius(16)
        .shadow(color: Color.black.opacity(0.2), radius: 8, y: 4)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(permissionType.title). \(permissionType.description)")
    }

    private func openSettings() {
        if let url = URL(string: UIApplication.openSettingsURLString) {
            openURL(url)
        }
    }
}

// MARK: - Preview

#Preview("Permission Error Card") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()

        VStack(spacing: 20) {
            PermissionErrorCard(
                permissionType: .healthKit,
                onGrantAccess: {}
            )

            PermissionErrorCard(
                permissionType: .heartRate,
                onGrantAccess: {}
            )
        }
        .padding()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/PremiumLockOverlay.swift">
import SwiftUI

// MARK: - Premium Lock Overlay

/// Semi-transparent overlay that indicates premium-only features
/// Displays lock icon and upgrade button when user is not premium
struct PremiumLockOverlay: View {
    @AppStorage("isPremiumUser") private var isPremiumUser = false
    @State private var showPremiumSheet = false

    var body: some View {
        ZStack {
            // Semi-transparent background
            Color.white.opacity(0.63)
                .ignoresSafeArea()

            // Lock button
            Button {
                showPremiumSheet = true
            } label: {
                HStack(spacing: 8) {
                    Image(systemName: "lock.fill")
                        .font(.system(size: 14, weight: .semibold))

                    Text("Unlock with Premium")
                        .font(Typography.subheadline)
                        .fontWeight(.semibold)
                }
                .foregroundStyle(Color(hex: "#1A1A1A"))
                .padding(.horizontal, 16)
                .padding(.vertical, 10)
                .background(Color(hex: "#FFD380"))
                .cornerRadius(20)
            }
            .buttonStyle(.plain)
        }
        .sheet(isPresented: $showPremiumSheet) {
            PremiumPlaceholderView()
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Premium feature locked. Tap to unlock with Premium subscription.")
    }
}

// MARK: - Premium Placeholder View

/// Placeholder view for premium upgrade screen
struct PremiumPlaceholderView: View {
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            VStack(spacing: 24) {
                Image(systemName: "crown.fill")
                    .font(.system(size: 64))
                    .foregroundStyle(Color(hex: "#FFD380"))
                    .padding(.top, 40)

                Text("Upgrade to Premium")
                    .font(Typography.title1)
                    .fontWeight(.bold)
                    .foregroundStyle(Color.Wellness.adaptivePrimaryText)

                VStack(spacing: 16) {
                    premiumFeatureRow(icon: "chart.bar.fill", text: "Advanced stress analytics")
                    premiumFeatureRow(icon: "calendar.badge.clock", text: "Unlimited history access")
                    premiumFeatureRow(icon: "bell.fill", text: "Custom stress alerts")
                    premiumFeatureRow(icon: "person.fill.checkmark", text: "Personalized insights")
                }
                .padding(.horizontal, 32)

                Spacer()

                Button {
                    // Premium purchase action placeholder
                    dismiss()
                } label: {
                    Text("Subscribe Now")
                        .font(Typography.headline)
                        .fontWeight(.semibold)
                        .foregroundStyle(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 54)
                        .background(Color.primaryBlue)
                        .cornerRadius(16)
                }
                .padding(.horizontal, 24)
                .padding(.bottom, 32)
            }
            .background(Color.Wellness.adaptiveBackground)
            .navigationTitle("")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Close") {
                        dismiss()
                    }
                }
            }
        }
    }

    private func premiumFeatureRow(icon: String, text: String) -> some View {
        HStack(spacing: 16) {
            Image(systemName: icon)
                .font(.system(size: 20))
                .foregroundStyle(Color.primaryBlue)
                .frame(width: 24)

            Text(text)
                .font(Typography.body)
                .foregroundStyle(Color.Wellness.adaptivePrimaryText)

            Spacer()
        }
    }
}

// MARK: - Preview

#Preview("Premium Lock Overlay") {
    ZStack {
        Color.gray.opacity(0.3)
            .frame(width: 358, height: 376)

        PremiumLockOverlay()
    }
    .padding()
}

#Preview("Premium Placeholder View") {
    PremiumPlaceholderView()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/QuickActionCard.swift">
import SwiftUI

// MARK: - Quick Action Card

/// Horizontal scrollable action cards for wellness activities
struct QuickActionCard<Destination: View>: View {
    let title: String
    let description: String
    let duration: String
    let color: Color
    let destination: () -> Destination

    var body: some View {
        NavigationLink(destination: destination()) {
            VStack(alignment: .leading, spacing: DesignTokens.Spacing.sm) {
                // Title
                Text(title)
                    .font(Typography.headline)
                    .fontWeight(.semibold)
                    .foregroundStyle(.white)
                    .lineLimit(1)

                // Description (13pt, 2 lines max)
                Text(description)
                    .font(Typography.footnote)
                    .foregroundStyle(.white.opacity(0.9))
                    .lineLimit(2)

                Spacer()

                // Duration badge and image placeholder
                HStack {
                    // Duration badge
                    Text(duration)
                        .font(Typography.caption1)
                        .fontWeight(.medium)
                        .foregroundStyle(.white)
                        .padding(.horizontal, DesignTokens.Spacing.sm)
                        .padding(.vertical, DesignTokens.Spacing.xs)
                        .background(Color.white.opacity(0.2))
                        .cornerRadius(8)

                    Spacer()

                    // Image placeholder
                    Image(systemName: "play.circle.fill")
                        .font(.title2)
                        .foregroundStyle(.white.opacity(0.8))
                }
            }
            .padding(DesignTokens.Layout.cardPadding)
            .frame(width: 268, height: 98)
            .background(color)
            .cornerRadius(DesignTokens.Layout.cornerRadius)
        }
        .buttonStyle(.plain)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(title). \(description). Duration: \(duration)")
        .accessibilityHint("Double tap to start activity")
    }
}

// MARK: - Convenience Static Methods

extension QuickActionCard where Destination == PlaceholderDestination {
    /// Gratitude journaling activity card
    static func gratitude() -> QuickActionCard<PlaceholderDestination> {
        QuickActionCard<PlaceholderDestination>(
            title: "Gratitude",
            description: "Take a moment to reflect on what you're grateful for",
            duration: "0:45s",
            color: Color.Wellness.gratitudePurple,
            destination: { PlaceholderDestination(title: "Gratitude") }
        )
    }

    /// Mini walk activity card
    static func miniWalk() -> QuickActionCard<PlaceholderDestination> {
        QuickActionCard<PlaceholderDestination>(
            title: "Mini Walk",
            description: "A short walk to refresh your mind and body",
            duration: "3 mins",
            color: Color.Wellness.miniWalkBlue,
            destination: { PlaceholderDestination(title: "Mini Walk") }
        )
    }
}

extension QuickActionCard where Destination == BreathingExerciseView {
    /// Box breathing exercise card
    static func boxBreathing() -> QuickActionCard<BreathingExerciseView> {
        QuickActionCard<BreathingExerciseView>(
            title: "Box Breathing",
            description: "A calming breathing technique for stress relief",
            duration: "3 mins",
            color: Color.Wellness.boxBreathingPurple,
            destination: { BreathingExerciseView() }
        )
    }
}

// MARK: - Placeholder Destination

/// Placeholder view for activities not yet implemented
struct PlaceholderDestination: View {
    let title: String

    var body: some View {
        VStack(spacing: DesignTokens.Spacing.lg) {
            Image(systemName: "figure.mind.and.body")
                .font(.system(size: 60))
                .foregroundStyle(Color.Wellness.calmBlue)

            Text(title)
                .font(Typography.title2)
                .fontWeight(.bold)

            Text("Coming soon")
                .font(Typography.callout)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.Wellness.background)
        .navigationTitle(title)
        .navigationBarTitleDisplayMode(.inline)
    }
}

// MARK: - Preview

#Preview {
    NavigationStack {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: DesignTokens.Spacing.md) {
                QuickActionCard.gratitude()
                QuickActionCard.miniWalk()
                QuickActionCard.boxBreathing()
            }
            .padding()
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/QuickStatCard.swift">
import SwiftUI

struct QuickStatCard: View {
    let icon: String
    let value: String
    let unit: String
    let label: String
    let tintColor: Color

    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundColor(tintColor)
                .frame(width: 44, height: 44)
                .background(tintColor.opacity(0.15))
                .cornerRadius(12)

            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text(value)
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundColor(.primary)

                if !unit.isEmpty {
                    Text(unit)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }

            Text(label)
                .font(.caption2)
                .foregroundColor(.secondary)
                .lineLimit(1)
        }
        .frame(maxWidth: .infinity)
        .padding(16)
        .background(Color.secondary.opacity(0.1))
        .cornerRadius(16)
    }
}

#Preview {
    HStack(spacing: 12) {
        QuickStatCard(
            icon: "heart.fill",
            value: "45",
            unit: "ms",
            label: "Today's HRV",
            tintColor: .red
        )

        QuickStatCard(
            icon: "chart.xyaxis.lines",
            value: "↑",
            unit: "",
            label: "7-Day",
            tintColor: .stressRelaxed
        )

        QuickStatCard(
            icon: "scale.3d",
            value: "35-55",
            unit: "",
            label: "Baseline",
            tintColor: .primaryBlue
        )
    }
    .padding()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/SelfNoteCard.swift">
import SwiftUI

// MARK: - Self Note Card

/// Teal journal prompt card that opens NoteEntryView as a sheet
struct SelfNoteCard: View {
    @State private var isShowingNoteEntry = false

    var body: some View {
        Button(action: {
            HapticManager.shared.buttonPress()
            isShowingNoteEntry = true
        }) {
            HStack(spacing: DesignTokens.Spacing.md) {
                // Avatar placeholder circle
                Circle()
                    .fill(Color.white.opacity(0.3))
                    .frame(width: 44, height: 44)
                    .overlay(
                        Image(systemName: "person.circle.fill")
                            .font(.title2)
                            .foregroundStyle(.white)
                    )

                // Text content
                VStack(alignment: .leading, spacing: DesignTokens.Spacing.xs) {
                    Text("How was your day?")
                        .font(Typography.headline)
                        .fontWeight(.bold)
                        .foregroundStyle(.white)

                    Text("Tell me about it")
                        .font(Typography.subheadline)
                        .foregroundStyle(.white.opacity(0.8))
                }

                Spacer()

                // Chevron
                Image(systemName: "chevron.right")
                    .font(.body)
                    .foregroundStyle(.white.opacity(0.8))
            }
            .padding(DesignTokens.Layout.cardPadding)
            .background(Color.Wellness.tealCard)
            .cornerRadius(DesignTokens.Layout.cornerRadius)
        }
        .buttonStyle(.plain)
        .accessibilityLabel("Journal entry. How was your day? Tell me about it.")
        .accessibilityHint("Opens journal entry form")
        .sheet(isPresented: $isShowingNoteEntry) {
            NoteEntryView(isPresented: $isShowingNoteEntry)
        }
    }
}

// MARK: - Preview

#Preview {
    SelfNoteCard()
        .padding()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/StatusBadgeView.swift">
import SwiftUI

/// Pill-shaped status badge that displays stress category with dynamic color
struct StatusBadgeView: View {
    let category: StressCategory
    var style: BadgeStyle = .standard

    enum BadgeStyle {
        case standard
        case compact
        case large
    }

    var body: some View {
        HStack(spacing: 6) {
            Circle()
                .fill(Color.stressColor(for: category))
                .frame(width: indicatorSize, height: indicatorSize)

            Text(category.displayName.uppercased())
                .font(font)
                .fontWeight(.medium)
                .foregroundColor(Color.stressColor(for: category))
        }
        .padding(.horizontal, horizontalPadding)
        .padding(.vertical, verticalPadding)
        .background(Color.stressColor(for: category).opacity(0.15))
        .cornerRadius(cornerRadius)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Stress status: \(category.displayName)")
    }

    // MARK: - Style-based Properties

    private var indicatorSize: CGFloat {
        switch style {
        case .standard: return 8
        case .compact: return 6
        case .large: return 10
        }
    }

    private var font: Font {
        switch style {
        case .standard: return .caption
        case .compact: return .caption2
        case .large: return .subheadline
        }
    }

    private var horizontalPadding: CGFloat {
        switch style {
        case .standard: return 12
        case .compact: return 8
        case .large: return 16
        }
    }

    private var verticalPadding: CGFloat {
        switch style {
        case .standard: return 6
        case .compact: return 4
        case .large: return 8
        }
    }

    private var cornerRadius: CGFloat {
        switch style {
        case .standard: return 20
        case .compact: return 12
        case .large: return 24
        }
    }
}

#Preview("Status Badge Variations") {
    VStack(spacing: 16) {
        ForEach(StressCategory.allCases, id: \.self) { category in
            StatusBadgeView(category: category)
        }

        Divider()

        HStack(spacing: 12) {
            StatusBadgeView(category: .relaxed, style: .compact)
            StatusBadgeView(category: .mild, style: .standard)
            StatusBadgeView(category: .high, style: .large)
        }
    }
    .padding()
    .background(Color.oledBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/StressOverTimeChart.swift">
import SwiftUI

// MARK: - Chart Time Range Selector

/// Time range options for the stress chart
/// Note: Separate from TimeRange in HistoryViewModel to avoid conflicts
enum ChartTimeRange: String, CaseIterable {
    case sevenDays = "7 Days"
    case thirtyDays = "30 Days"
    case ninetyDays = "90 Days"
}

// MARK: - Stress Over Time Chart

/// Bar chart visualization for stress data over time
/// Shows daily stress levels with category-based coloring
struct StressOverTimeChart: View {
    @State private var selectedRange: ChartTimeRange = .sevenDays
    @AppStorage("isPremiumUser") private var isPremiumUser = false

    // Mock data for chart visualization
    private let chartData: [StressDataPoint] = [
        StressDataPoint(day: "D1", value: 35, category: .mild),
        StressDataPoint(day: "D2", value: 20, category: .relaxed),
        StressDataPoint(day: "D3", value: 55, category: .moderate),
        StressDataPoint(day: "D4", value: 30, category: .mild),
        StressDataPoint(day: "D5", value: 15, category: .relaxed),
        StressDataPoint(day: "D6", value: 45, category: .mild),
        StressDataPoint(day: "D7", value: 25, category: .relaxed),
    ]

    // Legend percentages (mock data)
    private let excellentPercent = 29
    private let normalPercent = 29
    private let stressedPercent = 29

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header with title and dropdown
            headerView

            if isPremiumUser {
                chartContent
            } else {
                chartContent
                    .overlay(PremiumLockOverlay())
            }
        }
        .padding(16)
        .frame(width: 358, height: 376)
        .background(Color.Wellness.adaptiveCardBackground)
        .cornerRadius(16)
        .accessibilityElement(children: .contain)
        .accessibilityLabel("Stress over time chart")
    }

    // MARK: - Header View

    private var headerView: some View {
        HStack {
            Text("Stress over time")
                .font(Typography.headline)
                .foregroundStyle(Color.Wellness.adaptivePrimaryText)

            Spacer()

            Menu {
                ForEach(ChartTimeRange.allCases, id: \.self) { range in
                    Button {
                        selectedRange = range
                    } label: {
                        HStack {
                            Text(range.rawValue)
                            if selectedRange == range {
                                Image(systemName: "checkmark")
                            }
                        }
                    }
                }
            } label: {
                HStack(spacing: 4) {
                    Text(selectedRange.rawValue)
                        .font(Typography.subheadline)
                    Image(systemName: "chevron.down")
                        .font(.system(size: 12))
                }
                .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
            }
        }
    }

    // MARK: - Chart Content

    private var chartContent: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Y-axis labels and chart area
            HStack(alignment: .top, spacing: 8) {
                // Y-axis labels
                yAxisLabels

                // Bar chart
                barChart
            }

            Spacer()

            // Legend
            legendView
                .padding(.top, 16)
        }
    }

    // MARK: - Y-Axis Labels

    private var yAxisLabels: some View {
        VStack(alignment: .trailing, spacing: 0) {
            ForEach([100, 66, 33, 0], id: \.self) { value in
                Text("\(value)")
                    .font(Typography.caption1)
                    .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
                    .frame(height: 60, alignment: .top)
            }
        }
        .frame(width: 24)
    }

    // MARK: - Bar Chart

    private var barChart: some View {
        HStack(alignment: .bottom, spacing: 12) {
            ForEach(chartData) { dataPoint in
                VStack(spacing: 4) {
                    // Bar
                    Rectangle()
                        .fill(barColor(for: dataPoint.category))
                        .frame(width: 28, height: barHeight(for: dataPoint.value))
                        .cornerRadius(6)

                    // X-axis label
                    Text(dataPoint.day)
                        .font(Typography.caption2)
                        .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
                }
                .frame(maxHeight: 240, alignment: .bottom)
            }
        }
        .frame(maxWidth: .infinity)
    }

    // MARK: - Legend View

    private var legendView: some View {
        HStack(spacing: 16) {
            legendItem(color: Color(hex: "#00C45A"), label: "Excellent", percent: excellentPercent)
            legendItem(color: Color(hex: "#F1AE00"), label: "Normal", percent: normalPercent)
            legendItem(color: Color(hex: "#FA363D"), label: "Stressed", percent: stressedPercent)
        }
    }

    private func legendItem(color: Color, label: String, percent: Int) -> some View {
        HStack(spacing: 6) {
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)

            Text("\(percent)% \(label)")
                .font(Typography.caption2)
                .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
        }
    }

    // MARK: - Helper Methods

    private func barHeight(for value: Int) -> CGFloat {
        // Max height is 240, scale proportionally
        return CGFloat(value) / 100.0 * 240.0
    }

    private func barColor(for category: StressCategory) -> Color {
        switch category {
        case .relaxed:
            return Color(hex: "#00C45A")
        case .mild:
            return Color(hex: "#F1AE00")
        case .moderate, .high:
            return Color(hex: "#FA363D")
        }
    }
}

// MARK: - Stress Data Point Model

struct StressDataPoint: Identifiable {
    let id = UUID()
    let day: String
    let value: Int
    let category: StressCategory
}

// MARK: - Preview

#Preview("Stress Over Time Chart") {
    VStack {
        StressOverTimeChart()
            .padding()

        Spacer()
    }
    .background(Color.Wellness.adaptiveBackground)
}

#Preview("Dark Mode") {
    VStack {
        StressOverTimeChart()
            .padding()

        Spacer()
    }
    .background(Color.Wellness.adaptiveBackground)
    .preferredColorScheme(.dark)
}

#Preview("Non-Premium User") {
    VStack {
        StressOverTimeChart()
            .padding()

        Spacer()
    }
    .background(Color.Wellness.adaptiveBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/StressStatusBadge.swift">
import SwiftUI

/// Status badge component for displaying stress status
struct StressStatusBadge: View {
    let status: String
    let color: Color

    init(status: String, color: Color = Color.Wellness.elevatedBadge) {
        self.status = status
        self.color = color
    }

    var body: some View {
        Text(status)
            .font(.system(size: 22, weight: .semibold))
            .foregroundColor(color)
            .accessibilityLabel("Stress status: \(status)")
    }
}

#Preview("StressStatusBadge") {
    VStack(spacing: 16) {
        StressStatusBadge(status: "Stressed")
        StressStatusBadge(status: "Relaxed", color: Color.Wellness.tealCard)
        StressStatusBadge(status: "Elevated", color: Color.Wellness.elevatedBadge)
    }
    .padding()
    .background(Color.Wellness.adaptiveBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/TripleMetricRow.swift">
import SwiftUI

/// Three-column metric row displaying RHR, HRV, and RR
struct TripleMetricRow: View {
    let rhrValue: String
    let hrvValue: String
    let rrValue: String

    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            MetricColumn(
                title: "RHR",
                value: rhrValue,
                unit: "bpm"
            )

            MetricColumn(
                title: "HRV",
                value: hrvValue,
                unit: "ms"
            )

            MetricColumn(
                title: "RR",
                value: rrValue,
                unit: "br/min"
            )
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Resting heart rate: \(rhrValue) bpm, Heart rate variability: \(hrvValue) ms, Respiratory rate: \(rrValue) breaths per minute")
    }
}

// MARK: - Metric Column

private struct MetricColumn: View {
    let title: String
    let value: String
    let unit: String

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title)
                .font(.system(size: 13, weight: .medium))
                .foregroundColor(Color.Wellness.adaptiveSecondaryText)

            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text(value)
                    .font(.system(size: 20, weight: .semibold))
                    .foregroundColor(Color.Wellness.adaptivePrimaryText)

                Text(unit)
                    .font(.system(size: 12, weight: .regular))
                    .foregroundColor(Color.Wellness.adaptiveSecondaryText)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

#Preview("TripleMetricRow") {
    VStack {
        TripleMetricRow(
            rhrValue: "62",
            hrvValue: "45",
            rrValue: "14"
        )
        Spacer()
    }
    .padding()
    .background(Color.Wellness.adaptiveBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/WeeklyInsightCard.swift">
import SwiftUI

/// Weekly average comparison card showing current week vs last week
struct WeeklyInsightCard: View {
    let currentWeekAvg: Double
    let lastWeekAvg: Double
    let startDate: Date
    let endDate: Date

    private var trend: TrendDirection {
        if currentWeekAvg < lastWeekAvg - 2 { return .improved }
        if currentWeekAvg > lastWeekAvg + 2 { return .increased }
        return .stable
    }

    private var trendColor: Color {
        switch trend {
        case .improved: return .stressRelaxed
        case .increased: return .stressHigh
        case .stable: return .stressMild
        }
    }

    private var trendIcon: String {
        switch trend {
        case .improved: return "arrow.down.right"
        case .increased: return "arrow.up.right"
        case .stable: return "arrow.right"
        }
    }

    private var trendText: String {
        switch trend {
        case .improved: return "Lower than last week"
        case .increased: return "Higher than last week"
        case .stable: return "Similar to last week"
        }
    }

    private var dateRangeText: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d"
        return "\(formatter.string(from: startDate)) - \(formatter.string(from: endDate))"
    }

    private var differenceText: String {
        let diff = abs(currentWeekAvg - lastWeekAvg)
        let sign = currentWeekAvg > lastWeekAvg ? "+" : "-"
        return "\(sign)\(Int(diff))"
    }

    var body: some View {
        HStack(spacing: 12) {
            // Calendar icon
            Image(systemName: "calendar")
                .font(.system(size: 16))
                .foregroundColor(Color.oledTextSecondary)
                .frame(width: 36, height: 36)
                .background(Color.oledCardSecondary)
                .cornerRadius(10)

            // Date range info
            VStack(alignment: .leading, spacing: 2) {
                Text("Weekly Average")
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.white)

                Text(dateRangeText)
                    .font(.caption)
                    .foregroundColor(Color.oledTextSecondary)
            }

            Spacer()

            // Trend indicator
            VStack(alignment: .trailing, spacing: 2) {
                HStack(spacing: 4) {
                    Image(systemName: trendIcon)
                        .font(.caption2)
                    Text(differenceText)
                        .font(.caption)
                        .fontWeight(.medium)
                }
                .foregroundColor(trendColor)

                Text(trendText)
                    .font(.caption2)
                    .foregroundColor(Color.oledTextSecondary)
            }
        }
        .padding(16)
        .background(Color.oledCardBackground)
        .cornerRadius(16)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Weekly average: \(Int(currentWeekAvg)), \(trendText)")
    }

    // MARK: - Trend Direction

    private enum TrendDirection {
        case improved
        case increased
        case stable
    }
}

// MARK: - Preview

#Preview("Weekly Insight Card") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()

        VStack(spacing: 16) {
            WeeklyInsightCard(
                currentWeekAvg: 32,
                lastWeekAvg: 38,
                startDate: Calendar.current.date(byAdding: .day, value: -7, to: Date())!,
                endDate: Date()
            )

            WeeklyInsightCard(
                currentWeekAvg: 45,
                lastWeekAvg: 38,
                startDate: Calendar.current.date(byAdding: .day, value: -7, to: Date())!,
                endDate: Date()
            )

            WeeklyInsightCard(
                currentWeekAvg: 38,
                lastWeekAvg: 37,
                startDate: Calendar.current.date(byAdding: .day, value: -7, to: Date())!,
                endDate: Date()
            )
        }
        .padding()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/DashboardViewModel.swift">
import Foundation
import Observation

@Observable
@MainActor
class DashboardViewModel {
    var currentStress: StressResult?
    var todayHRV: Double?
    var weeklyTrend: TrendDirection = .stable
    var baseline: PersonalBaseline?
    var aiInsight: AIInsight?
    var lastUpdated: Date?
    var isMeasuring = false
    var errorMessage: String?

    private let healthKit: HealthKitServiceProtocol
    private let algorithm: StressAlgorithmServiceProtocol
    private let repository: StressRepositoryProtocol

    init(
        healthKit: HealthKitServiceProtocol,
        algorithm: StressAlgorithmServiceProtocol,
        repository: StressRepositoryProtocol
    ) {
        self.healthKit = healthKit
        self.algorithm = algorithm
        self.repository = repository
    }

    func refreshStressLevel() async {
        guard !isMeasuring else { return }

        do {
            async let hrv = healthKit.fetchLatestHRV()
            async let hr = healthKit.fetchHeartRate(samples: 1)
            async let bl = repository.getBaseline()
            async let recentData = repository.fetchRecent(limit: 50)

            let (hrvData, hrData, baselineResult, weeklyData) = try await (hrv, hr, bl, recentData)

            guard let hrv = hrvData, let hr = hrData.first else {
                errorMessage = "No health data available"
                return
            }

            currentStress = try await algorithm.calculateStress(
                hrv: hrv.value,
                heartRate: hr.value
            )

            todayHRV = hrv.value
            baseline = baselineResult
            lastUpdated = Date()

            weeklyTrend = calculateTrend(from: weeklyData)
            aiInsight = generateInsight()

            let measurement = StressMeasurement(
                timestamp: Date(),
                stressLevel: currentStress!.level,
                hrv: hrv.value,
                restingHeartRate: hr.value,
                confidences: [currentStress!.confidence]
            )
            try await repository.save(measurement)

        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func measureNow() async {
        isMeasuring = true
        await refreshStressLevel()
        isMeasuring = false
    }

    var stressCategory: StressCategory {
        currentStress?.category ?? .mild
    }

    private func calculateTrend(from data: [StressMeasurement]) -> TrendDirection {
        guard data.count >= 2 else { return .stable }

        let hrvData = data.map { $0.hrv }
        let sampleCount = min(3, hrvData.count)
        let recent = hrvData.prefix(sampleCount).reduce(0, +) / Double(sampleCount)
        let older = hrvData.suffix(sampleCount).reduce(0, +) / Double(sampleCount)

        let diff = recent - older
        if diff > 5 { return .up }
        if diff < -5 { return .down }
        return .stable
    }

    private func generateInsight() -> AIInsight? {
        guard let stress = currentStress else { return nil }

        if stress.level > 75 {
            return AIInsight(
                title: "High Stress Detected",
                message: "Your stress is elevated. Consider a breathing exercise.",
                actionTitle: "Start Breathing",
                trendData: nil
            )
        } else if stress.level < 25 {
            return AIInsight(
                title: "Great Recovery",
                message: "Your HRV is excellent today. Keep up the good work!",
                actionTitle: nil,
                trendData: nil
            )
        } else {
            return AIInsight(
                title: "Stress is Normal",
                message: "Your stress level is within your typical range.",
                actionTitle: nil,
                trendData: nil
            )
        }
    }
}

enum TrendDirection {
    case up
    case down
    case stable
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/Badge.swift">
import SwiftUI

struct Badge: View {
    let text: String
    var color: Color = .primaryBlue
    var icon: String?

    var body: some View {
        HStack(spacing: 4) {
            if let icon = icon {
                Image(systemName: icon)
                    .font(Typography.caption1)
            }

            Text(text)
                .font(Typography.caption1)
                .fontWeight(.semibold)
        }
        .foregroundColor(color)
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(color.opacity(0.15))
        .cornerRadius(12)
    }
}

struct StressBadge: View {
    let level: Double

    var body: some View {
        let category = StressCategory(from: level)
        Badge(
            text: category.displayName,
            color: Color.stressColor(for: category),
            icon: Color.stressIcon(for: category)
        )
    }
}

extension StressCategory {
    init(from level: Double) {
        switch level {
        case 0...25: self = .relaxed
        case 26...50: self = .mild
        case 51...75: self = .moderate
        default: self = .high
        }
    }

    var displayName: String {
        switch self {
        case .relaxed: return "Relaxed"
        case .mild: return "Mild"
        case .moderate: return "Elevated"
        case .high: return "High"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/Buttons.swift">
import SwiftUI

struct PrimaryButton: View {
    let title: String
    let action: () -> Void
    var isLoading: Bool = false
    var isDisabled: Bool = false

    var body: some View {
        Button(action: action) {
            HStack {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                }
                Text(title)
            }
            .font(Typography.headline)
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .frame(height: 52)
            .background(isDisabled ? Color.gray : Color.primaryBlue)
            .cornerRadius(26)
        }
        .disabled(isDisabled || isLoading)
        .buttonStyle(ScaleButtonStyle())
    }
}

struct SecondaryButton: View {
    let title: String
    let action: () -> Void
    var isDestructive: Bool = false

    var body: some View {
        Button(action: action) {
            Text(title)
                .font(Typography.headline)
                .foregroundColor(isDestructive ? Color.error : Color.primaryBlue)
                .frame(maxWidth: .infinity)
                .frame(height: 52)
                .background(isDestructive ? Color.error.opacity(0.1) : Color.primaryBlue.opacity(0.1))
                .cornerRadius(26)
                .overlay(
                    RoundedRectangle(cornerRadius: 26)
                        .stroke(isDestructive ? Color.error : Color.primaryBlue, lineWidth: 1)
                )
        }
        .buttonStyle(ScaleButtonStyle())
    }
}

struct DestructiveButton: View {
    let title: String
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Text(title)
                .font(Typography.headline)
                .foregroundColor(.error)
        }
        .buttonStyle(ScaleButtonStyle())
    }
}

struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/EmptyStateView.swift">
import SwiftUI

struct EmptyStateView: View {
    let icon: String
    let title: String
    let message: String
    var actionTitle: String?
    var action: (() -> Void)?

    var body: some View {
        VStack(spacing: Spacing.lg) {
            Spacer()

            Image(systemName: icon)
                .font(.system(size: 64))
                .foregroundColor(.secondary)

            Text(title)
                .font(Typography.title2)
                .fontWeight(.bold)

            Text(message)
                .font(Typography.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, Spacing.xl)

            if let actionTitle = actionTitle, let action = action {
                Button(action: action) {
                    Text(actionTitle)
                        .font(Typography.headline)
                        .foregroundColor(.white)
                        .padding(.horizontal, Spacing.xl)
                        .padding(.vertical, Spacing.md)
                        .background(Color.primaryBlue)
                        .cornerRadius(12)
                }
            }

            Spacer()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

extension EmptyStateView {
    init(
        systemImage icon: String,
        title: String,
        message: String
    ) {
        self.icon = icon
        self.title = title
        self.message = message
        self.actionTitle = nil
        self.action = nil
    }

    static let noData = EmptyStateView(
        systemImage: "chart.bar",
        title: "No Measurements",
        message: "Take a measurement to see your data here"
    )

    static let noTrends = EmptyStateView(
        systemImage: "chart.xyaxis.slash",
        title: "Need More Data",
        message: "Continue measuring for 7 days to see trends"
    )
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/GlassCard.swift">
import SwiftUI

struct GlassCard<Content: View>: View {
    let content: Content
    var padding: CGFloat = Spacing.cardPadding
    var cornerRadius: CGFloat = 16

    init(padding: CGFloat = Spacing.cardPadding, cornerRadius: CGFloat = 16, @ViewBuilder content: () -> Content) {
        self.content = content()
        self.padding = padding
        self.cornerRadius = cornerRadius
    }

    var body: some View {
        content
            .padding(padding)
            .background(
                RoundedRectangle(cornerRadius: cornerRadius)
                    .fill(Color.secondary.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: cornerRadius)
                    .stroke(Color.white.opacity(0.1), lineWidth: 1)
            )
    }
}

struct DarkGlassCard<Content: View>: View {
    let content: Content

    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    var body: some View {
        content
            .padding(Spacing.cardPadding)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color.white.opacity(0.05))
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(Color.white.opacity(0.1), lineWidth: 1)
                    )
            )
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/LoadingView.swift">
import SwiftUI

struct LoadingView: View {
    var message: String?

    var body: some View {
        VStack(spacing: Spacing.md) {
            ProgressView()
                .scaleEffect(1.5)

            if let message = message {
                Text(message)
                    .font(Typography.body)
                    .foregroundColor(.secondary)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.backgroundLight)
    }
}

struct LoadingOverlay: View {
    var isLoading: Bool
    var message: String?

    var body: some View {
        if isLoading {
            ZStack {
                Color.black.opacity(0.3)
                    .ignoresSafeArea()

                VStack(spacing: Spacing.md) {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(1.5)

                    if let message = message {
                        Text(message)
                            .font(Typography.body)
                            .foregroundColor(.white)
                    }
                }
                .padding(Spacing.xl)
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(Color.black.opacity(0.8))
                )
            }
        }
    }
}

struct SkeletonRow: View {
    var body: some View {
        HStack(spacing: Spacing.md) {
            Circle()
                .fill(Color.secondary.opacity(0.2))
                .frame(width: 44, height: 44)

            VStack(alignment: .leading, spacing: Spacing.sm) {
                Rectangle()
                    .fill(Color.secondary.opacity(0.2))
                    .frame(height: 16)
                    .frame(maxWidth: 150)

                Rectangle()
                    .fill(Color.secondary.opacity(0.2))
                    .frame(height: 12)
                    .frame(maxWidth: 100)
            }

            Spacer()
        }
        .padding(Spacing.cellPadding)
        .shimmer()
    }
}

struct ShimmerModifier: ViewModifier {
    @State private var phase: CGFloat = 0

    func body(content: Content) -> some View {
        content
            .overlay(
                GeometryReader { geometry in
                    LinearGradient(
                        colors: [
                            Color.clear,
                            Color.white.opacity(0.3),
                            Color.clear
                        ],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: geometry.size.width)
                    .offset(x: phase * geometry.size.width * 2 - geometry.size.width)
                }
            )
            .onAppear {
                withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                    phase = 1
                }
            }
    }
}

extension View {
    func shimmer() -> some View {
        self.modifier(ShimmerModifier())
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/ProgressRing.swift">
import SwiftUI

struct ProgressRing: View {
    var progress: Double
    var color: Color = .primaryBlue
    var lineWidth: CGFloat = 8
    var size: CGFloat = 60

    @State private var animateProgress = false

    var body: some View {
        ZStack {
            Circle()
                .stroke(
                    Color.secondary.opacity(0.2),
                    style: StrokeStyle(lineWidth: lineWidth)
                )
                .frame(width: size, height: size)

            Circle()
                .trim(from: 0, to: animateProgress ? progress : 0)
                .stroke(
                    color,
                    style: StrokeStyle(lineWidth: lineWidth, lineCap: .round)
                )
                .frame(width: size, height: size)
                .rotationEffect(.degrees(-90))
                .animation(.easeInOut(duration: 0.6), value: animateProgress)
        }
        .onAppear {
            animateProgress = true
        }
    }
}

struct StressProgressRing: View {
    let stressLevel: Double

    var body: some View {
        ProgressRing(
            progress: stressLevel / 100,
            color: Color.stressColor(for: stressLevel),
            lineWidth: 12,
            size: 80
        )
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/SectionHeader.swift">
import SwiftUI

struct SectionHeader: View {
    let title: String
    var icon: String?
    var action: (() -> Void)?
    var actionText: String = "See All"

    var body: some View {
        HStack {
            if let icon = icon {
                Image(systemName: icon)
                    .foregroundColor(.primaryBlue)
            }

            Text(title)
                .font(Typography.title2)
                .fontWeight(.bold)

            Spacer()

            if let action = action {
                Button(action: action) {
                    Text(actionText)
                        .font(Typography.subheadline)
                        .foregroundColor(.primaryBlue)
                }
            }
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Components/StatCard.swift">
import SwiftUI

struct StatCard: View {
    let icon: String
    let value: String
    var unit: String?
    let label: String
    var tintColor: Color = .primaryBlue
    var action: (() -> Void)?

    var body: some View {
        VStack(spacing: Spacing.sm) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundColor(tintColor)
                .frame(width: 44, height: 44)
                .background(tintColor.opacity(0.15))
                .cornerRadius(12)

            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text(value)
                    .font(Typography.dataSmall)
                    .foregroundColor(.primary)

                if let unit = unit {
                    Text(unit)
                        .font(Typography.caption1)
                        .foregroundColor(.secondary)
                }
            }

            Text(label)
                .font(Typography.caption1)
                .foregroundColor(.secondary)
                .lineLimit(1)
        }
        .frame(maxWidth: .infinity)
        .padding(Spacing.cellPadding)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
        .contentShape(Rectangle())
        .modifier(ActionModifier(action: action))
    }
}

private struct ActionModifier: ViewModifier {
    let action: (() -> Void)?

    func body(content: Content) -> some View {
        if let action = action {
            content.onTapGesture(perform: action)
        } else {
            content
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Shadows.swift">
import SwiftUI

struct AppShadow {
    // MARK: - Shadow Presets

    static let card = ShadowDefinition(
        color: Color.black.opacity(0.05),
        radius: 8,
        x: 0,
        y: 2
    )

    static let elevated = ShadowDefinition(
        color: Color.black.opacity(0.1),
        radius: 16,
        x: 0,
        y: 4
    )

    static let button = ShadowDefinition(
        color: Color.black.opacity(0.15),
        radius: 4,
        x: 0,
        y: 2
    )

    static let subtle = ShadowDefinition(
        color: Color.black.opacity(0.03),
        radius: 4,
        x: 0,
        y: 1
    )
}

struct ShadowDefinition {
    let color: Color
    let radius: CGFloat
    let x: CGFloat
    let y: CGFloat
}

// MARK: - View Modifiers

extension View {
    func shadow(_ shadow: ShadowDefinition) -> some View {
        self.shadow(color: shadow.color, radius: shadow.radius, x: shadow.x, y: shadow.y)
    }

    func cardShadow() -> some View {
        self.shadow(AppShadow.card)
    }

    func elevatedShadow() -> some View {
        self.shadow(AppShadow.elevated)
    }

    func buttonShadow() -> some View {
        self.shadow(AppShadow.button)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Spacing.swift">
import SwiftUI

struct Spacing {
    // MARK: - 8pt Grid System

    static let xs: CGFloat = 4
    static let sm: CGFloat = 8
    static let md: CGFloat = 16
    static let lg: CGFloat = 24
    static let xl: CGFloat = 32
    static let xxl: CGFloat = 48
    static let xxxl: CGFloat = 64

    // MARK: - Component Specific

    static let cardPadding: CGFloat = 20
    static let cellPadding: CGFloat = 16
    static let listRowSpacing: CGFloat = 12
    static let sectionSpacing: CGFloat = 24
}
</file>

<file path="StressMonitor/StressMonitor/Views/DesignSystem/Typography.swift">
import SwiftUI

struct Typography {
    // MARK: - Large Titles

    static let largeTitle = Font.system(size: 34, weight: .bold)

    // MARK: - Titles

    static let title1 = Font.system(size: 28, weight: .bold)
    static let title2 = Font.system(size: 22, weight: .bold)
    static let title3 = Font.system(size: 20, weight: .semibold)

    // MARK: - Headline

    static let headline = Font.system(size: 17, weight: .semibold)

    // MARK: - Body

    static let body = Font.system(size: 17, weight: .regular)
    static let bodyEmphasized = Font.system(size: 17, weight: .semibold)

    // MARK: - Callout

    static let callout = Font.system(size: 16, weight: .regular)

    // MARK: - Subheadline

    static let subheadline = Font.system(size: 15, weight: .regular)

    // MARK: - Footnote

    static let footnote = Font.system(size: 13, weight: .regular)

    // MARK: - Captions

    static let caption1 = Font.system(size: 12, weight: .regular)
    static let caption2 = Font.system(size: 11, weight: .regular)

    // MARK: - Data Display (SF Pro Display Rounded)

    static let dataHero = Font.system(size: 72, weight: .bold, design: .rounded)
    static let dataLarge = Font.system(size: 48, weight: .bold, design: .rounded)
    static let dataMedium = Font.system(size: 34, weight: .semibold, design: .rounded)
    static let dataSmall = Font.system(size: 28, weight: .bold, design: .rounded)
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/Components/FactorProgressBar.swift">
import SwiftUI

struct FactorProgressBar: View {
    let factor: ContributingFactor

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(factor.name)
                    .font(Typography.subheadline)
                    .fontWeight(.medium)

                Spacer()

                Text(factor.label)
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)
            }

            HStack(spacing: 4) {
                ForEach(0..<10) { index in
                    let isFilled = Double(index) / 10.0 < factor.value
                    Circle()
                        .fill(isFilled ? colorForCategory(factor.category) : Color.secondary.opacity(0.2))
                        .frame(width: 12, height: 12)
                }
            }
        }
    }

    private func colorForCategory(_ category: FactorCategory) -> Color {
        switch category {
        case .low: return .stressHigh
        case .normal: return .stressMild
        case .fair: return .stressModerate
        case .high: return .stressRelaxed
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/Components/HistoryRowView.swift">
import SwiftUI

struct HistoryRowView: View {
    let measurement: StressMeasurement

    var body: some View {
        HStack(spacing: 16) {
            VStack(alignment: .leading, spacing: 2) {
                Text(formatTime(measurement.timestamp))
                    .font(.system(size: 17, weight: .semibold))
                    .foregroundColor(.primary)

                Text(formatDate(measurement.timestamp))
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)
            }
            .frame(width: 80, alignment: .leading)

            Spacer()

            VStack(alignment: .trailing, spacing: 2) {
                HStack(alignment: .firstTextBaseline, spacing: 4) {
                    Text("\(Int(measurement.stressLevel))")
                        .font(.system(size: 28, weight: .bold, design: .rounded))
                        .foregroundColor(colorForStress(measurement.stressLevel))

                    Text("/100")
                        .font(Typography.caption1)
                        .foregroundColor(.secondary)
                }

                Text("HRV: \(Int(measurement.hrv))ms")
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 12)
        .padding(.horizontal, 16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.secondary.opacity(0.05))
        )
    }

    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: date)
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d"
        return formatter.string(from: date)
    }

    private func colorForStress(_ level: Double) -> Color {
        switch level {
        case 0...25: return .stressRelaxed
        case 26...50: return .stressMild
        case 51...75: return .stressModerate
        default: return .stressHigh
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/Components/RecommendationCard.swift">
import SwiftUI

struct RecommendationCard: View {
    let recommendation: Recommendation

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: recommendation.icon)
                .font(.title2)
                .foregroundColor(.primaryBlue)
                .frame(width: 44, height: 44)
                .background(Color.primaryBlue.opacity(0.1))
                .cornerRadius(10)

            VStack(alignment: .leading, spacing: 4) {
                Text(recommendation.title)
                    .font(Typography.subheadline)
                    .fontWeight(.semibold)

                Text(recommendation.description)
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)
            }

            Spacer()

            if recommendation.action != .none {
                Image(systemName: "chevron.right")
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)
            }
        }
        .padding(12)
        .background(Color.secondary.opacity(0.05))
        .cornerRadius(12)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/Components/StressGaugeView.swift">
import SwiftUI

struct StressGaugeView: View {
    let level: Double
    let category: StressCategory

    var body: some View {
        ZStack {
            Path { path in
                path.addArc(
                    center: CGPoint(x: 100, y: 100),
                    radius: 80,
                    startAngle: .degrees(150),
                    endAngle: .degrees(30),
                    clockwise: false
                )
            }
            .stroke(Color.secondary.opacity(0.2), lineWidth: 20)

            ZStack {
                Path { path in
                    path.addArc(
                        center: CGPoint(x: 100, y: 100),
                        radius: 80,
                        startAngle: .degrees(150),
                        endAngle: .degrees(180),
                        clockwise: false
                    )
                }
                .stroke(Color.stressRelaxed, style: StrokeStyle(lineWidth: 20, lineCap: .butt))

                Path { path in
                    path.addArc(
                        center: CGPoint(x: 100, y: 100),
                        radius: 80,
                        startAngle: .degrees(180),
                        endAngle: .degrees(210),
                        clockwise: false
                    )
                }
                .stroke(Color.stressMild, style: StrokeStyle(lineWidth: 20, lineCap: .butt))

                Path { path in
                    path.addArc(
                        center: CGPoint(x: 100, y: 100),
                        radius: 80,
                        startAngle: .degrees(210),
                        endAngle: .degrees(240),
                        clockwise: false
                    )
                }
                .stroke(Color.stressModerate, style: StrokeStyle(lineWidth: 20, lineCap: .butt))

                Path { path in
                    path.addArc(
                        center: CGPoint(x: 100, y: 100),
                        radius: 80,
                        startAngle: .degrees(240),
                        endAngle: .degrees(30),
                        clockwise: false
                    )
                }
                .stroke(Color.stressHigh, style: StrokeStyle(lineWidth: 20, lineCap: .butt))
            }

            let angle = needleAngle(for: level)
            Path { path in
                path.move(to: CGPoint(x: 100, y: 100))
                path.addLine(to: CGPoint(
                    x: 100 + cos(angle) * 60,
                    y: 100 + sin(angle) * 60
                ))
            }
            .stroke(Color.primary, style: StrokeStyle(lineWidth: 3, lineCap: .round))
            .shadow(color: .black.opacity(0.2), radius: 2)

            Circle()
                .fill(Color.primary)
                .frame(width: 12, height: 12)

            VStack {
                Spacer()
                Text("\(Int(level))")
                    .font(.system(size: 48, weight: .bold, design: .rounded))
                Text("out of 100")
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)
            }
            .offset(y: 140)
        }
        .frame(width: 200, height: 200)
    }

    private func needleAngle(for value: Double) -> Double {
        let normalized = value / 100.0
        let startAngle = 150.0
        let endAngle = 30.0
        let degrees = startAngle + (endAngle - startAngle) * normalized
        return degrees * .pi / 180
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/DetailViewModel.swift">
import SwiftUI
import SwiftData

@Observable
class DetailViewModel {
    let measurement: StressMeasurement
    var baseline: PersonalBaseline?
    var todayAverage: Double?
    var weeklyAverage: Double?
    var trend: TrendDirection?
    var percentile: Double?
    var contributingFactors: [ContributingFactor] = []
    var recommendations: [Recommendation] = []

    private let repository: StressRepositoryProtocol

    init(measurement: StressMeasurement, modelContext: ModelContext, baselineCalculator: BaselineCalculator? = nil) {
        self.measurement = measurement
        self.repository = StressRepository(modelContext: modelContext, baselineCalculator: baselineCalculator)
    }

    func loadData() async {
        do {
            async let bl = repository.getBaseline()
            async let today = repository.fetchAverageHRV(hours: 24)
            async let week = repository.fetchAverageHRV(days: 7)

            baseline = try await bl
            todayAverage = try await today
            weeklyAverage = try await week

            trend = calculateTrend()
            percentile = calculatePercentile()

            contributingFactors = generateContributingFactors()
            recommendations = generateRecommendations()
        } catch {}
    }

    var category: StressCategory {
        switch measurement.stressLevel {
        case 0...25: return .relaxed
        case 26...50: return .mild
        case 51...75: return .moderate
        default: return .high
        }
    }

    func shareMeasurement() {
        let text = """
        Stress Measurement - \(formatDate(measurement.timestamp))

        Stress Level: \(Int(measurement.stressLevel))/100
        HRV: \(Int(measurement.hrv)) ms
        Category: \(categoryTitle(category))
        """

        let activityVC = UIActivityViewController(
            activityItems: [text],
            applicationActivities: nil
        )

        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(activityVC, animated: true)
        }
    }

    private func calculateTrend() -> TrendDirection {
        guard let today = todayAverage else { return .stable }
        let diff = measurement.hrv - today
        if diff > 5 { return .up }
        if diff < -5 { return .down }
        return .stable
    }

    private func calculatePercentile() -> Double {
        guard let baseline = baseline else { return 50 }
        let lowerBound = baseline.baselineHRV - 10
        let upperBound = baseline.baselineHRV + 10
        let normalized = (measurement.hrv - lowerBound) / (upperBound - lowerBound)
        return max(0, min(100, normalized * 100))
    }

    private func generateContributingFactors() -> [ContributingFactor] {
        return [
            ContributingFactor(
                name: "HRV Deviation",
                value: calculateHRVDeviation(),
                category: .high,
                label: "Higher than avg = Good"
            ),
            ContributingFactor(
                name: "Resting HR",
                value: 0.45,
                category: .normal,
                label: "Normal"
            ),
            ContributingFactor(
                name: "Sleep Quality",
                value: 0.60,
                category: .fair,
                label: "(7h 23m)"
            ),
            ContributingFactor(
                name: "Recent Activity",
                value: 0.30,
                category: .low,
                label: "(45 min workout)"
            )
        ]
    }

    private func calculateHRVDeviation() -> Double {
        guard let baseline = baseline else { return 0.5 }
        let lowerBound = baseline.baselineHRV - 10
        let upperBound = baseline.baselineHRV + 10
        let normalized = (measurement.hrv - lowerBound) / (upperBound - lowerBound)
        return max(0, min(1, normalized))
    }

    private func generateRecommendations() -> [Recommendation] {
        switch category {
        case .high:
            return [
                Recommendation(
                    title: "Breathing Exercise",
                    description: "Take a 5-minute resonance breathing break",
                    icon: "wind",
                    action: .breathing
                ),
                Recommendation(
                    title: "Hydration",
                    description: "Drink a glass of water to support recovery",
                    icon: "drop",
                    action: .hydration
                )
            ]
        case .moderate:
            return [
                Recommendation(
                    title: "Short Walk",
                    description: "A 10-minute walk can help reduce stress",
                    icon: "figure.walk",
                    action: .walk
                )
            ]
        default:
            return [
                Recommendation(
                    title: "Keep it up!",
                    description: "Your stress is well-managed today",
                    icon: "checkmark.circle.fill",
                    action: .none
                )
            ]
        }
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, YYYY"
        return formatter.string(from: date)
    }
}

struct ContributingFactor {
    let name: String
    let value: Double
    let category: FactorCategory
    let label: String
}

enum FactorCategory {
    case low, normal, fair, high
}

struct Recommendation {
    let title: String
    let description: String
    let icon: String
    let action: RecommendationAction
}

enum RecommendationAction {
    case breathing
    case hydration
    case walk
    case none
}

func categoryTitle(_ category: StressCategory) -> String {
    switch category {
    case .relaxed: return "Relaxed"
    case .mild: return "Mild"
    case .moderate: return "Elevated"
    case .high: return "High"
    }
}

func iconForCategory(_ category: StressCategory) -> String {
    Color.stressIcon(for: category)
}

func colorForCategory(_ category: StressCategory) -> Color {
    Color.stressColor(for: category)
}

func trendIcon(_ trend: TrendDirection) -> String {
    switch trend {
    case .up: return "arrow.up"
    case .down: return "arrow.down"
    case .stable: return "minus"
    }
}

func trendColor(_ trend: TrendDirection) -> Color {
    switch trend {
    case .up: return .stressRelaxed
    case .down: return .stressHigh
    case .stable: return .secondary
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/HistoryViewModel.swift">
import SwiftUI
import SwiftData

@Observable
class HistoryViewModel {
    var measurements: [StressMeasurement] = []
    var selectedTimeRange: TimeRange = .sevenDays
    var isLoading = false
    var errorMessage: String?

    private let repository: StressRepositoryProtocol

    init(modelContext: ModelContext, baselineCalculator: BaselineCalculator? = nil) {
        self.repository = StressRepository(modelContext: modelContext, baselineCalculator: baselineCalculator)
    }

    func fetchMeasurements() async {
        isLoading = true
        defer { isLoading = false }

        do {
            let calendar = Calendar.current
            let now = Date()
            var startDate: Date

            switch selectedTimeRange {
            case .twentyFourHours:
                startDate = calendar.date(byAdding: .hour, value: -24, to: now) ?? now
            case .sevenDays:
                startDate = calendar.date(byAdding: .day, value: -7, to: now) ?? now
            case .fourWeeks:
                startDate = calendar.date(byAdding: .weekOfYear, value: -4, to: now) ?? now
            case .threeMonths:
                startDate = calendar.date(byAdding: .month, value: -3, to: now) ?? now
            }

            measurements = try await repository.fetchMeasurements(from: startDate, to: now)
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func deleteMeasurement(_ measurement: StressMeasurement) async {
        do {
            try await repository.delete(measurement)
            measurements.removeAll { $0.id == measurement.id }
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    var groupedMeasurements: [String: [StressMeasurement]] {
        Dictionary(grouping: measurements) { measurement in
            formatDateGroup(measurement.timestamp)
        }
    }

    private func formatDateGroup(_ date: Date) -> String {
        let calendar = Calendar.current

        if calendar.isDateInToday(date) {
            return "TODAY"
        } else if calendar.isDateInYesterday(date) {
            return "YESTERDAY"
        } else {
            let daysSince = calendar.dateComponents([.day], from: date, to: Date()).day ?? 0
            if daysSince <= 7 {
                return "PREVIOUS 7 DAYS"
            } else {
                let formatter = DateFormatter()
                formatter.dateFormat = "MMM d, YYYY"
                return formatter.string(from: date).uppercased()
            }
        }
    }
}

enum TimeRange: String, CaseIterable {
    case twentyFourHours = "24H"
    case sevenDays = "7D"
    case fourWeeks = "4W"
    case threeMonths = "3M"
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/MeasurementDetailView.swift">
import SwiftUI
import SwiftData

struct MeasurementDetailView: View {
    let measurement: StressMeasurement
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: DetailViewModel?
    @Environment(\.dismiss) private var dismiss

    init(measurement: StressMeasurement) {
        self.measurement = measurement
    }

    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                stressLevelCard
                    .padding(.horizontal)

                hrvMeasurementsCard
                    .padding(.horizontal)

                contributingFactorsCard
                    .padding(.horizontal)

                if let viewModel = viewModel, !viewModel.recommendations.isEmpty {
                    recommendationsCard
                        .padding(.horizontal)
                }
            }
            .padding(.vertical, 20)
        }
        .background(Color.backgroundLight)
        .navigationBarHidden(true)
        .overlay(navigationBar)
        .task {
            viewModel = DetailViewModel(measurement: measurement, modelContext: modelContext)
            await viewModel?.loadData()
        }
    }

    private var navigationBar: some View {
        HStack {
            Button(action: { dismiss() }) {
                Image(systemName: "chevron.left")
                    .font(.title3)
                    .foregroundColor(.primary)
            }

            Spacer()

            Text(formatDate(measurement.timestamp))
                .font(Typography.headline)

            Spacer()

            Button(action: { viewModel?.shareMeasurement() }) {
                Image(systemName: "square.and.arrow.up")
                    .font(.title3)
                    .foregroundColor(.primaryBlue)
            }
        }
        .padding(.horizontal)
        .padding(.top, 16)
    }

    private var stressLevelCard: some View {
        VStack(spacing: 16) {
            HStack(spacing: 8) {
                Image(systemName: iconForCategory(category))
                    .font(.title3)

                Text(categoryTitle(category))
                    .font(Typography.headline)
            }
            .foregroundColor(colorForCategory(category))
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(colorForCategory(category).opacity(0.15))
            .cornerRadius(20)

            StressGaugeView(
                level: measurement.stressLevel,
                category: category
            )

            if let confidences = measurement.confidences, !confidences.isEmpty {
                let avgConfidence = confidences.reduce(0, +) / Double(confidences.count)
                HStack {
                    Label("\(Int(avgConfidence * 100))% Confidence", systemImage: "checkmark.circle.fill")
                        .font(Typography.caption1)
                        .foregroundColor(.secondary)

                    Spacer()

                    Text(formatTime(measurement.timestamp))
                        .font(Typography.caption1)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }

    private var hrvMeasurementsCard: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("HRV Measurements")
                .font(Typography.headline)

            VStack(spacing: 12) {
                HRVRow(
                    label: "Current HRV",
                    value: "\(Int(measurement.hrv)) ms",
                    icon: "heart.fill",
                    color: .red
                )

                Divider()

                HRVRow(
                    label: "Today's Average",
                    value: todayAvgText,
                    icon: "calendar",
                    color: .primaryBlue
                )

                Divider()

                HRVRow(
                    label: "Weekly Average",
                    value: weeklyAvgText,
                    icon: "chart.bar",
                    color: .stressRelaxed
                )

                Divider()

                HRVRow(
                    label: "Baseline Range",
                    value: baselineRangeText,
                    icon: "scale.3d",
                    color: .stressModerate
                )

                if let trend = viewModel?.trend {
                    Divider()

                    HStack {
                        Image(systemName: trendIcon(trend))
                            .foregroundColor(trendColor(trend))

                        Text(trendText(trend))
                            .font(Typography.body)

                        Spacer()

                        Text("\(Int(viewModel?.percentile ?? 0))th percentile")
                            .font(Typography.caption1)
                            .foregroundColor(.secondary)
                    }
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }

    private var contributingFactorsCard: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Contributing Factors")
                .font(Typography.headline)

            VStack(spacing: 16) {
                ForEach(viewModel?.contributingFactors ?? [], id: \.name) { factor in
                    FactorProgressBar(factor: factor)
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }

    private var recommendationsCard: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Recommendations")
                .font(Typography.headline)

            VStack(spacing: 12) {
                ForEach(viewModel?.recommendations ?? [], id: \.title) { rec in
                    RecommendationCard(recommendation: rec)
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }

    private var category: StressCategory {
        switch measurement.stressLevel {
        case 0...25: return .relaxed
        case 26...50: return .mild
        case 51...75: return .moderate
        default: return .high
        }
    }

    private var todayAvgText: String {
        guard let viewModel = viewModel, let avg = viewModel.todayAverage else { return "--" }
        return "\(Int(avg)) ms"
    }

    private var weeklyAvgText: String {
        guard let viewModel = viewModel, let avg = viewModel.weeklyAverage else { return "--" }
        return "\(Int(avg)) ms"
    }

    private var baselineRangeText: String {
        guard let viewModel = viewModel, let baseline = viewModel.baseline else { return "--" }
        let lowerBound = baseline.baselineHRV - 10
        let upperBound = baseline.baselineHRV + 10
        return "\(Int(lowerBound))-\(Int(upperBound)) ms"
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, YYYY"
        return formatter.string(from: date)
    }

    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: date)
    }
}

struct HRVRow: View {
    let label: String
    let value: String
    let icon: String
    let color: Color

    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(color)
                .frame(width: 32)

            Text(label)
                .font(Typography.subheadline)
                .foregroundColor(.secondary)

            Spacer()

            Text(value)
                .font(Typography.body)
                .fontWeight(.medium)
        }
    }
}

func trendText(_ trend: TrendDirection) -> String {
    switch trend {
    case .up: return "Above average"
    case .down: return "Below average"
    case .stable: return "Stable"
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/History/MeasurementHistoryView.swift">
import SwiftUI
import SwiftData

struct MeasurementHistoryView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: HistoryViewModel

    init() {
        _viewModel = State(initialValue: HistoryViewModel(
            modelContext: ModelContext(try! ModelContainer(for: StressMeasurement.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true)))
        ))
    }

    var body: some View {
        VStack(spacing: 0) {
            header
            timeRangeSelector

            Group {
                if viewModel.isLoading {
                    loadingView
                } else if viewModel.groupedMeasurements.isEmpty {
                    emptyState
                } else {
                    measurementsList
                }
            }
        }
        .background(Color.backgroundLight)
        .task {
            await viewModel.fetchMeasurements()
        }
        .onAppear {
            viewModel = HistoryViewModel(modelContext: modelContext)
        }
    }

    private var header: some View {
        HStack {
            Text("History")
                .font(Typography.largeTitle)

            Spacer()

            Button(action: {}) {
                Image(systemName: "line.3.horizontal.decrease.circle")
                    .font(.title2)
                    .foregroundColor(.primaryBlue)
            }
        }
        .padding(.horizontal)
        .padding(.top, 16)
    }

    private var timeRangeSelector: some View {
        Picker("", selection: $viewModel.selectedTimeRange) {
            Text("24H").tag(TimeRange.twentyFourHours)
            Text("7D").tag(TimeRange.sevenDays)
            Text("4W").tag(TimeRange.fourWeeks)
            Text("3M").tag(TimeRange.threeMonths)
        }
        .pickerStyle(.segmented)
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .onChange(of: viewModel.selectedTimeRange) { _, _ in
            Task { await viewModel.fetchMeasurements() }
        }
    }

    private var measurementsList: some View {
        ScrollView {
            LazyVStack(spacing: 20, pinnedViews: [.sectionHeaders]) {
                ForEach(Array(viewModel.groupedMeasurements.keys.sorted(by: >)), id: \.self) { groupKey in
                    Section {
                        ForEach(viewModel.groupedMeasurements[groupKey] ?? []) { measurement in
                            NavigationLink {
                                MeasurementDetailView(measurement: measurement)
                            } label: {
                                HistoryRowView(measurement: measurement)
                            }
                            .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                                Button(role: .destructive) {
                                    Task {
                                        await viewModel.deleteMeasurement(measurement)
                                    }
                                } label: {
                                    Label("Delete", systemImage: "trash")
                                }
                            }
                        }
                    } header: {
                        Text(groupKey)
                            .font(Typography.caption1)
                            .fontWeight(.semibold)
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.horizontal, 16)
                            .background(Color.backgroundLight)
                    }
                }
            }
            .padding(.bottom, 100)
        }
    }

    private var loadingView: some View {
        VStack(spacing: 16) {
            ProgressView()
                .scaleEffect(1.5)

            Text("Loading measurements...")
                .font(Typography.body)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    private var emptyState: some View {
        VStack(spacing: 16) {
            Image(systemName: "chart.bar")
                .font(.system(size: 64))
                .foregroundColor(.secondary)

            Text("No Measurements")
                .font(Typography.title2)

            Text("Take a measurement to see your history")
                .font(Typography.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)

            Button(action: {}) {
                Text("Measure Now")
                    .font(Typography.headline)
                    .foregroundColor(.white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .background(Color.primaryBlue)
                    .cornerRadius(12)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Journal/NoteEntryView.swift">
import SwiftUI

// MARK: - Note Entry View

/// Simple journal entry form for daily reflections
struct NoteEntryView: View {
    @Binding var isPresented: Bool
    @State private var noteText: String = ""
    @FocusState private var isTextEditorFocused: Bool

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: DesignTokens.Spacing.lg) {
                    // Header
                    VStack(alignment: .leading, spacing: DesignTokens.Spacing.sm) {
                        Text("Daily Reflection")
                            .font(Typography.title2)
                            .fontWeight(.bold)

                        Text(Date(), style: .date)
                            .font(Typography.callout)
                            .foregroundStyle(.secondary)
                    }
                    .padding(.top, DesignTokens.Spacing.sm)

                    // Text Editor
                    TextEditor(text: $noteText)
                        .focused($isTextEditorFocused)
                        .font(Typography.body)
                        .frame(minHeight: 200)
                        .padding(DesignTokens.Spacing.sm)
                        .background(Color.Wellness.surface)
                        .cornerRadius(DesignTokens.Layout.cornerRadius)
                        .overlay(
                            RoundedRectangle(cornerRadius: DesignTokens.Layout.cornerRadius)
                                .stroke(Color.primary.opacity(0.1), lineWidth: 1)
                        )
                        .overlay(alignment: .topLeading) {
                            if noteText.isEmpty {
                                Text("How are you feeling today?")
                                    .font(Typography.body)
                                    .foregroundStyle(.secondary.opacity(0.5))
                                    .padding(DesignTokens.Spacing.md)
                                    .allowsHitTesting(false)
                            }
                        }

                    Spacer()
                }
                .padding(DesignTokens.Spacing.md)
            }
            .background(Color.Wellness.background)
            .navigationTitle("Journal")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button("Cancel") {
                        HapticManager.shared.buttonPress()
                        isPresented = false
                    }
                    .accessibilityLabel("Cancel journal entry")
                }

                ToolbarItem(placement: .topBarTrailing) {
                    Button("Save") {
                        HapticManager.shared.success()
                        // TODO: Implement persistence
                        isPresented = false
                    }
                    .fontWeight(.semibold)
                    .disabled(noteText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                    .accessibilityLabel("Save journal entry")
                }
            }
            .onAppear {
                // Auto-focus text editor after a brief delay
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    isTextEditorFocused = true
                }
            }
        }
    }
}

// MARK: - Preview

#Preview {
    NoteEntryView(isPresented: .constant(true))
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/HealthKitErrorView.swift">
import SwiftUI

struct HealthKitErrorView: View {
    @State private var viewModel = HealthKitErrorViewModel()

    var body: some View {
        VStack(spacing: 32) {
            Spacer()

            // Error icon
            ZStack {
                Circle()
                    .fill(Color.stressHigh.opacity(0.1))
                    .frame(width: 120, height: 120)

                Image(systemName: "lock.fill")
                    .font(.system(size: 48))
                    .foregroundColor(.stressHigh)
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Access denied icon")

            // Headline
            Text("Health Access Required")
                .font(.system(size: 28, weight: .bold))
                .accessibilityAddTraits(.isHeader)

            // Explanation
            Text("Please grant health permissions in Settings to continue using StressMonitor")
                .font(.system(size: 17))
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 32)

            Spacer()

            // Actions
            VStack(spacing: 12) {
                Button(action: { viewModel.openSettings() }) {
                    Text("Open Settings")
                        .font(.system(size: 17, weight: .semibold))
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 48)
                        .background(Color.primaryBlue)
                        .cornerRadius(12)
                }
                .accessibilityHint("Opens iOS Settings app")

                Button(action: { viewModel.dismissToWelcome() }) {
                    Text("Cancel")
                        .font(.system(size: 15))
                        .foregroundColor(.secondary)
                }
                .accessibilityHint("Returns to welcome screen")
            }
        }
        .padding(24)
    }
}

#Preview {
    HealthKitErrorView()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/HealthKitErrorViewModel.swift">
import Foundation
import UIKit

@MainActor
@Observable
final class HealthKitErrorViewModel {
    func openSettings() {
        if let url = URL(string: UIApplication.openSettingsURLString) {
            UIApplication.shared.open(url)
        }
    }

    func dismissToWelcome() {
        // Navigate back to welcome screen
        // This would be handled by parent navigation
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingBaselineCalibrationView.swift">
import SwiftData
import SwiftUI

struct OnboardingBaselineCalibrationView: View {
    @State private var viewModel: OnboardingBaselineCalibrationViewModel

    init(repository: StressRepositoryProtocol) {
        _viewModel = State(initialValue: OnboardingBaselineCalibrationViewModel(repository: repository))
    }

    var body: some View {
        VStack(spacing: 24) {
            // Step indicator
            HStack {
                Text("Step 3 of 4")
                    .font(.system(size: 12))
                    .foregroundColor(.secondary)
                Spacer()
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Step 3 of 4")

            // Progress ring
            ZStack {
                Circle()
                    .stroke(Color.secondary.opacity(0.2), lineWidth: 8)
                    .frame(width: 200, height: 200)

                Circle()
                    .trim(from: 0, to: Double(viewModel.currentDay) / 7.0)
                    .stroke(
                        colorForPhase(viewModel.currentPhase),
                        style: StrokeStyle(lineWidth: 8, lineCap: .round)
                    )
                    .frame(width: 200, height: 200)
                    .rotationEffect(.degrees(-90))
                    .animation(.easeInOut(duration: 0.5), value: viewModel.currentDay)

                VStack(spacing: 4) {
                    Text("Day \(viewModel.currentDay)")
                        .font(.system(size: 48, weight: .bold, design: .rounded))

                    Text("of 7")
                        .font(.system(size: 17))
                        .foregroundColor(.secondary)
                }
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Day \(viewModel.currentDay) of 7 calibration progress")

            // Phase information
            VStack(spacing: 16) {
                Text(phaseTitle(viewModel.currentPhase))
                    .font(.system(size: 22, weight: .semibold))
                    .accessibilityAddTraits(.isHeader)

                Text(phaseDescription(viewModel.currentPhase))
                    .font(.system(size: 17))
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
            }

            // Daily check-in card
            if viewModel.dailyMeasurementTaken {
                HStack(spacing: 12) {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.stressRelaxed)
                        .font(.system(size: 24))

                    Text("Today's measurement complete")
                        .font(.system(size: 17, weight: .semibold))
                }
                .padding(16)
                .background(Color.stressRelaxed.opacity(0.1))
                .cornerRadius(12)
                .accessibilityElement(children: .ignore)
                .accessibilityLabel("Today's measurement is complete")
            } else if viewModel.currentDay <= 7 {
                Button(action: { Task { await viewModel.recordDailyMeasurement() } }) {
                    HStack {
                        Image(systemName: "plus.circle.fill")
                        Text("Take Today's Measurement")
                    }
                    .font(.system(size: 17, weight: .semibold))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 48)
                    .background(Color.primaryBlue)
                    .cornerRadius(12)
                }
                .disabled(viewModel.dailyMeasurementTaken)
                .accessibilityHint("Records daily health measurement for baseline")
            }

            Spacer()

            // Continue button (enabled after all 7 days)
            if viewModel.calibrationCompleted {
                Button(action: { viewModel.completeCalibration() }) {
                    Text("Continue")
                        .font(.system(size: 17, weight: .semibold))
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 48)
                        .background(Color.primaryBlue)
                        .cornerRadius(12)
                }
                .accessibilityHint("Proceeds to completion screen")
            }
        }
        .padding(24)
    }

    private func phaseTitle(_ phase: CalibrationPhase) -> String {
        switch phase {
        case .learning: return "Learning Phase"
        case .calibration: return "Calibration Phase"
        case .validation: return "Validation Phase"
        case .complete: return "Calibration Complete"
        }
    }

    private func phaseDescription(_ phase: CalibrationPhase) -> String {
        switch phase {
        case .learning:
            return "We're collecting HRV data to understand your normal patterns (Days 1-3)"
        case .calibration:
            return "Algorithm is fine-tuning to your personal patterns (Days 4-5)"
        case .validation:
            return "Baseline is being validated and finalized (Days 6-7)"
        case .complete:
            return "Your personal stress baseline is now established"
        }
    }

    private func colorForPhase(_ phase: CalibrationPhase) -> Color {
        switch phase {
        case .learning: return .stressRelaxed
        case .calibration: return .primaryBlue
        case .validation: return .stressModerate
        case .complete: return .stressRelaxed
        }
    }
}

#Preview {
    let repository = StressRepository(
        modelContext: ModelContext(try! ModelContainer(for: StressMeasurement.self)),
        baselineCalculator: BaselineCalculator()
    )
    OnboardingBaselineCalibrationView(repository: repository)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingBaselineCalibrationViewModel.swift">
import Foundation

@MainActor
@Observable
final class OnboardingBaselineCalibrationViewModel {
    var currentDay: Int = 1
    var calibrationCompleted: Bool = false
    var dailyMeasurementTaken: Bool = false

    private let repository: StressRepositoryProtocol

    init(repository: StressRepositoryProtocol) {
        self.repository = repository
        loadCalibrationState()
    }

    func startCalibration() {
        currentDay = 1
        dailyMeasurementTaken = false
        saveCalibrationState()
    }

    func recordDailyMeasurement() async {
        // Capture HRV/HR reading for baseline
        // This would trigger the measurement flow
        dailyMeasurementTaken = true
        saveCalibrationState()

        // Auto-advance to next day after measurement
        if currentDay < 7 {
            currentDay += 1
            dailyMeasurementTaken = false
        } else {
            calibrationCompleted = true
        }
        saveCalibrationState()
    }

    var currentPhase: CalibrationPhase {
        switch currentDay {
        case 1...3: return .learning
        case 4...5: return .calibration
        case 6...7: return .validation
        default: return .complete
        }
    }

    func completeCalibration() {
        // Mark baseline as ready
        UserDefaults.standard.set(true, forKey: "baselineCalibrated")
    }

    private func saveCalibrationState() {
        UserDefaults.standard.set(currentDay, forKey: "calibrationDay")
        UserDefaults.standard.set(calibrationCompleted, forKey: "calibrationCompleted")
    }

    private func loadCalibrationState() {
        currentDay = UserDefaults.standard.integer(forKey: "calibrationDay")
        calibrationCompleted = UserDefaults.standard.bool(forKey: "calibrationCompleted")
        if currentDay == 0 { currentDay = 1 }
    }
}

enum CalibrationPhase {
    case learning
    case calibration
    case validation
    case complete
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingHealthSyncView.swift">
import SwiftUI

struct OnboardingHealthSyncView: View {
    @State private var viewModel = OnboardingHealthSyncViewModel()

    var body: some View {
        VStack(spacing: 24) {
            // Step indicator
            HStack {
                Text("Step 2 of 4")
                    .font(.system(size: 12))
                    .foregroundColor(.secondary)
                Spacer()
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Step 2 of 4")

            // Hero icon
            ZStack {
                Circle()
                    .fill(Color.primaryBlue.opacity(0.1))
                    .frame(width: 120, height: 120)

                Image(systemName: "heart.text.square.fill")
                    .font(.system(size: 56))
                    .foregroundColor(.primaryBlue)
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Health data access icon")

            // Title and description
            VStack(spacing: 8) {
                Text("Health Data Access")
                    .font(.system(size: 28, weight: .bold))
                    .accessibilityAddTraits(.isHeader)

                Text("We need access to your health data to calculate stress levels")
                    .font(.system(size: 17))
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
            }

            // Data type cards
            VStack(spacing: 12) {
                DataTypeCard(
                    icon: "heart.fill",
                    color: .red,
                    title: "Heart Rate",
                    description: "Resting and active measurements"
                )
                DataTypeCard(
                    icon: "waveform.path",
                    color: .purple,
                    title: "Heart Rate Variability",
                    description: "Primary stress indicator"
                )
                DataTypeCard(
                    icon: "bed.double.fill",
                    color: .blue,
                    title: "Sleep Analysis",
                    description: "Recovery quality tracking"
                )
            }
            .accessibilityElement(children: .contain)
            .accessibilityLabel("Health data types we access")

            Spacer()

            // Privacy note
            HStack(spacing: 8) {
                Image(systemName: "lock.shield.fill")
                    .foregroundColor(.stressRelaxed)
                    .font(.system(size: 12))
                    .accessibilityHidden(true)

                Text("Your data stays on your device. We never sell your information.")
                    .font(.system(size: 13))
                    .foregroundColor(.secondary)
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Privacy assurance: Your data stays on your device")

            // Continue button
            Button(action: { Task { await viewModel.requestHealthKitAuthorization() } }) {
                if viewModel.isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                } else {
                    Text("Authorize & Continue")
                        .font(.system(size: 17, weight: .semibold))
                        .foregroundColor(.white)
                }
            }
            .frame(maxWidth: .infinity)
            .frame(height: 48)
            .background(viewModel.isLoading ? Color.gray : Color.primaryBlue)
            .cornerRadius(12)
            .disabled(viewModel.isLoading)
            .accessibilityHint("Requests health kit authorization")
        }
        .padding(24)
        .alert("Authorization Error", isPresented: .constant(viewModel.authorizationError != nil)) {
            Button("OK") {
                viewModel.authorizationError = nil
            }
        } message: {
            if let error = viewModel.authorizationError {
                Text(error)
            }
        }
    }
}

struct DataTypeCard: View {
    let icon: String
    let color: Color
    let title: String
    let description: String

    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: icon)
                .font(.system(size: 20))
                .foregroundColor(color)
                .frame(width: 44, height: 44)
                .background(color.opacity(0.15))
                .cornerRadius(10)

            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.system(size: 17, weight: .semibold))

                Text(description)
                    .font(.system(size: 12))
                    .foregroundColor(.secondary)
            }

            Spacer()

            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(.stressRelaxed)
                .accessibilityHidden(true)
        }
        .padding(16)
        .background(Color.secondary.opacity(0.1))
        .cornerRadius(12)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(title), \(description)")
    }
}

#Preview {
    OnboardingHealthSyncView()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingHealthSyncViewModel.swift">
import Foundation
import HealthKit

@MainActor
@Observable
final class OnboardingHealthSyncViewModel {
    var isLoading = false
    var healthKitAuthorized = false
    var authorizationError: String?

    private let healthKitService: HealthKitServiceProtocol

    init(healthKitService: HealthKitServiceProtocol) {
        self.healthKitService = healthKitService
    }

    convenience init() {
        self.init(healthKitService: HealthKitManager())
    }

    func requestHealthKitAuthorization() async {
        isLoading = true
        defer { isLoading = false }

        do {
            try await healthKitService.requestAuthorization()
            healthKitAuthorized = true
            authorizationError = nil
        } catch {
            healthKitAuthorized = false
            authorizationError = error.localizedDescription
        }
    }

    var canProceed: Bool {
        healthKitAuthorized
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingSuccessView.swift">
import Darwin
import SwiftData
import SwiftUI

struct OnboardingSuccessView: View {
    @State private var viewModel: OnboardingSuccessViewModel

    init(repository: StressRepositoryProtocol) {
        _viewModel = State(initialValue: OnboardingSuccessViewModel(repository: repository))
    }

    var body: some View {
        VStack(spacing: 32) {
            Spacer()

            // Success illustration
            ZStack {
                Circle()
                    .fill(Color.stressRelaxed.opacity(0.1))
                    .frame(width: 160, height: 160)

                Image(systemName: "checkmark.circle.fill")
                    .font(.system(size: 96))
                    .foregroundColor(.stressRelaxed)

                // Confetti particles (simplified)
                ForEach(0..<8) { index in
                    Circle()
                        .fill(confettiColor(index))
                        .frame(width: 8, height: 8)
                        .offset(confettiOffset(index))
                }
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Success checkmark icon")

            // Headline
            Text("You're All Set!")
                .font(.system(size: 34, weight: .bold))
                .accessibilityAddTraits(.isHeader)

            // Summary
            VStack(spacing: 8) {
                Text("Your stress baseline is being calculated")
                    .font(.system(size: 17))
                    .foregroundColor(.secondary)

                if let baseline = viewModel.personalBaseline {
                    Text("Baseline: \(Int(baseline.baselineHRV)) ms HRV, \(Int(baseline.restingHeartRate)) bpm resting HR")
                        .font(.system(size: 13))
                        .foregroundColor(.primaryBlue)
                        .accessibilityLabel("Baseline: \(Int(baseline.baselineHRV)) milliseconds HRV, \(Int(baseline.restingHeartRate)) beats per minute resting heart rate")
                }
            }

            Spacer()

            // CTA
            Button(action: { viewModel.completeOnboarding() }) {
                Text("Go to Dashboard")
                    .font(.system(size: 17, weight: .semibold))
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 48)
                    .background(Color.primaryBlue)
                    .cornerRadius(12)
            }
            .accessibilityHint("Opens the main dashboard")
        }
        .padding(24)
    }

    private func confettiColor(_ index: Int) -> Color {
        let colors: [Color] = [.stressRelaxed, .primaryBlue, .stressModerate]
        return colors[index % colors.count]
    }

    private func confettiOffset(_ index: Int) -> CGSize {
        let angle = Double(index) * .pi / 4
        let distance: CGFloat = 80
        return CGSize(width: CGFloat(cos(angle)) * distance, height: CGFloat(sin(angle)) * distance)
    }
}

#Preview {
    let repository = StressRepository(
        modelContext: ModelContext(try! ModelContainer(for: StressMeasurement.self)),
        baselineCalculator: BaselineCalculator()
    )
    OnboardingSuccessView(repository: repository)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingSuccessViewModel.swift">
import Foundation

@MainActor
@Observable
final class OnboardingSuccessViewModel {
    var personalBaseline: PersonalBaseline?

    private let repository: StressRepositoryProtocol

    init(repository: StressRepositoryProtocol) {
        self.repository = repository
        loadBaseline()
    }

    func loadBaseline() {
        Task {
            do {
                personalBaseline = try await repository.getBaseline()
            } catch {
                personalBaseline = nil
            }
        }
    }

    func completeOnboarding() {
        UserDefaults.standard.set(true, forKey: "hasCompletedOnboarding")
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingWelcomeView.swift">
import SwiftUI

struct OnboardingWelcomeView: View {
    @State private var viewModel = OnboardingWelcomeViewModel()

    var body: some View {
        VStack(spacing: 32) {
            Spacer()

            // Hero illustration
            ZStack {
                Circle()
                    .stroke(Color.stressRelaxed.opacity(0.2), lineWidth: 4)
                    .frame(width: 160, height: 160)

                Image(systemName: "heart.fill")
                    .font(.system(size: 64))
                    .foregroundColor(.stressRelaxed)

                // Orbiting ring animation
                Circle()
                    .trim(from: 0, to: 0.7)
                    .stroke(Color.stressRelaxed, style: StrokeStyle(lineWidth: 3, lineCap: .round))
                    .frame(width: 200, height: 200)
                    .rotationEffect(.degrees(-90))
                    .animation(.linear(duration: 3).repeatForever(autoreverses: false), value: viewModel.isAnimating)
            }
            .accessibilityElement(children: .ignore)
            .accessibilityLabel("Heart icon with rotating ring")

            // Headline
            Text("Understand Your Stress")
                .font(.system(size: 28, weight: .bold))
                .accessibilityAddTraits(.isHeader)

            // Feature list
            VStack(alignment: .leading, spacing: 16) {
                FeatureRow(icon: "checkmark.circle.fill", text: "Accurate HRV-based stress monitoring")
                FeatureRow(icon: "checkmark.circle.fill", text: "Personalized baseline calculations")
                FeatureRow(icon: "checkmark.circle.fill", text: "Actionable health insights")
            }
            .accessibilityElement(children: .contain)
            .accessibilityLabel("Features list")

            Spacer()

            // CTAs
            VStack(spacing: 12) {
                Button(action: { viewModel.handleGetStarted() }) {
                    Text("Get Started")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .frame(height: 48)
                        .background(Color.primaryBlue)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                }
                .accessibilityHint("Begins health kit authorization")

                Button(action: { viewModel.handleSignIn() }) {
                    Text("Already have an account? Sign in")
                        .font(.subheadline)
                }
                .accessibilityHint("Opens sign in flow (coming soon)")
            }
        }
        .padding(24)
        .onAppear {
            viewModel.isAnimating = true
        }
    }
}

struct FeatureRow: View {
    let icon: String
    let text: String

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .foregroundColor(.stressRelaxed)
                .font(.title3)
                .accessibilityHidden(true)

            Text(text)
                .font(.body)
                .foregroundColor(.primary)
        }
    }
}

#Preview {
    OnboardingWelcomeView()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Onboarding/OnboardingWelcomeViewModel.swift">
import Foundation

@MainActor
@Observable
final class OnboardingWelcomeViewModel {
    var isAnimating = true
    var navigateToHealthKit = false
    var navigateToSignIn = false

    func handleGetStarted() {
        navigateToHealthKit = true
    }

    func handleSignIn() {
        navigateToSignIn = true
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Settings/DataManagement/Components/DeleteConfirmationView.swift">
import SwiftUI

/// Confirmation view for data deletion operations
/// Requires user to type "DELETE" to confirm, shows affected data and consequences
struct DeleteConfirmationView: View {
    let deleteScope: DataDeleteScope
    let dateRange: DateRange?
    let affectedDataCounts: AffectedDataCounts
    let onConfirm: () -> Void
    let onCancel: () -> Void

    @State private var confirmationText = ""
    @FocusState private var isTextFieldFocused: Bool

    private let requiredConfirmationText = "DELETE"

    var isConfirmationValid: Bool {
        confirmationText.uppercased() == requiredConfirmationText
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Warning icon
                    Image(systemName: "exclamationmark.triangle.fill")
                        .font(.system(size: 64))
                        .foregroundColor(.warning)
                        .padding(.top, 20)

                    // Title
                    Text(deleteScope.title)
                        .font(.title2)
                        .fontWeight(.bold)
                        .multilineTextAlignment(.center)
                        .foregroundColor(.primary)
                        .padding(.horizontal)

                    // Warning message
                    Text(deleteScope.warningMessage)
                        .font(.body)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)

                    // What will be deleted section
                    VStack(alignment: .leading, spacing: 16) {
                        Text("What will be deleted")
                            .font(.headline)
                            .foregroundColor(.primary)

                        VStack(alignment: .leading, spacing: 12) {
                            DeleteConfirmationItem(
                                icon: "heart.slash.fill",
                                title: "Stress Measurements",
                                count: affectedDataCounts.stressMeasurements,
                                color: .error
                            )

                            if deleteScope.includesBaseline {
                                DeleteConfirmationItem(
                                    icon: "chart.line.flattrend.xyaxis",
                                    title: "Personal Baseline",
                                    count: affectedDataCounts.baseline ? 1 : 0,
                                    color: .warning
                                )
                            }

                            if let range = dateRange {
                                DeleteConfirmationItem(
                                    icon: "calendar.badge.exclamationmark",
                                    title: "Date Range",
                                    subtitle: range.displayText,
                                    count: nil,
                                    color: .secondary
                                )
                            }
                        }
                    }
                    .padding()
                    .background(Color.secondary.opacity(0.1))
                    .cornerRadius(12)

                    // Consequences section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Important")
                            .font(.headline)
                            .foregroundColor(.primary)

                        VStack(alignment: .leading, spacing: 8) {
                            ConsequenceRow(
                                icon: "xmark.circle.fill",
                                text: "This action cannot be undone"
                            )

                            ConsequenceRow(
                                icon: "xmark.circle.fill",
                                text: deleteScope.includesCloud ? "Data will be removed from all devices" : "Only local data will be affected"
                            )

                            ConsequenceRow(
                                icon: "info.circle.fill",
                                text: "HealthKit data will not be affected"
                            )
                        }
                    }
                    .padding()
                    .background(Color.secondary.opacity(0.1))
                    .cornerRadius(12)

                    // Confirmation requirement
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Type DELETE to confirm")
                            .font(.headline)
                            .foregroundColor(.primary)

                        TextField("Enter DELETE", text: $confirmationText)
                            .textFieldStyle(.roundedBorder)
                            .textInputAutocapitalization(.characters)
                            .focused($isTextFieldFocused)
                            .accessibilityLabel("Confirmation text field")
                            .accessibilityHint("Type \(requiredConfirmationText) to enable the delete button")
                    }
                    .padding()
                    .background(Color.secondary.opacity(0.1))
                    .cornerRadius(12)

                    // Action buttons
                    VStack(spacing: 12) {
                        Button(action: onConfirm) {
                            HStack {
                                Image(systemName: "trash.fill")
                                Text("Delete Everything")
                            }
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .frame(height: 52)
                            .background(isConfirmationValid ? Color.error : Color.secondary)
                            .cornerRadius(26)
                        }
                        .disabled(!isConfirmationValid)
                        .accessibilityLabel("Delete all data")
                        .accessibilityHint(isConfirmationValid ? "Double tap to permanently delete data" : "Type DELETE to enable")

                        Button(action: onCancel) {
                            Text("Cancel")
                                .font(.headline)
                                .foregroundColor(.primaryBlue)
                                .frame(maxWidth: .infinity)
                                .frame(height: 52)
                                .background(Color.primaryBlue.opacity(0.1))
                                .cornerRadius(26)
                        }
                        .accessibilityLabel("Cancel and return")
                    }
                    .padding(.horizontal, 32)
                }
                .padding(.bottom, 24)
            }
            .navigationTitle("Confirm Deletion")
            .navigationBarTitleDisplayMode(.inline)
        }
        .onAppear {
            isTextFieldFocused = true
        }
    }
}

/// Individual item showing what will be deleted
struct DeleteConfirmationItem: View {
    let icon: String
    let title: String
    var subtitle: String? = nil
    let count: Int?
    let color: Color

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundColor(color)
                .frame(width: 28)

            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.callout)
                    .foregroundColor(.primary)

                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }

            Spacer()

            if let count = count {
                Text("\(count)")
                    .font(.callout)
                    .fontWeight(.semibold)
                    .foregroundColor(color)
            }
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel(title)
        if let count = count {
            Text(count == 1 ? "1 item" : "\(count) items")
                .accessibilityHidden(true)
        }
    }
}

/// Row displaying a consequence
struct ConsequenceRow: View {
    let icon: String
    let text: String

    var body: some View {
        HStack(alignment: .top, spacing: 8) {
            Image(systemName: icon)
                .font(.callout)
                .foregroundColor(icon.contains("xmark") ? .error : .warning)

            Text(text)
                .font(.callout)
                .foregroundColor(.primary)
                .fixedSize(horizontal: false, vertical: true)
        }
    }
}

/// Data deletion scope
enum DataDeleteScope {
    case localOnly
    case cloudOnly
    case everything

    var title: String {
        switch self {
        case .localOnly: return "Delete Local Data"
        case .cloudOnly: return "Delete Cloud Data"
        case .everything: return "Delete All Data"
        }
    }

    var warningMessage: String {
        switch self {
        case .localOnly:
            return "This will permanently delete all stress measurements stored on this device. Your cloud data will not be affected."
        case .cloudOnly:
            return "This will permanently delete all data from iCloud. Your local data will remain on this device."
        case .everything:
            return "This will permanently delete all your stress measurements from both this device and iCloud. This action cannot be undone."
        }
    }

    var includesBaseline: Bool {
        switch self {
        case .localOnly, .everything: return true
        case .cloudOnly: return false
        }
    }

    var includesCloud: Bool {
        switch self {
        case .localOnly: return false
        case .cloudOnly, .everything: return true
        }
    }
}

/// Date range for deletion
struct DateRange {
    let startDate: Date
    let endDate: Date

    var displayText: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return "\(formatter.string(from: startDate)) - \(formatter.string(from: endDate))"
    }
}

/// Counts of affected data
struct AffectedDataCounts {
    let stressMeasurements: Int
    let baseline: Bool
}

#Preview {
    DeleteConfirmationView(
        deleteScope: .everything,
        dateRange: DateRange(
            startDate: Date().addingTimeInterval(-30 * 24 * 60 * 60),
            endDate: Date()
        ),
        affectedDataCounts: AffectedDataCounts(
            stressMeasurements: 1247,
            baseline: true
        ),
        onConfirm: {},
        onCancel: {}
    )
}
</file>

<file path="StressMonitor/StressMonitor/Views/Settings/DataManagement/Components/ExportProgressView.swift">
import SwiftUI

/// Progress view for data export operations
/// Displays progress bar, current operation, records processed, and estimated time remaining
struct ExportProgressView: View {
    let progress: Double // 0.0 to 1.0
    let currentOperation: String
    let recordsProcessed: Int
    let totalRecords: Int
    let estimatedTimeRemaining: TimeInterval?
    let isCancellable: Bool
    let onCancel: () -> Void

    var body: some View {
        VStack(spacing: 24) {
            Spacer()

            // Progress indicator with animation
            ZStack {
                Circle()
                    .stroke(Color.secondary.opacity(0.2), lineWidth: 8)
                    .frame(width: 120, height: 120)

                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(
                        Color.primaryBlue,
                        style: StrokeStyle(lineWidth: 8, lineCap: .round)
                    )
                    .frame(width: 120, height: 120)
                    .rotationEffect(.degrees(-90))
                    .animation(.easeInOut(duration: 0.3), value: progress)

                VStack(spacing: 4) {
                    Text("\(Int(progress * 100))%")
                        .font(.system(size: 28, weight: .bold, design: .rounded))
                        .foregroundColor(.primary)

                    Text("Complete")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .accessibilityLabel("Export progress: \(Int(progress * 100)) percent complete")
            .accessibilityValue("\(recordsProcessed) of \(totalRecords) records processed")

            VStack(spacing: 12) {
                // Current operation
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text(currentOperation)
                        .font(.body)
                        .foregroundColor(.primary)
                }
                .frame(maxWidth: .infinity)
                .padding(.horizontal, 20)
                .padding(.vertical, 12)
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(10)

                // Records processed
                HStack {
                    Image(systemName: "doc.on.doc")
                        .foregroundColor(.secondary)
                    Text("\(recordsProcessed) of \(totalRecords) records")
                        .font(.callout)
                        .foregroundColor(.secondary)
                    Spacer()
                }
                .padding(.horizontal, 20)

                // Estimated time remaining
                if let timeRemaining = estimatedTimeRemaining {
                    HStack {
                        Image(systemName: "clock")
                            .foregroundColor(.secondary)
                        Text(estimatedTimeText(timeRemaining))
                            .font(.callout)
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .padding(.horizontal, 20)
                }
            }

            Spacer()

            // Cancel button (if cancellable)
            if isCancellable {
                Button(action: onCancel) {
                    Text("Cancel")
                        .font(.headline)
                        .foregroundColor(.primaryBlue)
                        .frame(maxWidth: .infinity)
                        .frame(height: 52)
                        .background(Color.primaryBlue.opacity(0.1))
                        .cornerRadius(26)
                }
                .padding(.horizontal, 32)
                .accessibilityHint("Cancel the export operation")
            }
        }
        .padding(.top, 32)
        .padding(.bottom, 24)
    }

    private func estimatedTimeText(_ timeInterval: TimeInterval) -> String {
        if timeInterval < 60 {
            return "About \(Int(timeInterval)) seconds remaining"
        } else {
            let minutes = Int(timeInterval / 60)
            return "About \(minutes) minute\(minutes == 1 ? "" : "s") remaining"
        }
    }
}

/// Linear progress bar variant for use in cards
struct ExportProgressBarView: View {
    let progress: Double // 0.0 to 1.0
    let currentOperation: String
    let recordsProcessed: Int
    let totalRecords: Int

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(currentOperation)
                    .font(.callout)
                    .foregroundColor(.primary)
                Spacer()
                Text("\(recordsProcessed)/\(totalRecords)")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.secondary.opacity(0.2))
                        .frame(height: 8)

                    // Progress fill
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.primaryBlue)
                        .frame(width: geometry.size.width * progress, height: 8)
                        .animation(.easeInOut(duration: 0.3), value: progress)
                }
            }
            .frame(height: 8)
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(currentOperation), \(recordsProcessed) of \(totalRecords) records, \(Int(progress * 100)) percent complete")
    }
}

#Preview {
    VStack(spacing: 40) {
        ExportProgressView(
            progress: 0.65,
            currentOperation: "Preparing data...",
            recordsProcessed: 650,
            totalRecords: 1000,
            estimatedTimeRemaining: 45,
            isCancellable: true,
            onCancel: {}
        )

        ExportProgressBarView(
            progress: 0.45,
            currentOperation: "Generating CSV...",
            recordsProcessed: 450,
            totalRecords: 1000
        )
        .padding()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Settings/DataManagement/DataDeleteView.swift">
import SwiftUI
import SwiftData

/// Data deletion view with options for local, cloud, or complete deletion
struct DataDeleteView: View {
    @Environment(\.modelContext) private var modelContext
    @Environment(\.dismiss) private var dismiss

    @State private var viewModel: DataDeleteViewModel
    @State private var showingConfirmation = false
    @State private var showingError = false
    @State private var errorMessage = ""

    init(viewModel: DataDeleteViewModel = DataDeleteViewModel()) {
        _viewModel = State(initialValue: viewModel)
    }

    var body: some View {
        Form {
            // Delete Scope Section
            Section("Delete Options") {
                Picker("Scope", selection: $viewModel.deleteScope) {
                    Text("Local Only").tag(DataDeleteScope.localOnly)
                    Text("Cloud Only").tag(DataDeleteScope.cloudOnly)
                    Text("Everything").tag(DataDeleteScope.everything)
                }
                .pickerStyle(.segmented)
                .accessibilityLabel("Delete scope selection")

                Text(viewModel.deleteScopeDescription)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.vertical, 4)
            }

            // Date Range Section
            Section("Date Range") {
                Toggle("Custom Date Range", isOn: $viewModel.useCustomDateRange)
                    .accessibilityLabel("Use custom date range")

                if viewModel.useCustomDateRange {
                    DatePicker("Start Date", selection: $viewModel.customStartDate, displayedComponents: .date)
                        .accessibilityLabel("Start date")
                    DatePicker("End Date", selection: $viewModel.customEndDate, displayedComponents: .date)
                        .accessibilityLabel("End date")
                } else {
                    Picker("Range", selection: $viewModel.dateRange) {
                        Text("All Time").tag(DeleteDateRange.all)
                        Text("Last 3 Months").tag(DeleteDateRange.threeMonths)
                        Text("Last Month").tag(DeleteDateRange.month)
                        Text("Last Week").tag(DeleteDateRange.week)
                    }
                    .pickerStyle(.menu)
                    .accessibilityLabel("Date range selection")
                }

                if let description = viewModel.dateRangeDescription {
                    Text(description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }

            // Affected Data Section
            if !viewModel.isDeleting {
                Section("Affected Data") {
                    AffectedDataRow(
                        icon: "heart.slash.fill",
                        label: "Stress Measurements",
                        count: viewModel.affectedMeasurementCount
                    )

                    if viewModel.deleteScope.includesBaseline {
                        AffectedDataRow(
                            icon: "chart.line.flattrend.xyaxis",
                            label: "Personal Baseline",
                            count: viewModel.affectedBaselineCount
                        )
                    }

                    HStack {
                        Text("Total")
                            .foregroundColor(.secondary)
                        Spacer()
                        Text("\(viewModel.totalAffectedCount) items")
                            .fontWeight(.semibold)
                            .foregroundColor(.error)
                    }
                    .accessibilityElement(children: .combine)
                }
            }

            // Delete Progress Section
            if viewModel.isDeleting {
                Section {
                    VStack(spacing: 16) {
                        ZStack {
                            Circle()
                                .stroke(Color.secondary.opacity(0.2), lineWidth: 8)
                                .frame(width: 80, height: 80)

                            Circle()
                                .trim(from: 0, to: viewModel.deleteProgress)
                                .stroke(
                                    Color.error,
                                    style: StrokeStyle(lineWidth: 8, lineCap: .round)
                                )
                                .frame(width: 80, height: 80)
                                .rotationEffect(.degrees(-90))
                                .animation(.easeInOut(duration: 0.3), value: viewModel.deleteProgress)

                            Text("\(Int(viewModel.deleteProgress * 100))%")
                                .font(.system(size: 18, weight: .bold, design: .rounded))
                        }

                        Text(viewModel.currentOperation)
                            .font(.callout)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 16)
                    .accessibilityElement(children: .combine)
                    .accessibilityLabel("Delete progress: \(Int(viewModel.deleteProgress * 100)) percent")
                }
            }

            // Delete Button Section
            if !viewModel.isDeleting {
                Section {
                    Button(action: {
                        showingConfirmation = true
                    }) {
                        HStack {
                            Spacer()
                            Image(systemName: "trash.fill")
                            Text("Delete Data")
                            Spacer()
                        }
                    }
                    .disabled(viewModel.totalAffectedCount == 0)
                    .accessibilityLabel("Delete data")
                    .accessibilityHint(viewModel.totalAffectedCount == 0 ? "No data to delete" : "Double tap to confirm deletion")
                }

                // Information Section
                Section {
                    VStack(alignment: .leading, spacing: 12) {
                        InfoRow(
                            icon: "checkmark.circle.fill",
                            text: viewModel.deleteScope.includesCloud ? "Data will be removed from all devices" : "Only local data will be affected",
                            color: .primaryBlue
                        )

                        InfoRow(
                            icon: "xmark.circle.fill",
                            text: "This action cannot be undone",
                            color: .error
                        )

                        InfoRow(
                            icon: "info.circle.fill",
                            text: "HealthKit data will not be affected",
                            color: .secondary
                        )
                    }
                    .padding(.vertical, 4)
                }
            }
        }
        .navigationTitle("Delete Data")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") {
                    if viewModel.isDeleting {
                        viewModel.cancelDelete()
                    } else {
                        dismiss()
                    }
                }
                .accessibilityLabel(viewModel.isDeleting ? "Stop deletion" : "Cancel")
            }
        }
        .sheet(isPresented: $showingConfirmation) {
            DeleteConfirmationView(
                deleteScope: viewModel.deleteScope,
                dateRange: viewModel.getDateRange(),
                affectedDataCounts: AffectedDataCounts(
                    stressMeasurements: viewModel.affectedMeasurementCount,
                    baseline: viewModel.affectedBaselineCount > 0
                ),
                onConfirm: {
                    showingConfirmation = false
                    Task {
                        await performDelete()
                    }
                },
                onCancel: {
                    showingConfirmation = false
                }
            )
        }
        .alert("Deletion Failed", isPresented: $showingError) {
            Button("OK", role: .cancel) {}
        } message: {
            Text(errorMessage)
        }
        .onAppear {
            Task {
                await viewModel.loadAffectedCounts(modelContext: modelContext)
            }
        }
        .onChange(of: viewModel.deleteScope) { _, _ in
            Task {
                await viewModel.loadAffectedCounts(modelContext: modelContext)
            }
        }
        .onChange(of: viewModel.dateRange) { _, _ in
            Task {
                await viewModel.loadAffectedCounts(modelContext: modelContext)
            }
        }
        .onChange(of: viewModel.useCustomDateRange) { _, _ in
            Task {
                await viewModel.loadAffectedCounts(modelContext: modelContext)
            }
        }
    }

    private func performDelete() async {
        do {
            try await viewModel.performDelete(modelContext: modelContext)
            HapticManager.shared.success()
            dismiss()
        } catch {
            await MainActor.run {
                errorMessage = error.localizedDescription
                showingError = true
                HapticManager.shared.error()
            }
        }
    }
}

/// Row displaying affected data count
struct AffectedDataRow: View {
    let icon: String
    let label: String
    let count: Int

    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(.error)
                .frame(width: 24)

            Text(label)
                .foregroundColor(.primary)

            Spacer()

            Text("\(count)")
                .fontWeight(.semibold)
                .foregroundColor(.error)
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(label): \(count) items")
    }
}

/// Information row
struct InfoRow: View {
    let icon: String
    let text: String
    let color: Color

    var body: some View {
        HStack(alignment: .top, spacing: 8) {
            Image(systemName: icon)
                .foregroundColor(color)
                .frame(width: 20)

            Text(text)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

/// Date range for deletion
enum DeleteDateRange {
    case all
    case threeMonths
    case month
    case week

    var days: Int? {
        switch self {
        case .all: return nil
        case .threeMonths: return 90
        case .month: return 30
        case .week: return 7
        }
    }
}

/// View model for data deletion
@Observable
class DataDeleteViewModel {
    var deleteScope: DataDeleteScope = .localOnly
    var dateRange: DeleteDateRange = .all
    var useCustomDateRange: Bool = false
    var customStartDate: Date = Calendar.current.date(byAdding: .day, value: -30, to: Date()) ?? Date()
    var customEndDate: Date = Date()

    var isDeleting: Bool = false
    var deleteProgress: Double = 0
    var currentOperation: String = ""
    private var cancellationToken: Task<Void, Never>?

    private(set) var affectedMeasurementCount: Int = 0
    private(set) var affectedBaselineCount: Int = 0

    var deleteScopeDescription: String {
        switch deleteScope {
        case .localOnly:
            return "Only data stored on this device will be deleted. Cloud data will remain intact."
        case .cloudOnly:
            return "Only iCloud data will be deleted. Local data on this device will remain."
        case .everything:
            return "All data will be permanently deleted from both this device and iCloud."
        }
    }

    var dateRangeDescription: String? {
        guard useCustomDateRange else {
            switch dateRange {
            case .all: return nil
            case .threeMonths: return "Data from the last 3 months"
            case .month: return "Data from the last month"
            case .week: return "Data from the last week"
            }
        }

        let formatter = DateFormatter()
        formatter.dateStyle = .short
        return "From \(formatter.string(from: customStartDate)) to \(formatter.string(from: customEndDate))"
    }

    var totalAffectedCount: Int {
        affectedMeasurementCount + affectedBaselineCount
    }

    func getDateRange() -> DateRange? {
        guard useCustomDateRange else {
            if let days = dateRange.days {
                return DateRange(
                    startDate: Calendar.current.date(byAdding: .day, value: -days, to: Date()) ?? Date(),
                    endDate: Date()
                )
            }
            return nil
        }
        return DateRange(startDate: customStartDate, endDate: customEndDate)
    }

    func loadAffectedCounts(modelContext: ModelContext) async {
        await MainActor.run {
            currentOperation = "Calculating affected data..."
        }

        let (start, end) = getDateRangeBounds()

        // Count stress measurements
        let measurementDescriptor = FetchDescriptor<StressMeasurement>(
            predicate: #Predicate { measurement in
                measurement.timestamp >= start && measurement.timestamp <= end
            }
        )

        do {
            let measurements = try modelContext.fetch(measurementDescriptor)
            await MainActor.run {
                affectedMeasurementCount = measurements.count
                affectedBaselineCount = deleteScope.includesBaseline ? 1 : 0
                currentOperation = ""
            }
        } catch {
            await MainActor.run {
                affectedMeasurementCount = 0
                affectedBaselineCount = 0
                currentOperation = ""
            }
        }
    }

    func performDelete(modelContext: ModelContext) async throws {
        isDeleting = true
        deleteProgress = 0
        currentOperation = "Preparing to delete..."

        cancellationToken = Task {
            await MainActor.run {
                isDeleting = false
                deleteProgress = 0
                currentOperation = ""
            }
        }

        let (start, end) = getDateRangeBounds()

        await MainActor.run {
            currentOperation = "Fetching data..."
        }

        let descriptor = FetchDescriptor<StressMeasurement>(
            predicate: #Predicate { measurement in
                measurement.timestamp >= start && measurement.timestamp <= end
            }
        )

        let measurements = try modelContext.fetch(descriptor)

        guard !measurements.isEmpty else {
            throw DeleteError.noData
        }

        for (index, measurement) in measurements.enumerated() {
            try Task.checkCancellation()

            await MainActor.run {
                deleteProgress = Double(index + 1) / Double(measurements.count)
                currentOperation = "Deleting \(index + 1) of \(measurements.count)..."
            }

            modelContext.delete(measurement)
        }

        try modelContext.save()

        // Delete baseline if scope includes it
        if deleteScope.includesBaseline {
            try await deleteBaseline(modelContext: modelContext)
        }

        await MainActor.run {
            deleteProgress = 1.0
            currentOperation = "Delete complete"
        }
    }

    func cancelDelete() {
        cancellationToken?.cancel()
        cancellationToken = nil
    }

    private func deleteBaseline(modelContext: ModelContext) async throws {
        // Baseline deletion logic would go here
        // For now, we'll just mark it as completed
        await MainActor.run {
            currentOperation = "Removing baseline..."
        }
    }

    private func getDateRangeBounds() -> (start: Date, end: Date) {
        let calendar = Calendar.current
        let now = Date()

        if useCustomDateRange {
            return (customStartDate, customEndDate)
        }

        guard let days = dateRange.days else {
            return (Date.distantPast, now)
        }

        let start = calendar.date(byAdding: .day, value: -days, to: now) ?? now
        return (start, now)
    }
}

enum DeleteError: LocalizedError {
    case noData
    case operationFailed

    var errorDescription: String? {
        switch self {
        case .noData: return "No data found to delete"
        case .operationFailed: return "Failed to complete deletion"
        }
    }
}

#Preview {
    NavigationView {
        DataDeleteView()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Settings/DataManagement/DataExportView.swift">
import SwiftUI
import SwiftData

/// Data export view with date range picker, format selection, and share sheet integration
struct DataExportView: View {
    @Environment(\.modelContext) private var modelContext
    @Environment(\.dismiss) private var dismiss

    @State private var viewModel: DataExportViewModel
    @State private var showingShareSheet = false
    @State private var exportURL: URL?
    @State private var showingError = false
    @State private var errorMessage = ""

    init(viewModel: DataExportViewModel = DataExportViewModel()) {
        _viewModel = State(initialValue: viewModel)
    }

    var body: some View {
        Form {
            dateRangeSection
            dataSelectionSection
            formatSection
            previewSection
            exportProgressSection
            exportButtonSection
            recordsCountSection
        }
        .navigationTitle("Export Data")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") {
                    dismiss()
                }
                .accessibilityLabel("Cancel export")
            }
        }
        .sheet(isPresented: $showingShareSheet) {
            if let url = exportURL {
                ShareSheet(items: [url])
                    .presentationDetents([.medium, .large])
                    .presentationDragIndicator(.visible)
            }
        }
        .alert("Export Failed", isPresented: $showingError) {
            Button("OK", role: .cancel) {}
        } message: {
            Text(errorMessage)
        }
        .onAppear {
            Task {
                await viewModel.loadPreviewData(modelContext: modelContext)
            }
        }
        .onChange(of: viewModel.dateRange) { _, _ in
            Task {
                await viewModel.loadPreviewData(modelContext: modelContext)
            }
        }
        .onChange(of: viewModel.format) { _, _ in
            Task {
                await viewModel.loadPreviewData(modelContext: modelContext)
            }
        }
    }

    private var dateRangeSection: some View {
        Section("Date Range") {
            Picker("Range", selection: $viewModel.dateRange) {
                ForEach(ExportDateRange.allCases, id: \.self) { range in
                    Text(range.rawValue).tag(range)
                }
            }
            .pickerStyle(.segmented)
            .accessibilityLabel("Date range selection")

            if viewModel.dateRange == .custom {
                DatePicker("Start Date", selection: $viewModel.customStartDate, displayedComponents: .date)
                    .accessibilityLabel("Start date")
                DatePicker("End Date", selection: $viewModel.customEndDate, displayedComponents: .date)
                    .accessibilityLabel("End date")
            }

            Text(viewModel.dateRangeDescription)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }

    private var dataSelectionSection: some View {
        Section("Data to Include") {
            Toggle("HRV Measurements", isOn: $viewModel.includeHRV)
                .accessibilityLabel("Include HRV measurements")

            Toggle("Heart Rate Data", isOn: $viewModel.includeHeartRate)
                .accessibilityLabel("Include heart rate data")

            Toggle("Stress Levels", isOn: $viewModel.includeStressLevels)
                .accessibilityLabel("Include stress levels")

            Toggle("Baseline Data", isOn: $viewModel.includeBaseline)
                .accessibilityLabel("Include baseline data")
        }
    }

    private var formatSection: some View {
        Section("Format") {
            Picker("File Format", selection: $viewModel.format) {
                Text("CSV").tag(ExportFormat.csv)
                Text("JSON").tag(ExportFormat.json)
            }
            .pickerStyle(.segmented)
            .accessibilityLabel("File format")

            Text(viewModel.formatDescription)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }

    @ViewBuilder
    private var previewSection: some View {
        if let preview = viewModel.previewData {
            Section("Preview") {
                VStack(alignment: .leading, spacing: 8) {
                    Text("First \(preview.count) records will be exported")
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Text(preview)
                        .font(.system(.caption, design: .monospaced))
                        .padding(8)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .background(Color.secondary.opacity(0.1))
                        .cornerRadius(6)
                        .lineLimit(5)
                }
            }
        }
    }

    @ViewBuilder
    private var exportProgressSection: some View {
        if viewModel.isExporting {
            Section {
                ExportProgressBarView(
                    progress: viewModel.exportProgress,
                    currentOperation: viewModel.currentOperation,
                    recordsProcessed: viewModel.recordsProcessed,
                    totalRecords: viewModel.totalRecords
                )
            }
        }
    }

    private var exportButtonSection: some View {
        Section {
            Button(action: {
                Task {
                    await performExport()
                }
            }) {
                HStack {
                    Spacer()
                    if viewModel.isExporting {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Exporting...")
                            .foregroundColor(.secondary)
                    } else {
                        Image(systemName: "square.and.arrow.up")
                        Text("Export Data")
                    }
                    Spacer()
                }
            }
            .disabled(viewModel.isExporting || !viewModel.hasValidSelection)
            .accessibilityLabel(viewModel.isExporting ? "Exporting data" : "Export data")
            .accessibilityHint(!viewModel.hasValidSelection ? "Select at least one data type to export" : "Double tap to start export")
        }
    }

    @ViewBuilder
    private var recordsCountSection: some View {
        if !viewModel.isExporting {
            Section {
                HStack {
                    Text("Records to Export")
                        .foregroundColor(.secondary)
                    Spacer()
                    Text("\(viewModel.estimatedRecordCount)")
                        .fontWeight(.semibold)
                }
                .accessibilityElement(children: .combine)
            }
        }
    }

    private func performExport() async {
        do {
            viewModel.isExporting = true
            defer { viewModel.isExporting = false }

            let url = try await viewModel.exportData(modelContext: modelContext)
            await MainActor.run {
                exportURL = url
                showingShareSheet = true
                HapticManager.shared.success()
            }
        } catch {
            await MainActor.run {
                errorMessage = error.localizedDescription
                showingError = true
                HapticManager.shared.error()
            }
        }
    }
}

/// View model for data export
@Observable
class DataExportViewModel {
    var dateRange: ExportDateRange = .month
    var customStartDate: Date = Calendar.current.date(byAdding: .day, value: -30, to: Date()) ?? Date()
    var customEndDate: Date = Date()
    var includeHRV: Bool = true
    var includeHeartRate: Bool = true
    var includeStressLevels: Bool = true
    var includeBaseline: Bool = false
    var format: ExportFormat = .csv

    var isExporting: Bool = false
    var exportProgress: Double = 0
    var currentOperation: String = ""
    var recordsProcessed: Int = 0
    var totalRecords: Int = 0

    private(set) var previewData: String?
    private(set) var estimatedRecordCount: Int = 0

    var hasValidSelection: Bool {
        includeHRV || includeHeartRate || includeStressLevels || includeBaseline
    }

    var dateRangeDescription: String {
        let calendar = Calendar.current
        let now = Date()

        switch dateRange {
        case .day:
            return "Last 24 hours"
        case .week:
            return "Last 7 days"
        case .month:
            return "Last 4 weeks"
        case .threeMonths:
            return "Last 3 months"
        case .all:
            return "All time"
        case .custom:
            let formatter = DateFormatter()
            formatter.dateStyle = .short
            return "\(formatter.string(from: customStartDate)) - \(formatter.string(from: customEndDate))"
        }
    }

    var formatDescription: String {
        switch format {
        case .csv:
            return "Comma-separated values, compatible with Excel and Numbers"
        case .json:
            return "Structured data format, suitable for developers and backups"
        }
    }

    private var dateRangeBounds: (start: Date, end: Date) {
        let calendar = Calendar.current
        let now = Date()

        switch dateRange {
        case .day:
            let start = calendar.date(byAdding: .day, value: -1, to: now) ?? now
            return (start, now)
        case .week:
            let start = calendar.date(byAdding: .day, value: -7, to: now) ?? now
            return (start, now)
        case .month:
            let start = calendar.date(byAdding: .day, value: -28, to: now) ?? now
            return (start, now)
        case .threeMonths:
            let start = calendar.date(byAdding: .day, value: -90, to: now) ?? now
            return (start, now)
        case .all:
            return (Date.distantPast, now)
        case .custom:
            return (customStartDate, customEndDate)
        }
    }

    func loadPreviewData(modelContext: ModelContext) async {
        await MainActor.run {
            currentOperation = "Loading preview..."
        }

        // Simulate loading preview data
        let records = fetchRecords(modelContext: modelContext, limit: 3)
        estimatedRecordCount = fetchRecords(modelContext: modelContext, limit: nil).count

        await MainActor.run {
            if format == .csv {
                previewData = generateCSVPreview(records: records)
            } else {
                previewData = generateJSONPreview(records: records)
            }
            currentOperation = ""
        }
    }

    func exportData(modelContext: ModelContext) async throws -> URL {
        let records = fetchRecords(modelContext: modelContext, limit: nil)
        totalRecords = records.count
        recordsProcessed = 0
        exportProgress = 0

        let fileName = "stress_export_\(Int(Date().timeIntervalSince1970))"
        let fileExtension = format == .csv ? "csv" : "json"

        guard let tempDir = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first else {
            throw ExportError.fileAccessFailed
        }

        let fileURL = tempDir.appendingPathComponent("\(fileName).\(fileExtension)")

        await MainActor.run {
            currentOperation = "Generating \(fileExtension.uppercased())..."
        }

        let content: String
        if format == .csv {
            content = try await generateCSV(records: records)
        } else {
            content = try await generateJSON(records: records)
        }

        try content.write(to: fileURL, atomically: true, encoding: .utf8)

        await MainActor.run {
            exportProgress = 1.0
            currentOperation = "Export complete"
        }

        return fileURL
    }

    private func fetchRecords(modelContext: ModelContext, limit: Int?) -> [StressMeasurement] {
        let (start, end) = dateRangeBounds

        let descriptor = FetchDescriptor<StressMeasurement>(
            predicate: #Predicate { measurement in
                measurement.timestamp >= start && measurement.timestamp <= end
            },
            sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
        )

        do {
            var results = try modelContext.fetch(descriptor)
            if let limit = limit {
                results = Array(results.prefix(limit))
            }
            return results
        } catch {
            return []
        }
    }

    private func generateCSVPreview(records: [StressMeasurement]) -> String {
        guard !records.isEmpty else { return "No data to export" }

        var csv = "Timestamp,HRV,Heart Rate,Stress Level,Confidence\n"
        for record in records {
            let formatter = ISO8601DateFormatter()
            csv += "\(formatter.string(from: record.timestamp)),"
            csv += "\(String(format: "%.1f", record.hrv)),"
            csv += "\(String(format: "%.0f", record.restingHeartRate)),"
            csv += "\(String(format: "%.0f", record.stressLevel)),"
            csv += "\(String(format: "%.2f", (record.confidences?.first ?? 0.0)))\n"
        }
        return csv
    }

    private func generateJSONPreview(records: [StressMeasurement]) -> String {
        guard !records.isEmpty else { return "No data to export" }

        let previewRecords = Array(records.prefix(2))
        let dict = previewRecords.map { record in
            [
                "timestamp": ISO8601DateFormatter().string(from: record.timestamp),
                "hrv": record.hrv,
                "heartRate": record.restingHeartRate,
                "stressLevel": record.stressLevel,
                "confidence": (record.confidences?.first ?? 0.0)
            ]
        }
        if let jsonData = try? JSONSerialization.data(withJSONObject: dict, options: .prettyPrinted),
           let json = String(data: jsonData, encoding: .utf8) {
            return json
        }
        return "Error generating preview"
    }

    private func generateCSV(records: [StressMeasurement]) async throws -> String {
        var csv = "Timestamp,HRV,Heart Rate,Stress Level,Confidence\n"

        for (index, record) in records.enumerated() {
            await MainActor.run {
                recordsProcessed = index + 1
                exportProgress = Double(index + 1) / Double(records.count)
                currentOperation = "Processing record \(index + 1) of \(records.count)..."
            }

            let formatter = ISO8601DateFormatter()
            csv += "\(formatter.string(from: record.timestamp)),"
            csv += "\(String(format: "%.1f", record.hrv)),"
            csv += "\(String(format: "%.0f", record.restingHeartRate)),"
            csv += "\(String(format: "%.0f", record.stressLevel)),"
            csv += "\(String(format: "%.2f", (record.confidences?.first ?? 0.0)))\n"
        }

        return csv
    }

    private func generateJSON(records: [StressMeasurement]) async throws -> String {
        let dict = records.map { record in
            [
                "timestamp": ISO8601DateFormatter().string(from: record.timestamp),
                "hrv": record.hrv,
                "heartRate": record.restingHeartRate,
                "stressLevel": record.stressLevel,
                "confidence": (record.confidences?.first ?? 0.0)
            ]
        }

        let jsonData = try JSONSerialization.data(withJSONObject: dict, options: .prettyPrinted)
        guard let json = String(data: jsonData, encoding: .utf8) else {
            throw ExportError.encodingFailed
        }

        return json
    }
}

/// ShareSheet wrapper for SwiftUI
struct ShareSheet: UIViewControllerRepresentable {
    let items: [Any]

    func makeUIViewController(context: Context) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: items, applicationActivities: nil)
        return controller
    }

    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}

#Preview {
    NavigationView {
        DataExportView()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Trends/Components/DistributionBarView.swift">
import SwiftUI

struct DistributionBarView: View {
    let icon: String
    let label: String
    let percentage: Double
    let color: Color

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(Typography.caption1)
                .foregroundColor(color)
                .frame(width: 20)

            Text(label)
                .font(Typography.caption1)
                .frame(width: 60, alignment: .leading)

            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.secondary.opacity(0.2))

                    RoundedRectangle(cornerRadius: 4)
                        .fill(color)
                        .frame(width: geometry.size.width * (percentage / 100))
                }
            }
            .frame(height: 16)

            Text("\(Int(percentage))%")
                .font(Typography.caption1)
                .foregroundColor(.secondary)
                .frame(width: 40, alignment: .trailing)
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Trends/Components/InsightCard.swift">
import SwiftUI

struct InsightCard: View {
    let insight: PatternInsight

    var body: some View {
        HStack(spacing: 12) {
            Text(insight.icon)
                .font(.title2)
                .frame(width: 44, height: 44)
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(10)

            VStack(alignment: .leading, spacing: 2) {
                Text(insight.title)
                    .font(Typography.subheadline)
                    .fontWeight(.semibold)

                Text(insight.description)
                    .font(Typography.caption1)
                    .foregroundColor(.secondary)
            }

            Spacer()
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Trends/Components/LineChartView.swift">
import SwiftUI

struct LineChartView: View {
    let dataPoints: [ChartDataPoint]
    let accentColor: Color
    let showGrid: Bool

    @State private var selectedPoint: ChartDataPoint?
    @State private var touchLocation: CGPoint = .zero

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                if showGrid {
                    drawGrid(in: geometry.size)
                }

                drawAreaFill(in: geometry.size)
                drawLine(in: geometry.size)

                if selectedPoint != nil {
                    drawSelectionIndicator(in: geometry.size)
                }
            }
            .gesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        touchLocation = value.location
                        selectedPoint = findNearestPoint(to: value.location, in: geometry.size)
                    }
                    .onEnded { _ in }
            )
        }
    }

    private func drawGrid(in size: CGSize) -> some View {
        ZStack {
            ForEach(0..<5) { index in
                let y = CGFloat(index) / 4 * size.height
                Path { path in
                    path.move(to: CGPoint(x: 0, y: y))
                    path.addLine(to: CGPoint(x: size.width, y: y))
                }
                .stroke(Color.secondary.opacity(0.1), lineWidth: 1)
            }
        }
    }

    private func normalize(point: ChartDataPoint, in size: CGSize) -> CGPoint {
        guard let minValue = dataPoints.map({ $0.value }).min(),
              let maxValue = dataPoints.map({ $0.value }).max(),
              !dataPoints.isEmpty else { return .zero }

        let x = CGFloat(dataPoints.firstIndex(of: point) ?? 0) / CGFloat(dataPoints.count - 1) * size.width

        let valueRange = maxValue - minValue
        let normalizedValue = (point.value - minValue) / (valueRange == 0 ? 1 : valueRange)
        let y = size.height - (normalizedValue * size.height * 0.8 + size.height * 0.1)

        return CGPoint(x: x, y: y)
    }

    private func drawLine(in size: CGSize) -> some View {
        Path { path in
            guard let first = dataPoints.first else { return }
            let start = normalize(point: first, in: size)
            path.move(to: start)

            for point in dataPoints.dropFirst() {
                let normalized = normalize(point: point, in: size)
                path.addLine(to: normalized)
            }
        }
        .stroke(accentColor, style: StrokeStyle(lineWidth: 3, lineCap: .round, lineJoin: .round))
    }

    private func drawAreaFill(in size: CGSize) -> some View {
        Path { path in
            guard let first = dataPoints.first else { return }
            let start = normalize(point: first, in: size)
            path.move(to: start)

            for point in dataPoints.dropFirst() {
                let normalized = normalize(point: point, in: size)
                path.addLine(to: normalized)
            }

            path.addLine(to: CGPoint(x: size.width, y: size.height))
            path.addLine(to: CGPoint(x: 0, y: size.height))
            path.closeSubpath()
        }
        .fill(
            LinearGradient(
                colors: [accentColor.opacity(0.3), accentColor.opacity(0.0)],
                startPoint: .top,
                endPoint: .bottom
            )
        )
    }

    private func drawSelectionIndicator(in size: CGSize) -> some View {
        Group {
            if let point = selectedPoint, let location = normalizeOptional(point: point, in: size) {
                Circle()
                    .fill(accentColor)
                    .frame(width: 12, height: 12)
                    .position(location)

                Circle()
                    .stroke(accentColor, lineWidth: 2)
                    .frame(width: 20, height: 20)
                    .position(location)
            }
        }
    }

    private func findNearestPoint(to location: CGPoint, in size: CGSize) -> ChartDataPoint? {
        dataPoints.min { point1, point2 in
            let loc1 = normalize(point: point1, in: size)
            let loc2 = normalize(point: point2, in: size)
            let dist1 = hypot(loc1.x - location.x, loc1.y - location.y)
            let dist2 = hypot(loc2.x - location.x, loc2.y - location.y)
            return dist1 < dist2
        }
    }

    private func normalizeOptional(point: ChartDataPoint?, in size: CGSize) -> CGPoint? {
        guard let point = point else { return nil }
        return normalize(point: point, in: size)
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Trends/Components/TimeRangePicker.swift">
import SwiftUI

struct TimeRangePicker: View {
    @Binding var selectedRange: TrendsTimeRange
    let options: [TrendsTimeRange]

    var body: some View {
        HStack(spacing: 8) {
            ForEach(options, id: \.self) { option in
                Button(action: { selectedRange = option }) {
                    Text(option.rawValue)
                        .font(Typography.subheadline)
                        .fontWeight(selectedRange == option ? .semibold : .regular)
                        .foregroundColor(selectedRange == option ? .white : .primary)
                        .frame(maxWidth: .infinity)
                        .frame(height: 36)
                        .background(selectedRange == option ? Color.primaryBlue : Color.secondary.opacity(0.1))
                        .cornerRadius(8)
                }
            }
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Trends/TrendsView.swift">
import SwiftUI
import SwiftData

struct TrendsView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: TrendsViewModel

    init() {
        _viewModel = State(initialValue: TrendsViewModel(
            modelContext: ModelContext(try! ModelContainer(for: StressMeasurement.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true)))
        ))
    }

    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
                headerSection
                    .padding(.horizontal)

                hrvTrendCard
                    .padding(.horizontal)

                summaryStatsRow
                    .padding(.horizontal)

                distributionCard
                    .padding(.horizontal)

                if let insight = viewModel.weeklyInsight {
                    InsightCard(insight: PatternInsight(icon: "💡", title: "Weekly Insight", description: insight))
                        .padding(.horizontal)
                }

                ForEach(viewModel.patternInsights, id: \.title) { pattern in
                    InsightCard(insight: pattern)
                        .padding(.horizontal)
                }

                Spacer()
                    .frame(height: 100)
            }
            .padding(.top, 16)
        }
        .background(Color.backgroundLight)
        .task {
            await viewModel.loadTrendData()
        }
        .onAppear {
            viewModel = TrendsViewModel(modelContext: modelContext)
        }
    }

    private var headerSection: some View {
        VStack(spacing: 16) {
            Text("Trends")
                .font(Typography.largeTitle)
                .frame(maxWidth: .infinity, alignment: .leading)

            TimeRangePicker(
                selectedRange: $viewModel.selectedTimeRange,
                options: [.day, .week, .month, .threeMonths]
            )
            .onChange(of: viewModel.selectedTimeRange) { _, _ in
                Task { await viewModel.loadTrendData() }
            }
        }
    }

    private var hrvTrendCard: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("HRV Trend")
                .font(Typography.title2)
                .fontWeight(.bold)

            if viewModel.isLoading {
                loadingPlaceholder
            } else if viewModel.hrvData.isEmpty {
                emptyStatePlaceholder
            } else {
                LineChartView(
                    dataPoints: viewModel.hrvData,
                    accentColor: .primaryBlue,
                    showGrid: true
                )
                .frame(height: 200)
            }

            if let selectedPoint = viewModel.selectedDataPoint {
                HStack {
                    Text("\(Int(selectedPoint.value)) ms")
                        .font(.system(size: 17, weight: .semibold))

                    Text(selectedPoint.date, style: .time)
                        .font(Typography.caption1)
                        .foregroundColor(.secondary)
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(8)
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }

    private var summaryStatsRow: some View {
        HStack(spacing: 12) {
            StatCard(
                icon: "chart.bar.fill",
                value: "\(Int(viewModel.averageHRV))",
                unit: "ms",
                label: "Average"
            )

            StatCard(
                icon: "arrow.up.arrow.down",
                value: "\(Int(viewModel.hrvRange.lowerBound))-\(Int(viewModel.hrvRange.upperBound))",
                unit: "ms",
                label: "Range"
            )

            StatCard(
                icon: trendIcon,
                value: trendIcon,
                label: "Trend"
            )
            .foregroundColor(trendColor)
        }
    }

    private var distributionCard: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Stress Level Distribution")
                .font(Typography.title2)
                .fontWeight(.bold)

            let distribution = viewModel.stressDistribution

            VStack(spacing: 12) {
                DistributionBarView(
                    icon: "leaf.fill",
                    label: "Relaxed",
                    percentage: distribution.relaxed,
                    color: .stressRelaxed
                )

                DistributionBarView(
                    icon: "circle.fill",
                    label: "Normal",
                    percentage: distribution.normal,
                    color: .stressMild
                )

                DistributionBarView(
                    icon: "triangle.fill",
                    label: "Elevated",
                    percentage: distribution.elevated,
                    color: .stressModerate
                )

                DistributionBarView(
                    icon: "square.fill",
                    label: "High",
                    percentage: distribution.high,
                    color: .stressHigh
                )
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.secondary.opacity(0.1))
        )
    }

    private var loadingPlaceholder: some View {
        VStack(spacing: 12) {
            ProgressView()

            Text("Loading trend data...")
                .font(Typography.caption1)
                .foregroundColor(.secondary)
        }
        .frame(height: 200)
        .frame(maxWidth: .infinity)
    }

    private var emptyStatePlaceholder: some View {
        VStack(spacing: 12) {
            Image(systemName: "chart.xyaxis.slash")
                .font(.largeTitle)
                .foregroundColor(.secondary)

            Text("Need More Data")
                .font(Typography.headline)

            Text("Continue measuring for 7 days to see trends")
                .font(Typography.caption1)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
        .frame(height: 200)
        .frame(maxWidth: .infinity)
    }

    private var trendIcon: String {
        switch viewModel.trendDirection {
        case .up: return "↑"
        case .down: return "↓"
        case .stable: return "→"
        }
    }

    private var trendColor: Color {
        switch viewModel.trendDirection {
        case .up: return .stressRelaxed
        case .down: return .stressHigh
        case .stable: return .secondary
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Trends/TrendsViewModel.swift">
import SwiftUI
import SwiftData

@Observable
class TrendsViewModel {
    var selectedTimeRange: TrendsTimeRange = .week
    var hrvData: [ChartDataPoint] = []
    var averageHRV: Double = 0
    var hrvRange: ClosedRange<Double> = 0...0
    var trendDirection: TrendDirection = .stable
    var stressDistribution: StressDistribution = .init()
    var weeklyInsight: String?
    var patternInsights: [PatternInsight] = []
    var selectedDataPoint: ChartDataPoint?
    var isLoading = false

    private let repository: StressRepositoryProtocol

    init(modelContext: ModelContext, baselineCalculator: BaselineCalculator? = nil) {
        self.repository = StressRepository(modelContext: modelContext, baselineCalculator: baselineCalculator)
    }

    func loadTrendData() async {
        isLoading = true
        defer { isLoading = false }

        do {
            let calendar = Calendar.current
            let now = Date()
            var startDate: Date
            var groupBy: Calendar.Component

            switch selectedTimeRange {
            case .day:
                startDate = calendar.date(byAdding: .hour, value: -24, to: now) ?? now
                groupBy = .hour
            case .week:
                startDate = calendar.date(byAdding: .day, value: -7, to: now) ?? now
                groupBy = .day
            case .month:
                startDate = calendar.date(byAdding: .weekOfYear, value: -4, to: now) ?? now
                groupBy = .day
            case .threeMonths:
                startDate = calendar.date(byAdding: .month, value: -3, to: now) ?? now
                groupBy = .weekOfYear
            }

            let measurements = try await repository.fetchMeasurements(from: startDate, to: now)

            hrvData = processChartData(measurements: measurements, groupBy: groupBy)
            averageHRV = calculateAverage(from: hrvData)
            hrvRange = calculateRange(from: hrvData)
            trendDirection = calculateTrend()
            stressDistribution = calculateDistribution(measurements: measurements)
            weeklyInsight = generateWeeklyInsight(measurements: measurements)
            patternInsights = generatePatternInsights(measurements: measurements)

        } catch {
            hrvData = []
        }
    }

    private func processChartData(measurements: [StressMeasurement], groupBy: Calendar.Component) -> [ChartDataPoint] {
        let calendar = Calendar.current
        let grouped = Dictionary(grouping: measurements) { measurement in
            calendar.dateComponents([groupBy], from: measurement.timestamp)
        }

        return grouped.map { components, measurements in
            let avgHRV = measurements.map { $0.hrv }.reduce(0, +) / Double(measurements.count)
            let date = components.date ?? Date()
            return ChartDataPoint(date: date, value: avgHRV)
        }.sorted { $0.date < $1.date }
    }

    private func calculateAverage(from data: [ChartDataPoint]) -> Double {
        guard !data.isEmpty else { return 0 }
        return data.map { $0.value }.reduce(0, +) / Double(data.count)
    }

    private func calculateRange(from data: [ChartDataPoint]) -> ClosedRange<Double> {
        guard !data.isEmpty else { return 0...0 }
        let values = data.map { $0.value }
        return (values.min() ?? 0)...(values.max() ?? 0)
    }

    private func calculateTrend() -> TrendDirection {
        guard hrvData.count >= 2 else { return .stable }

        let recent = hrvData.suffix(3).map { $0.value }.reduce(0, +) / Double(min(3, hrvData.count))
        let older = hrvData.prefix(3).map { $0.value }.reduce(0, +) / Double(min(3, hrvData.count))

        let diff = recent - older
        if diff > 5 { return .up }
        if diff < -5 { return .down }
        return .stable
    }

    private func calculateDistribution(measurements: [StressMeasurement]) -> StressDistribution {
        guard !measurements.isEmpty else { return .init() }

        let total = Double(measurements.count)

        return StressDistribution(
            relaxed: Double(measurements.filter { $0.stressLevel <= 25 }.count) / total * 100,
            normal: Double(measurements.filter { $0.stressLevel > 25 && $0.stressLevel <= 50 }.count) / total * 100,
            elevated: Double(measurements.filter { $0.stressLevel > 50 && $0.stressLevel <= 75 }.count) / total * 100,
            high: Double(measurements.filter { $0.stressLevel > 75 }.count) / total * 100
        )
    }

    private func generateWeeklyInsight(measurements: [StressMeasurement]) -> String {
        guard measurements.count >= 7 else {
            return "Continue tracking for 7 days to unlock weekly insights"
        }

        let calendar = Calendar.current
        let now = Date()
        let thisWeekStart = calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: now)) ?? now
        let lastWeekStart = calendar.date(byAdding: .weekOfYear, value: -1, to: thisWeekStart) ?? thisWeekStart

        let thisWeek = measurements.filter { $0.timestamp >= thisWeekStart }
        let lastWeek = measurements.filter { $0.timestamp >= lastWeekStart && $0.timestamp < thisWeekStart }

        guard !thisWeek.isEmpty, !lastWeek.isEmpty else {
            return "Track for another week to see week-over-week changes"
        }

        let thisWeekAvg = thisWeek.map { $0.hrv }.reduce(0, +) / Double(thisWeek.count)
        let lastWeekAvg = lastWeek.map { $0.hrv }.reduce(0, +) / Double(lastWeek.count)
        let change = ((thisWeekAvg - lastWeekAvg) / lastWeekAvg) * 100

        if change > 10 {
            return "Your HRV is \(Int(change))% higher this week - great recovery!"
        } else if change < -10 {
            return "Your HRV is \(Int(abs(change)))% lower this week - prioritize rest"
        } else {
            return "Your HRV is stable compared to last week"
        }
    }

    private func generatePatternInsights(measurements: [StressMeasurement]) -> [PatternInsight] {
        var insights: [PatternInsight] = []

        let calendar = Calendar.current
        let weekdayAvg = Dictionary(grouping: measurements) { calendar.component(.weekday, from: $0.timestamp) }
            .mapValues { measurements in
                measurements.map { $0.hrv }.reduce(0, +) / Double(measurements.count)
            }

        let weekdayAvgValues = Array(weekdayAvg.values)
        if weekdayAvgValues.count >= 5 {
            let saturdayAvg = weekdayAvg[7] ?? 0
            let sundayAvg = weekdayAvg[1] ?? 0
            let weekendAvg = (saturdayAvg + sundayAvg) / 2
            let weekdayAvgCalc = weekdayAvgValues.filter { $0 != saturdayAvg && $0 != sundayAvg }.reduce(0, +) / Double(weekdayAvgValues.count - 2)

            if weekendAvg > weekdayAvgCalc * 1.1 {
                insights.append(PatternInsight(
                    icon: "📈",
                    title: "Weekly Pattern",
                    description: "Your HRV is \(Int(((weekendAvg / weekdayAvgCalc) - 1) * 100))% higher on weekends vs weekdays"
                ))
            }
        }

        if let bestDay = weekdayAvg.max(by: { $0.value < $1.value }) {
            let dayName = calendar.weekdaySymbols[bestDay.key - 1]
            insights.append(PatternInsight(
                icon: "💤",
                title: "Best Recovery Day",
                description: "\(dayName) (\(Int(bestDay.value)) ms average)"
            ))
        }

        if let bestHRV = measurements.map({ $0.hrv }).max(), let bestDate = measurements.first(where: { $0.hrv == bestHRV })?.timestamp {
            insights.append(PatternInsight(
                icon: "🏃",
                title: "Personal Best",
                description: "\(Int(bestHRV)) ms on \(formatDate(bestDate))"
            ))
        }

        return insights
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d"
        return formatter.string(from: date)
    }
}

struct ChartDataPoint: Identifiable, Equatable {
    let id = UUID()
    let date: Date
    let value: Double

    static func == (lhs: ChartDataPoint, rhs: ChartDataPoint) -> Bool {
        lhs.id == rhs.id
    }
}

struct StressDistribution {
    var relaxed: Double = 0
    var normal: Double = 0
    var elevated: Double = 0
    var high: Double = 0
}

struct PatternInsight {
    let icon: String
    let title: String
    let description: String
}

enum TrendsTimeRange: String {
    case day = "24H"
    case week = "7D"
    case month = "4W"
    case threeMonths = "3M"
}
</file>

<file path="StressMonitor/StressMonitorTests/Components/Charts/AccessibleStressTrendChartTests.swift">
import XCTest
import SwiftUI
@testable import StressMonitor

// MARK: - Accessible Stress Trend Chart Tests

final class AccessibleStressTrendChartTests: XCTestCase {

    // MARK: - Properties

    private var sampleMeasurements: [StressMeasurement]!

    // MARK: - Setup & Teardown

    override func setUp() {
        super.setUp()

        sampleMeasurements = (0..<20).map { i in
            StressMeasurement(
                timestamp: Calendar.current.date(byAdding: .hour, value: -i, to: Date())!,
                stressLevel: Double(20 + i * 3),
                hrv: 50,
                restingHeartRate: 70
            )
        }
    }

    override func tearDown() {
        sampleMeasurements = nil
        super.tearDown()
    }

    // MARK: - Time Range Tests

    func testTimeRangeDescriptions() {
        XCTAssertEqual(AccessibleStressTrendChart.TimeRange.day.description, "24 hours")
        XCTAssertEqual(AccessibleStressTrendChart.TimeRange.week.description, "7 days")
        XCTAssertEqual(AccessibleStressTrendChart.TimeRange.month.description, "4 weeks")
    }

    func testTimeRangeRawValues() {
        XCTAssertEqual(AccessibleStressTrendChart.TimeRange.day.rawValue, "24H")
        XCTAssertEqual(AccessibleStressTrendChart.TimeRange.week.rawValue, "7D")
        XCTAssertEqual(AccessibleStressTrendChart.TimeRange.month.rawValue, "4W")
    }

    func testTimeRangeAllCases() {
        let allCases = AccessibleStressTrendChart.TimeRange.allCases
        XCTAssertEqual(allCases.count, 3, "Should have exactly 3 time range options")
        XCTAssertTrue(allCases.contains(.day))
        XCTAssertTrue(allCases.contains(.week))
        XCTAssertTrue(allCases.contains(.month))
    }

    // MARK: - Empty State Tests

    func testEmptyStateHandling() {
        let emptyData: [StressMeasurement] = []
        XCTAssertTrue(emptyData.isEmpty, "Empty data should be handled gracefully")
    }

    // MARK: - Statistics Tests

    func testStatsCalculation() {
        // Given: Sample measurements with known values
        let measurements = [
            StressMeasurement(timestamp: Date(), stressLevel: 20, hrv: 50, restingHeartRate: 70),
            StressMeasurement(timestamp: Date(), stressLevel: 40, hrv: 50, restingHeartRate: 70),
            StressMeasurement(timestamp: Date(), stressLevel: 60, hrv: 50, restingHeartRate: 70),
            StressMeasurement(timestamp: Date(), stressLevel: 80, hrv: 50, restingHeartRate: 70)
        ]

        // When: Calculating stats
        let levels = measurements.map { $0.stressLevel }
        let average = levels.reduce(0, +) / Double(levels.count)
        let min = levels.min() ?? 0
        let max = levels.max() ?? 0

        // Then: Stats should be correct
        XCTAssertEqual(average, 50.0, "Average should be 50")
        XCTAssertEqual(min, 20.0, "Min should be 20")
        XCTAssertEqual(max, 80.0, "Max should be 80")
    }

    func testStatsWithSingleDataPoint() {
        let measurements = [
            StressMeasurement(timestamp: Date(), stressLevel: 42, hrv: 50, restingHeartRate: 70)
        ]

        let average = measurements.map { $0.stressLevel }.reduce(0, +) / Double(measurements.count)
        let min = measurements.map { $0.stressLevel }.min() ?? 0
        let max = measurements.map { $0.stressLevel }.max() ?? 0

        XCTAssertEqual(average, 42.0)
        XCTAssertEqual(min, 42.0)
        XCTAssertEqual(max, 42.0)
    }

    // MARK: - VoiceOver Data Table Tests

    func testDataTableRowAccessibility() {
        // Test that each measurement has required accessibility properties
        let measurement = StressMeasurement(
            timestamp: Date(),
            stressLevel: 42,
            hrv: 50,
            restingHeartRate: 70
        )

        XCTAssertNotNil(measurement.timestamp, "Timestamp should be available for VoiceOver")
        XCTAssertNotNil(measurement.stressLevel, "Stress level should be available for VoiceOver")
        XCTAssertNotNil(measurement.category, "Category should be available for VoiceOver")
    }

    func testDataTableWithMultipleMeasurements() {
        XCTAssertEqual(sampleMeasurements.count, 20, "Should have 20 measurements")

        for measurement in sampleMeasurements {
            XCTAssertGreaterThanOrEqual(measurement.stressLevel, 0, "Stress level should be non-negative")
            XCTAssertLessThanOrEqual(measurement.stressLevel, 100, "Stress level should not exceed 100")
        }
    }

    // MARK: - Reduce Motion Tests

    func testReduceMotionStaticDataEntry() {
        // With Reduce Motion enabled, chart should show static data
        // Verify that measurements can be displayed without animation
        let measurements = sampleMeasurements!

        XCTAssertFalse(measurements.isEmpty, "Should have data to display")
        XCTAssertTrue(measurements.allSatisfy { $0.stressLevel >= 0 }, "All stress levels valid")
    }

    // MARK: - Chart Scale Tests

    func testChartYAxisScale() {
        // Chart should use 0-100 scale
        let minScale = 0.0
        let maxScale = 100.0

        for measurement in sampleMeasurements {
            XCTAssertGreaterThanOrEqual(measurement.stressLevel, minScale, "Stress should be >= 0")
            XCTAssertLessThanOrEqual(measurement.stressLevel, maxScale, "Stress should be <= 100")
        }
    }

    // MARK: - Data Validation Tests

    func testMeasurementCategoryMapping() {
        let relaxed = StressMeasurement(timestamp: Date(), stressLevel: 20, hrv: 50, restingHeartRate: 70)
        let mild = StressMeasurement(timestamp: Date(), stressLevel: 40, hrv: 50, restingHeartRate: 70)
        let moderate = StressMeasurement(timestamp: Date(), stressLevel: 60, hrv: 50, restingHeartRate: 70)
        let high = StressMeasurement(timestamp: Date(), stressLevel: 80, hrv: 50, restingHeartRate: 70)

        XCTAssertEqual(relaxed.category, .relaxed)
        XCTAssertEqual(mild.category, .mild)
        XCTAssertEqual(moderate.category, .moderate)
        XCTAssertEqual(high.category, .high)
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Components/Charts/SparklineChartTests.swift">
import XCTest
import SwiftUI
@testable import StressMonitor

// MARK: - Sparkline Chart Tests

final class SparklineChartTests: XCTestCase {

    // MARK: - Properties

    private var upwardTrendData: [SparklineChart.DataPoint]!
    private var downwardTrendData: [SparklineChart.DataPoint]!
    private var stableTrendData: [SparklineChart.DataPoint]!

    // MARK: - Setup & Teardown

    override func setUp() {
        super.setUp()

        // Upward trend: values increase by 5 each day
        upwardTrendData = (0..<7).map { i in
            SparklineChart.DataPoint(
                value: Double(30 + i * 5),
                timestamp: Calendar.current.date(byAdding: .day, value: -6 + i, to: Date())!
            )
        }

        // Downward trend: values decrease by 5 each day
        downwardTrendData = (0..<7).map { i in
            SparklineChart.DataPoint(
                value: Double(70 - i * 5),
                timestamp: Calendar.current.date(byAdding: .day, value: -6 + i, to: Date())!
            )
        }

        // Stable trend: values stay around 50
        stableTrendData = (0..<7).map { i in
            SparklineChart.DataPoint(
                value: Double.random(in: 48...52),
                timestamp: Calendar.current.date(byAdding: .day, value: -6 + i, to: Date())!
            )
        }
    }

    override func tearDown() {
        upwardTrendData = nil
        downwardTrendData = nil
        stableTrendData = nil
        super.tearDown()
    }

    // MARK: - Data Point Tests

    func testDataPointCount() {
        // Sparkline should show last 7 data points
        XCTAssertEqual(upwardTrendData.count, 7, "Should have 7 data points")
        XCTAssertEqual(downwardTrendData.count, 7, "Should have 7 data points")
        XCTAssertEqual(stableTrendData.count, 7, "Should have 7 data points")
    }

    func testDataPointIdentifiable() {
        // Each data point should have unique ID
        let ids = Set(upwardTrendData.map { $0.id })
        XCTAssertEqual(ids.count, 7, "All data points should have unique IDs")
    }

    // MARK: - Trend Description Tests

    func testUpwardTrendDescription() {
        let firstValue = upwardTrendData.first?.value ?? 0
        let lastValue = upwardTrendData.last?.value ?? 0
        let change = lastValue - firstValue

        XCTAssertEqual(change, 30.0, "Upward trend should increase by 30 points")
        XCTAssertGreaterThan(change, 5, "Change should be > 5 for upward trend")
    }

    func testDownwardTrendDescription() {
        let firstValue = downwardTrendData.first?.value ?? 0
        let lastValue = downwardTrendData.last?.value ?? 0
        let change = lastValue - firstValue

        XCTAssertEqual(change, -30.0, "Downward trend should decrease by 30 points")
        XCTAssertLessThan(change, -5, "Change should be < -5 for downward trend")
    }

    func testStableTrendDescription() {
        let firstValue = stableTrendData.first?.value ?? 0
        let lastValue = stableTrendData.last?.value ?? 0
        let change = abs(lastValue - firstValue)

        XCTAssertLessThanOrEqual(change, 5, "Stable trend change should be <= 5 points")
    }

    // MARK: - Y-Axis Auto Scaling Tests

    func testYAxisDomainCalculation() {
        // Test auto-scaling with upward trend
        let values = upwardTrendData.map { $0.value }
        let min = values.min() ?? 0
        let max = values.max() ?? 100

        XCTAssertEqual(min, 30.0, "Min value should be 30")
        XCTAssertEqual(max, 60.0, "Max value should be 60")

        // Padding should be 20% of range
        let range = max - min
        let padding = range * 0.2

        XCTAssertEqual(range, 30.0)
        XCTAssertEqual(padding, 6.0)

        // Domain should be (min - padding)...(max + padding)
        let expectedMin = min - padding
        let expectedMax = max + padding

        XCTAssertEqual(expectedMin, 24.0, accuracy: 0.1)
        XCTAssertEqual(expectedMax, 66.0, accuracy: 0.1)
    }

    func testYAxisDomainWithEmptyData() {
        let emptyData: [SparklineChart.DataPoint] = []

        // Should default to 0...100 range
        let values = emptyData.map { $0.value }
        let min = values.min() ?? 0
        let max = values.max() ?? 100

        XCTAssertEqual(min, 0.0)
        XCTAssertEqual(max, 100.0)
    }

    // MARK: - Empty State Tests

    func testEmptyStateHandling() {
        let emptyData: [SparklineChart.DataPoint] = []
        XCTAssertTrue(emptyData.isEmpty, "Empty data should be handled gracefully")
    }

    // MARK: - Accessibility Tests

    func testAccessibilityHintWithSevenDataPoints() {
        // Should show "Shows 7 recent measurements"
        XCTAssertEqual(upwardTrendData.count, 7)
    }

    func testAccessibilityValueForUpwardTrend() {
        let firstValue = upwardTrendData.first?.value ?? 0
        let lastValue = upwardTrendData.last?.value ?? 0
        let change = lastValue - firstValue

        // Should describe as "Trending up by X points"
        XCTAssertGreaterThan(change, 5)
        XCTAssertEqual(Int(abs(change)), 30)
    }

    func testAccessibilityValueForDownwardTrend() {
        let firstValue = downwardTrendData.first?.value ?? 0
        let lastValue = downwardTrendData.last?.value ?? 0
        let change = lastValue - firstValue

        // Should describe as "Trending down by X points"
        XCTAssertLessThan(change, -5)
        XCTAssertEqual(Int(abs(change)), 30)
    }

    func testAccessibilityValueForStableTrend() {
        let firstValue = stableTrendData.first?.value ?? 0
        let lastValue = stableTrendData.last?.value ?? 0
        let change = abs(lastValue - firstValue)

        // Should describe as "Stable trend"
        XCTAssertLessThanOrEqual(change, 5)
    }

    // MARK: - Dimension Tests

    func testSparklineChartDimensions() {
        // Sparkline should be 60x120pt
        let expectedWidth = 120.0
        let expectedHeight = 60.0

        XCTAssertEqual(expectedWidth, 120.0)
        XCTAssertEqual(expectedHeight, 60.0)
    }

    // MARK: - Reduce Motion Tests

    func testReduceMotionSupport() {
        // Sparkline should work with reduce motion enabled
        // Static rendering should still show all data points
        XCTAssertEqual(upwardTrendData.count, 7)
        XCTAssertFalse(upwardTrendData.isEmpty)
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Components/StressCharacterCardTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - StressCharacterCard Tests

/// Tests for Phase 2: Character System - StressCharacterCard component
/// Validates rendering, VoiceOver support, and all size contexts
@MainActor
struct StressCharacterCardTests {

    // MARK: - Card Rendering Tests

    @Test func testCardRenderingSleeping() {
        let card = StressCharacterCard(
            mood: .sleeping,
            stressLevel: 5,
            hrv: 65,
            size: .dashboard
        )

        // Verify view can be created without crash
        let _ = card.body
    }

    @Test func testCardRenderingCalm() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: 70,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testCardRenderingConcerned() {
        let card = StressCharacterCard(
            mood: .concerned,
            stressLevel: 35,
            hrv: 55,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testCardRenderingWorried() {
        let card = StressCharacterCard(
            mood: .worried,
            stressLevel: 60,
            hrv: 45,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testCardRenderingOverwhelmed() {
        let card = StressCharacterCard(
            mood: .overwhelmed,
            stressLevel: 85,
            hrv: 30,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testCardRenderingAllMoods() {
        // Test all moods render without crash
        for mood in StressBuddyMood.allCases {
            let stressLevel = switch mood {
            case .sleeping: 5.0
            case .calm: 15.0
            case .concerned: 35.0
            case .worried: 60.0
            case .overwhelmed: 85.0
            }

            let card = StressCharacterCard(
                mood: mood,
                stressLevel: stressLevel,
                hrv: 50,
                size: .dashboard
            )

            let _ = card.body
        }
    }

    // MARK: - Size Context Tests

    @Test func testCardRenderingDashboardSize() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: 70,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testCardRenderingWidgetSize() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: 70,
            size: .widget
        )

        let _ = card.body
    }

    @Test func testCardRenderingWatchOSSize() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: 70,
            size: .watchOS
        )

        let _ = card.body
    }

    @Test func testCardRenderingAllSizes() {
        let sizes: [StressBuddyMood.CharacterContext] = [.dashboard, .widget, .watchOS]

        for size in sizes {
            let card = StressCharacterCard(
                mood: .calm,
                stressLevel: 15,
                hrv: 70,
                size: size
            )

            let _ = card.body
        }
    }

    // MARK: - HRV Optional Tests

    @Test func testCardRenderingWithHRV() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: 70,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testCardRenderingWithoutHRV() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: nil,
            size: .dashboard
        )

        let _ = card.body
    }

    // MARK: - Convenience Initializer Tests

    @Test func testInitFromStressResult() {
        let result = StressResult(
            level: 35,
            category: .mild,
            confidence: 0.85,
            hrv: 55,
            heartRate: 70
        )

        let card = StressCharacterCard(result: result, size: .dashboard)

        #expect(card.mood == .concerned)
        #expect(card.stressLevel == 35)
        #expect(card.hrv == 55)
        #expect(card.size == .dashboard)

        let _ = card.body
    }

    @Test func testInitWithMinimalData() {
        let card = StressCharacterCard(stressLevel: 15, size: .widget)

        #expect(card.mood == .calm)
        #expect(card.stressLevel == 15)
        #expect(card.hrv == nil)
        #expect(card.size == .widget)

        let _ = card.body
    }

    // MARK: - VoiceOver Label Tests

    @Test func testVoiceOverLabelExists() {
        // VoiceOver labels should use mood.accessibilityDescription
        let moods: [(StressBuddyMood, String)] = [
            (.sleeping, "Very relaxed, sleeping peacefully"),
            (.calm, "Calm and relaxed"),
            (.concerned, "Showing mild concern"),
            (.worried, "Moderately worried"),
            (.overwhelmed, "Feeling overwhelmed")
        ]

        for (mood, expectedDescription) in moods {
            #expect(mood.accessibilityDescription == expectedDescription)
        }
    }

    @Test func testVoiceOverValueFormatting() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15.7,
            hrv: 70,
            size: .dashboard
        )

        // Verify stress level is converted to integer for VoiceOver
        let expectedValue = "Stress level: 15"
        // Note: In actual implementation, card uses Int(stressLevel)
        #expect(Int(card.stressLevel) == 15)
    }

    @Test func testAccessibilityLabelsForAllMoods() {
        for mood in StressBuddyMood.allCases {
            let description = mood.accessibilityDescription
            #expect(!description.isEmpty, "Mood '\(mood)' must have non-empty accessibility description")
            #expect(description.count > 5, "Description should be meaningful")
        }
    }

    // MARK: - Typography Tests

    @Test func testFontSizeForDashboard() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: nil,
            size: .dashboard
        )

        // Verify fonts are appropriate for size (can't directly test Font, but verify creation)
        let _ = card.body
    }

    @Test func testFontSizeForWidget() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: nil,
            size: .widget
        )

        let _ = card.body
    }

    @Test func testFontSizeForWatchOS() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: nil,
            size: .watchOS
        )

        let _ = card.body
    }

    // MARK: - Accessory Rendering Tests

    @Test func testAccessoriesRenderForSleeping() {
        let card = StressCharacterCard(
            mood: .sleeping,
            stressLevel: 5,
            hrv: nil,
            size: .dashboard
        )

        // Sleeping has zzz accessory
        #expect(!card.mood.accessories.isEmpty)
        let _ = card.body
    }

    @Test func testNoAccessoriesRenderForCalm() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: nil,
            size: .dashboard
        )

        // Calm has no accessories
        #expect(card.mood.accessories.isEmpty)
        let _ = card.body
    }

    @Test func testAccessoriesRenderForConcerned() {
        let card = StressCharacterCard(
            mood: .concerned,
            stressLevel: 35,
            hrv: nil,
            size: .dashboard
        )

        // Concerned has star accessory
        #expect(card.mood.accessories.count == 1)
        let _ = card.body
    }

    @Test func testAccessoriesRenderForWorried() {
        let card = StressCharacterCard(
            mood: .worried,
            stressLevel: 60,
            hrv: nil,
            size: .dashboard
        )

        // Worried has drop accessory
        #expect(card.mood.accessories.count == 1)
        let _ = card.body
    }

    @Test func testMultipleAccessoriesRenderForOverwhelmed() {
        let card = StressCharacterCard(
            mood: .overwhelmed,
            stressLevel: 85,
            hrv: nil,
            size: .dashboard
        )

        // Overwhelmed has multiple accessories
        #expect(card.mood.accessories.count == 2)
        let _ = card.body
    }

    // MARK: - Character Animation Tests

    @Test func testCharacterAnimationModifierApplied() {
        // Verify character has animation modifier
        for mood in StressBuddyMood.allCases {
            let card = StressCharacterCard(
                mood: mood,
                stressLevel: 50,
                hrv: nil,
                size: .dashboard
            )

            let _ = card.body // Verify view with animation compiles
        }
    }

    // MARK: - Color Application Tests

    @Test func testMoodColorApplied() {
        for mood in StressBuddyMood.allCases {
            let card = StressCharacterCard(
                mood: mood,
                stressLevel: 50,
                hrv: nil,
                size: .dashboard
            )

            // Verify color can be created
            let _ = UIColor(card.mood.color)
            let _ = card.body
        }
    }

    // MARK: - Edge Case Tests

    @Test func testZeroStressLevel() {
        let card = StressCharacterCard(
            mood: .sleeping,
            stressLevel: 0,
            hrv: nil,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testMaxStressLevel() {
        let card = StressCharacterCard(
            mood: .overwhelmed,
            stressLevel: 100,
            hrv: nil,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testVeryLowHRV() {
        let card = StressCharacterCard(
            mood: .overwhelmed,
            stressLevel: 85,
            hrv: 10,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testVeryHighHRV() {
        let card = StressCharacterCard(
            mood: .sleeping,
            stressLevel: 5,
            hrv: 150,
            size: .dashboard
        )

        let _ = card.body
    }

    @Test func testDecimalStressLevels() {
        // Test fractional stress levels are handled correctly
        let levels = [0.1, 5.5, 15.7, 35.3, 60.9, 85.2, 99.9]

        for level in levels {
            let mood = StressBuddyMood.from(stressLevel: level)
            let card = StressCharacterCard(
                mood: mood,
                stressLevel: level,
                hrv: nil,
                size: .dashboard
            )

            let _ = card.body
        }
    }

    // MARK: - Display Name Tests

    @Test func testMoodDisplayNameShown() {
        for mood in StressBuddyMood.allCases {
            let displayName = mood.displayName
            #expect(!displayName.isEmpty)
            #expect(displayName.first?.isUppercase == true, "Display name should be capitalized")
        }
    }

    // MARK: - Monospaced Digit Tests

    @Test func testStressLevelUsesMonospacedDigits() {
        // Verify stress level text would use monospacedDigit() modifier
        // This ensures consistent width for smooth transitions
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: nil,
            size: .dashboard
        )

        let _ = card.body // Verify compilation with monospacedDigit modifier
    }

    // MARK: - HRV Formatting Tests

    @Test func testHRVFormattingWhenPresent() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: 65.7,
            size: .dashboard
        )

        // HRV should be shown as integer in ms
        #expect(card.hrv != nil)
        let hrvInt = Int(card.hrv!)
        #expect(hrvInt == 65)

        let _ = card.body
    }

    @Test func testHRVNotShownWhenNil() {
        let card = StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: nil,
            size: .dashboard
        )

        #expect(card.hrv == nil)
        let _ = card.body
    }

    // MARK: - Symbol Rendering Mode Tests

    @Test func testSymbolHierarchicalRenderingMode() {
        // Verify all symbols can be rendered in hierarchical mode
        for mood in StressBuddyMood.allCases {
            let symbolName = mood.symbol
            let image = UIImage(systemName: symbolName)

            #expect(image != nil, "Symbol '\(symbolName)' should be valid SF Symbol")
        }
    }
}

// MARK: - Character Animation Modifier Tests

@MainActor
struct CharacterAnimationModifierTests {

    @Test func testAnimationModifierCreation() {
        for mood in StressBuddyMood.allCases {
            let modifier = CharacterAnimationModifier(mood: mood)
            let _ = modifier // Verify creation
        }
    }

    @Test func testAnimationModifierAppliedToView() {
        struct TestView: View {
            var body: some View {
                Image(systemName: "figure.mind.and.body")
                    .characterAnimation(for: .calm)
            }
        }

        let view = TestView()
        let _ = view.body // Verify compilation
    }
}

// MARK: - Accessory Animation Modifier Tests

@MainActor
struct AccessoryAnimationModifierTests {

    @Test func testAccessoryModifierCreation() {
        let modifier = AccessoryAnimationModifier(index: 0)
        let _ = modifier
    }

    @Test func testAccessoryModifierWithDifferentIndices() {
        for index in 0..<5 {
            let modifier = AccessoryAnimationModifier(index: index)
            let _ = modifier
        }
    }

    @Test func testAccessoryAnimationAppliedToView() {
        struct TestView: View {
            var body: some View {
                Image(systemName: "star.fill")
                    .accessoryAnimation(index: 0)
            }
        }

        let view = TestView()
        let _ = view.body
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Mocks/MockCloudKitManager.swift">
import Foundation
import CloudKit
import UIKit
@testable import StressMonitor

@preconcurrency import CloudKit

class MockCloudKitManager: CloudKitServiceProtocol {
    var syncStatus: SyncStatus = .idle
    var lastSyncDate: Date?

    private var storedMeasurements: [CloudKitStressMeasurement] = []
    private var shouldThrowError = false
    private var errorToThrow: Error? = nil
    private var syncDelay: TimeInterval = 0

    // MARK: - Test Configuration

    func setSyncDelay(_ delay: TimeInterval) {
        self.syncDelay = delay
    }

    func setError(_ error: Error?) {
        self.shouldThrowError = error != nil
        self.errorToThrow = error
    }

    func setStoredMeasurements(_ measurements: [CloudKitStressMeasurement]) {
        self.storedMeasurements = measurements
    }

    // MARK: - CloudKitServiceProtocol

    nonisolated func saveMeasurement(_ measurement: StressMeasurement) async throws {
        if shouldThrowError { throw errorToThrow ?? CloudKitError.unknown }

        if syncDelay > 0 {
            try await Task.sleep(nanoseconds: UInt64(syncDelay * 1_000_000_000))
        }

        await MainActor.run {
            syncStatus = .syncing(progress: 0.5)
        }

        let recordID = CKRecord.ID(recordName: UUID().uuidString)

        // Create a CKRecord to extract the CloudKitStressMeasurement
        let record = CKRecord(recordType: CloudKitRecordType.stressMeasurement.rawValue, recordID: recordID)
        record["timestamp"] = measurement.timestamp
        record["stressLevel"] = measurement.stressLevel
        record["hrv"] = measurement.hrv
        record["restingHeartRate"] = measurement.restingHeartRate
        record["category"] = measurement.category.rawValue
        record["confidences"] = measurement.confidences ?? []
        record["deviceID"] = UIDevice.current.identifierForVendor?.uuidString ?? "test-device"
        record["isDeleted"] = false

        guard let ckMeasurement = CloudKitStressMeasurement(record: record) else {
            throw CloudKitError.unknown
        }

        await MainActor.run {
            storedMeasurements.append(ckMeasurement)
            syncStatus = .success
            lastSyncDate = Date()
        }
    }

    nonisolated func fetchMeasurements(since date: Date?) async throws -> [StressMeasurement] {
        if shouldThrowError { throw errorToThrow ?? CloudKitError.unknown }

        if syncDelay > 0 {
            try await Task.sleep(nanoseconds: UInt64(syncDelay * 1_000_000_000))
        }

        await MainActor.run {
            syncStatus = .syncing(progress: 0.5)
        }

        let filtered = await storedMeasurements.filter { measurement in
            if let since = date {
                return measurement.timestamp >= since
            }
            return true
        }

        await MainActor.run {
            syncStatus = .success
        }

        return filtered.map { ckMeasurement in
            StressMeasurement(
                timestamp: ckMeasurement.timestamp,
                stressLevel: ckMeasurement.stressLevel,
                hrv: ckMeasurement.hrv,
                restingHeartRate: ckMeasurement.restingHeartRate,
                confidences: ckMeasurement.confidences
            )
        }
    }

    nonisolated func deleteMeasurement(_ measurement: StressMeasurement) async throws {
        if shouldThrowError { throw errorToThrow ?? CloudKitError.unknown }

        await MainActor.run {
            storedMeasurements.removeAll { $0.timestamp == measurement.timestamp }
        }
    }

    nonisolated func sync() async throws {
        if shouldThrowError { throw errorToThrow ?? CloudKitError.unknown }

        await MainActor.run {
            syncStatus = .syncing(progress: 0.5)
        }

        if syncDelay > 0 {
            try await Task.sleep(nanoseconds: UInt64(syncDelay * 1_000_000_000))
        }

        await MainActor.run {
            syncStatus = .success
            lastSyncDate = Date()
        }
    }

    nonisolated func setupPushSubscription() async throws {
        // Mock implementation
    }

    nonisolated func checkAccountStatus() async throws -> CloudKitAccountStatus {
        return .available
    }

    // MARK: - Test Helpers

    func reset() {
        storedMeasurements.removeAll()
        syncStatus = .idle
        lastSyncDate = nil
        shouldThrowError = false
        errorToThrow = nil
        syncDelay = 0
    }
}

enum CloudKitError: Error {
    case unknown
    case networkFailure
    case quotaExceeded
    case accountUnavailable
}
</file>

<file path="StressMonitor/StressMonitorTests/Models/StressBuddyMoodTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - StressBuddyMood Tests

/// Tests for Phase 2: Character System - StressBuddyMood model
/// Validates mood mapping, accessories, symbols, size contexts, and accessibility
struct StressBuddyMoodTests {

    // MARK: - Mood Mapping Tests

    @Test func testMoodMappingSleeping() {
        // Stress level 0-10 should map to sleeping
        #expect(StressBuddyMood.from(stressLevel: 0) == .sleeping)
        #expect(StressBuddyMood.from(stressLevel: 5) == .sleeping)
        #expect(StressBuddyMood.from(stressLevel: 9.9) == .sleeping)
    }

    @Test func testMoodMappingCalm() {
        // Stress level 10-25 should map to calm
        #expect(StressBuddyMood.from(stressLevel: 10) == .calm)
        #expect(StressBuddyMood.from(stressLevel: 15) == .calm)
        #expect(StressBuddyMood.from(stressLevel: 24.9) == .calm)
    }

    @Test func testMoodMappingConcerned() {
        // Stress level 25-50 should map to concerned
        #expect(StressBuddyMood.from(stressLevel: 25) == .concerned)
        #expect(StressBuddyMood.from(stressLevel: 35) == .concerned)
        #expect(StressBuddyMood.from(stressLevel: 49.9) == .concerned)
    }

    @Test func testMoodMappingWorried() {
        // Stress level 50-75 should map to worried
        #expect(StressBuddyMood.from(stressLevel: 50) == .worried)
        #expect(StressBuddyMood.from(stressLevel: 60) == .worried)
        #expect(StressBuddyMood.from(stressLevel: 74.9) == .worried)
    }

    @Test func testMoodMappingOverwhelmed() {
        // Stress level 75-100 should map to overwhelmed
        #expect(StressBuddyMood.from(stressLevel: 75) == .overwhelmed)
        #expect(StressBuddyMood.from(stressLevel: 85) == .overwhelmed)
        #expect(StressBuddyMood.from(stressLevel: 100) == .overwhelmed)
    }

    @Test func testMoodMappingBoundaries() {
        // Test exact boundaries
        #expect(StressBuddyMood.from(stressLevel: 0) == .sleeping)
        #expect(StressBuddyMood.from(stressLevel: 10) == .calm)
        #expect(StressBuddyMood.from(stressLevel: 25) == .concerned)
        #expect(StressBuddyMood.from(stressLevel: 50) == .worried)
        #expect(StressBuddyMood.from(stressLevel: 75) == .overwhelmed)
    }

    // MARK: - Accessory Mapping Tests

    @Test func testAccessorySleepingHasZZZ() {
        let mood = StressBuddyMood.sleeping
        #expect(mood.accessories.contains("zzz"))
        #expect(mood.accessories.count == 1)
    }

    @Test func testAccessoryCalmHasNoAccessories() {
        let mood = StressBuddyMood.calm
        #expect(mood.accessories.isEmpty)
    }

    @Test func testAccessoryConcernedHasStars() {
        let mood = StressBuddyMood.concerned
        #expect(mood.accessories.contains("star.fill"))
        #expect(mood.accessories.count == 1)
    }

    @Test func testAccessoryWorriedHasDrops() {
        let mood = StressBuddyMood.worried
        #expect(mood.accessories.contains("drop.fill"))
        #expect(mood.accessories.count == 1)
    }

    @Test func testAccessoryOverwhelmedHasDropsAndStars() {
        let mood = StressBuddyMood.overwhelmed
        #expect(mood.accessories.contains("drop.fill"))
        #expect(mood.accessories.contains("star.fill"))
        #expect(mood.accessories.count == 2)
    }

    // MARK: - Symbol Assignment Tests

    @Test func testSymbolSleeping() {
        let mood = StressBuddyMood.sleeping
        #expect(mood.symbol == "moon.zzz.fill")
    }

    @Test func testSymbolCalm() {
        let mood = StressBuddyMood.calm
        #expect(mood.symbol == "figure.mind.and.body")
    }

    @Test func testSymbolConcerned() {
        let mood = StressBuddyMood.concerned
        #expect(mood.symbol == "figure.walk.circle")
    }

    @Test func testSymbolWorried() {
        let mood = StressBuddyMood.worried
        #expect(mood.symbol == "exclamationmark.triangle.fill")
    }

    @Test func testSymbolOverwhelmed() {
        let mood = StressBuddyMood.overwhelmed
        #expect(mood.symbol == "flame.fill")
    }

    @Test func testAllSymbolsAreValidSFSymbols() {
        // Verify all symbols can be loaded as SF Symbols
        for mood in StressBuddyMood.allCases {
            let image = UIImage(systemName: mood.symbol)
            #expect(image != nil, "Symbol '\(mood.symbol)' for mood '\(mood)' should be valid")
        }
    }

    // MARK: - Size Context Tests

    @Test func testDashboardSize() {
        let mood = StressBuddyMood.calm
        let size = mood.symbolSize(for: .dashboard)
        #expect(size == 120)
    }

    @Test func testWidgetSize() {
        let mood = StressBuddyMood.calm
        let size = mood.symbolSize(for: .widget)
        #expect(size == 80)
    }

    @Test func testWatchOSSize() {
        let mood = StressBuddyMood.calm
        let size = mood.symbolSize(for: .watchOS)
        #expect(size == 60)
    }

    @Test func testAccessorySizeRelativeToMainSymbol() {
        // Accessory should be 30% of main symbol size
        let mood = StressBuddyMood.concerned

        let dashboardMain = mood.symbolSize(for: .dashboard)
        let dashboardAccessory = mood.accessorySize(for: .dashboard)
        #expect(dashboardAccessory == dashboardMain * 0.3)

        let widgetMain = mood.symbolSize(for: .widget)
        let widgetAccessory = mood.accessorySize(for: .widget)
        #expect(widgetAccessory == widgetMain * 0.3)

        let watchMain = mood.symbolSize(for: .watchOS)
        let watchAccessory = mood.accessorySize(for: .watchOS)
        #expect(watchAccessory == watchMain * 0.3)
    }

    @Test func testSizeContextsAreOrderedCorrectly() {
        // Dashboard should be largest, watchOS smallest
        let mood = StressBuddyMood.calm
        let dashboard = mood.symbolSize(for: .dashboard)
        let widget = mood.symbolSize(for: .widget)
        let watch = mood.symbolSize(for: .watchOS)

        #expect(dashboard > widget)
        #expect(widget > watch)
    }

    // MARK: - Accessibility Tests

    @Test func testAccessibilityDescriptionSleeping() {
        let mood = StressBuddyMood.sleeping
        #expect(mood.accessibilityDescription == "Very relaxed, sleeping peacefully")
    }

    @Test func testAccessibilityDescriptionCalm() {
        let mood = StressBuddyMood.calm
        #expect(mood.accessibilityDescription == "Calm and relaxed")
    }

    @Test func testAccessibilityDescriptionConcerned() {
        let mood = StressBuddyMood.concerned
        #expect(mood.accessibilityDescription == "Showing mild concern")
    }

    @Test func testAccessibilityDescriptionWorried() {
        let mood = StressBuddyMood.worried
        #expect(mood.accessibilityDescription == "Moderately worried")
    }

    @Test func testAccessibilityDescriptionOverwhelmed() {
        let mood = StressBuddyMood.overwhelmed
        #expect(mood.accessibilityDescription == "Feeling overwhelmed")
    }

    @Test func testAllMoodsHaveNonEmptyAccessibilityDescriptions() {
        for mood in StressBuddyMood.allCases {
            #expect(!mood.accessibilityDescription.isEmpty,
                   "Mood '\(mood)' must have accessibility description")
        }
    }

    // MARK: - Display Name Tests

    @Test func testDisplayNameFormatting() {
        #expect(StressBuddyMood.sleeping.displayName == "Sleeping")
        #expect(StressBuddyMood.calm.displayName == "Calm")
        #expect(StressBuddyMood.concerned.displayName == "Concerned")
        #expect(StressBuddyMood.worried.displayName == "Worried")
        #expect(StressBuddyMood.overwhelmed.displayName == "Overwhelmed")
    }

    // MARK: - Color Mapping Tests

    @Test func testColorMappingSleeping() {
        let mood = StressBuddyMood.sleeping
        // Sleeping should use relaxed category color
        let _ = UIColor(mood.color)
    }

    @Test func testColorMappingCalm() {
        let mood = StressBuddyMood.calm
        // Calm should use relaxed category color
        let _ = UIColor(mood.color)
    }

    @Test func testColorMappingConcerned() {
        let mood = StressBuddyMood.concerned
        // Concerned should use mild category color
        let _ = UIColor(mood.color)
    }

    @Test func testColorMappingWorried() {
        let mood = StressBuddyMood.worried
        // Worried should use moderate category color
        let _ = UIColor(mood.color)
    }

    @Test func testColorMappingOverwhelmed() {
        let mood = StressBuddyMood.overwhelmed
        // Overwhelmed should use high category color
        let _ = UIColor(mood.color)
    }

    @Test func testAllMoodsHaveValidColors() {
        for mood in StressBuddyMood.allCases {
            let uiColor = UIColor(mood.color)
            #expect(uiColor != nil, "Mood '\(mood)' must have valid color")
        }
    }

    // MARK: - Edge Case Tests

    @Test func testNegativeStressLevel() {
        // Negative values should still map to a valid mood (sleeping)
        let mood = StressBuddyMood.from(stressLevel: -10)
        #expect(mood == .sleeping)
    }

    @Test func testExtremelyHighStressLevel() {
        // Values over 100 should map to overwhelmed
        let mood = StressBuddyMood.from(stressLevel: 999)
        #expect(mood == .overwhelmed)
    }

    @Test func testAllCasesCount() {
        // Verify we have exactly 5 mood states
        #expect(StressBuddyMood.allCases.count == 5)
    }

    // MARK: - Sendable Protocol Conformance

    @Test func testSendableConformance() {
        // StressBuddyMood should be Sendable for concurrency safety
        let mood: StressBuddyMood = .calm
        Task {
            let _ = mood // Should compile without warnings
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Theme/FontWellnessTypeTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - Font Wellness Type Tests
struct FontWellnessTypeTests {

    // MARK: - Font Availability Tests

    @Test func testLoraFontAvailabilityCheck() {
        // Test the availability check itself works
        let isAvailable = WellnessFontLoader.isLoraAvailable
        // Should return true or false without crashing
        let _ = isAvailable
    }

    @Test func testRalewayFontAvailabilityCheck() {
        let isAvailable = WellnessFontLoader.isRalewayAvailable
        let _ = isAvailable
    }

    @Test func testAllFontsAvailabilityCheck() {
        let allAvailable = WellnessFontLoader.areAllFontsAvailable
        let _ = allAvailable
    }

    @Test func testAvailableFamiliesList() {
        let families = WellnessFontLoader.availableFamilies
        #expect(!families.isEmpty)
        #expect(families.contains("System Font"))
    }

    // MARK: - Font Creation Tests

    @Test func testHeroNumberFontCreation() {
        let font = Font.WellnessType.heroNumber
        // Verify font doesn't crash when created
        let _ = font
    }

    @Test func testLargeMetricFontCreation() {
        let font = Font.WellnessType.largeMetric
        let _ = font
    }

    @Test func testCardTitleFontCreation() {
        let font = Font.WellnessType.cardTitle
        let _ = font
    }

    @Test func testSectionHeaderFontCreation() {
        let font = Font.WellnessType.sectionHeader
        let _ = font
    }

    @Test func testBodyFontCreation() {
        let font = Font.WellnessType.body
        let _ = font
    }

    @Test func testBodyEmphasizedFontCreation() {
        let font = Font.WellnessType.bodyEmphasized
        let _ = font
    }

    @Test func testCaptionFontCreation() {
        let font = Font.WellnessType.caption
        let _ = font
    }

    @Test func testCaption2FontCreation() {
        let font = Font.WellnessType.caption2
        let _ = font
    }

    // MARK: - System Fallback Tests

    @Test func testSystemFallbackLargeTitle() {
        let font = Font.SystemFallback.largeTitle
        let _ = font
    }

    @Test func testSystemFallbackTitle() {
        let font = Font.SystemFallback.title
        let _ = font
    }

    @Test func testSystemFallbackTitle2() {
        let font = Font.SystemFallback.title2
        let _ = font
    }

    @Test func testSystemFallbackBody() {
        let font = Font.SystemFallback.body
        let _ = font
    }

    @Test func testSystemFallbackCaption() {
        let font = Font.SystemFallback.caption
        let _ = font
    }

    // MARK: - Font Fallback Behavior Tests

    @Test func testFontFallbackToSystemWhenCustomUnavailable() {
        // When custom fonts are unavailable, the fonts should fall back to system fonts
        // This is tested implicitly - if fonts crash when custom fonts are missing,
        // this test will fail
        let allFonts = [
            Font.WellnessType.heroNumber,
            Font.WellnessType.largeMetric,
            Font.WellnessType.cardTitle,
            Font.WellnessType.sectionHeader,
            Font.WellnessType.body,
            Font.WellnessType.bodyEmphasized,
            Font.WellnessType.caption,
            Font.WellnessType.caption2
        ]

        for font in allFonts {
            let _ = font // Should not crash
        }
    }

    // MARK: - Dynamic Type Tests

    @Test func testDynamicTypeSizeRange() {
        // Test that Dynamic Type sizes are properly bounded
        // We can't easily test the actual scaling in unit tests,
        // but we can verify the modifiers don't crash

        let sizes: [DynamicTypeSize] = [
            .xSmall,
            .small,
            .medium,
            .large,
            .xLarge,
            .xxLarge,
            .xxxLarge,
            .accessibility1,
            .accessibility2,
            .accessibility3
        ]

        for size in sizes {
            let _ = size
        }
    }

    // MARK: - Vietnamese Character Support Test

    @Test func testVietnameseCharacterSupport() {
        // Test that fonts can handle Vietnamese diacritical marks
        let vietnameseText = "Căng thẳng"
        let attributedString = NSAttributedString(string: vietnameseText)
        #expect(!attributedString.string.isEmpty)
        #expect(attributedString.string == vietnameseText)
    }

    // MARK: - Font Status Debugging

    @Test func testPrintFontStatusDoesNotCrash() {
        // Verify the debug helper doesn't crash
        WellnessFontLoader.printFontStatus()
    }

    // MARK: - Minimum Scale Factor Tests

    @Test func testMinimumScaleFactorIs70Percent() {
        // This is a documentation test - the actual modifier is tested in UI tests
        // We document that minimum scale factor should be 0.7 (70%)
        let expectedMinScale = 0.7
        #expect(expectedMinScale == 0.7)
    }

    // MARK: - Line Limit Tests

    @Test func testSingleLineModifierExists() {
        // Test that the single line modifier is available
        // Actual behavior tested in UI tests
        let testView = Text("Test")
        let _ = testView.accessibleWellnessTypeSingleLine()
    }

    @Test func testMultiLineModifierExists() {
        let testView = Text("Test")
        let _ = testView.accessibleWellnessType()
    }

    @Test func testCustomLineCountModifierExists() {
        let testView = Text("Test")
        let _ = testView.accessibleWellnessType(lines: 3)
    }
}

// MARK: - Font Size Tests
struct FontSizeTests {

    @Test func testAllDynamicTypeSizesSupported() {
        // Test all Dynamic Type sizes from XS to AX3
        let allSizes: [DynamicTypeSize] = [
            .xSmall,      // XS
            .small,       // S
            .medium,      // M
            .large,       // L
            .xLarge,      // XL
            .xxLarge,     // XXL
            .xxxLarge,    // XXXL
            .accessibility1,  // AX1
            .accessibility2,  // AX2
            .accessibility3   // AX3
        ]

        for size in allSizes {
            // Verify all sizes are valid
            let _ = size
        }

        // We support up to accessibility3
        #expect(allSizes.count == 10)
    }

    @Test func testAccessibility3IsMaximumSupported() {
        // Per requirements, we support up to AX3
        // The modifier should cap at .accessibility3
        let maxSize = DynamicTypeSize.accessibility3
        let _ = maxSize
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Theme/GradientsTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - Gradients Tests
struct GradientsTests {

    // MARK: - Calm Wellness Gradient Tests

    @Test func testCalmWellnessGradientExists() {
        let gradient = LinearGradient.calmWellness
        // Verify gradient can be created without crashing
        let _ = gradient
    }

    @Test func testCalmWellnessGradientHasCorrectDirection() {
        let gradient = LinearGradient.calmWellness
        // The gradient should go from top-leading to bottom-trailing
        // We can't directly test the direction in unit tests,
        // but we verify it doesn't crash when accessed
        let _ = gradient
    }

    // MARK: - Stress Spectrum Gradient Tests

    @Test func testStressSpectrumForRelaxed() {
        let gradient = LinearGradient.stressSpectrum(for: .relaxed)
        let _ = gradient
    }

    @Test func testStressSpectrumForMild() {
        let gradient = LinearGradient.stressSpectrum(for: .mild)
        let _ = gradient
    }

    @Test func testStressSpectrumForModerate() {
        let gradient = LinearGradient.stressSpectrum(for: .moderate)
        let _ = gradient
    }

    @Test func testStressSpectrumForHigh() {
        let gradient = LinearGradient.stressSpectrum(for: .high)
        let _ = gradient
    }

    @Test func testAllStressCategoriesHaveGradients() {
        // Every stress category should have a gradient
        for category in StressCategory.allCases {
            let gradient = LinearGradient.stressSpectrum(for: category)
            let _ = gradient
        }
    }

    // MARK: - Stress Background Tint Tests

    @Test func testStressBackgroundTintForRelaxed() {
        let gradient = LinearGradient.stressBackgroundTint(for: .relaxed)
        let _ = gradient
    }

    @Test func testStressBackgroundTintForMild() {
        let gradient = LinearGradient.stressBackgroundTint(for: .mild)
        let _ = gradient
    }

    @Test func testStressBackgroundTintForModerate() {
        let gradient = LinearGradient.stressBackgroundTint(for: .moderate)
        let _ = gradient
    }

    @Test func testStressBackgroundTintForHigh() {
        let gradient = LinearGradient.stressBackgroundTint(for: .high)
        let _ = gradient
    }

    @Test func testAllStressCategoriesHaveBackgroundTints() {
        for category in StressCategory.allCases {
            let gradient = LinearGradient.stressBackgroundTint(for: category)
            let _ = gradient
        }
    }

    // MARK: - Special Purpose Gradient Tests

    @Test func testMindfulnessGradientExists() {
        let gradient = LinearGradient.mindfulness
        let _ = gradient
    }

    @Test func testRelaxationGradientExists() {
        let gradient = LinearGradient.relaxation
        let _ = gradient
    }

    // MARK: - View Modifier Tests

    @Test func testWellnessBackgroundModifier() {
        let view = Text("Test")
        let modifiedView = view.wellnessBackground()
        let _ = modifiedView
    }

    @Test func testStressBackgroundModifierForAllCategories() {
        for category in StressCategory.allCases {
            let view = Text("Test")
            let modifiedView = view.stressBackground(for: category)
            let _ = modifiedView
        }
    }

    @Test func testStressCardModifierForAllCategories() {
        for category in StressCategory.allCases {
            let view = Text("Test")
            let modifiedView = view.stressCard(for: category)
            let _ = modifiedView
        }
    }

    @Test func testStressCardModifierWithCustomBaseColor() {
        let view = Text("Test")
        let modifiedView = view.stressCard(
            for: .relaxed,
            baseColor: Color.Wellness.surfaceLight
        )
        let _ = modifiedView
    }

    // MARK: - Gradient Opacity Tests

    @Test func testGradientOpacityIsSubtle() {
        // Document that gradients should use subtle opacity values
        // Actual opacity values tested in UI tests

        // Calm wellness uses 0.1, 0.05 opacity
        let calmGradient = LinearGradient.calmWellness
        let _ = calmGradient

        // Stress spectrum uses 0.6, 0.3, 0.1 opacity
        let stressGradient = LinearGradient.stressSpectrum(for: .relaxed)
        let _ = stressGradient

        // Background tints use 0.08 opacity
        let tintGradient = LinearGradient.stressBackgroundTint(for: .relaxed)
        let _ = tintGradient
    }

    // MARK: - Gradient Combination Tests

    @Test func testGradientsCanBeCombined() {
        // Test that multiple gradients can be layered
        let view = Text("Test")
            .wellnessBackground()
            .stressBackground(for: .relaxed)

        let _ = view
    }

    @Test func testStressCardIncludesBaseColorAndGradient() {
        // Stress card should combine base color with gradient overlay
        let view = Text("Test")
            .stressCard(for: .mild, baseColor: Color.Wellness.surface)

        let _ = view
    }
}

// MARK: - Gradient Color Mapping Tests
struct GradientColorMappingTests {

    @Test func testStressSpectrumUsesCorrectBaseColor() {
        // Each stress category should use its corresponding color
        let relaxedGradient = LinearGradient.stressSpectrum(for: .relaxed)
        let mildGradient = LinearGradient.stressSpectrum(for: .mild)
        let moderateGradient = LinearGradient.stressSpectrum(for: .moderate)
        let highGradient = LinearGradient.stressSpectrum(for: .high)

        // Verify all gradients can be created
        let _ = relaxedGradient
        let _ = mildGradient
        let _ = moderateGradient
        let _ = highGradient
    }

    @Test func testBackgroundTintUsesCorrectBaseColor() {
        let relaxedTint = LinearGradient.stressBackgroundTint(for: .relaxed)
        let mildTint = LinearGradient.stressBackgroundTint(for: .mild)
        let moderateTint = LinearGradient.stressBackgroundTint(for: .moderate)
        let highTint = LinearGradient.stressBackgroundTint(for: .high)

        let _ = relaxedTint
        let _ = mildTint
        let _ = moderateTint
        let _ = highTint
    }
}

// MARK: - Gradient Corner Radius Tests
struct GradientCornerRadiusTests {

    @Test func testStressCardHasRoundedCorners() {
        // Stress card modifier should include rounded corners (12pt radius)
        let view = Text("Test")
            .stressCard(for: .relaxed)

        let _ = view
    }

    @Test func testCornerRadiusConsistency() {
        // All stress cards should have the same corner radius
        for category in StressCategory.allCases {
            let view = Text("Test")
                .stressCard(for: category)
            let _ = view
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Utilities/AnimationWellnessTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - Animation+Wellness Tests

/// Tests for Phase 2: Character System - Animation utilities
/// Validates Reduce Motion support and all animation types
struct AnimationWellnessTests {

    // MARK: - Reduce Motion Detection Tests

    @Test func testWellnessAnimationWithReduceMotionDisabled() {
        let animation = Animation.wellness(duration: 1.0, reduceMotion: false)
        #expect(animation != nil, "Animation should exist when Reduce Motion is disabled")
    }

    @Test func testWellnessAnimationWithReduceMotionEnabled() {
        let animation = Animation.wellness(duration: 1.0, reduceMotion: true)
        #expect(animation == nil, "Animation should be nil when Reduce Motion is enabled")
    }

    @Test func testBreathingAnimationWithReduceMotionDisabled() {
        let animation = Animation.breathing(reduceMotion: false)
        #expect(animation != nil, "Breathing animation should exist when Reduce Motion is disabled")
    }

    @Test func testBreathingAnimationWithReduceMotionEnabled() {
        let animation = Animation.breathing(reduceMotion: true)
        #expect(animation == nil, "Breathing animation should be nil when Reduce Motion is enabled")
    }

    @Test func testFidgetAnimationWithReduceMotionDisabled() {
        let animation = Animation.fidget(reduceMotion: false)
        #expect(animation != nil, "Fidget animation should exist when Reduce Motion is disabled")
    }

    @Test func testFidgetAnimationWithReduceMotionEnabled() {
        let animation = Animation.fidget(reduceMotion: true)
        #expect(animation == nil, "Fidget animation should be nil when Reduce Motion is enabled")
    }

    @Test func testShakeAnimationWithReduceMotionDisabled() {
        let animation = Animation.shake(reduceMotion: false)
        #expect(animation != nil, "Shake animation should exist when Reduce Motion is disabled")
    }

    @Test func testShakeAnimationWithReduceMotionEnabled() {
        let animation = Animation.shake(reduceMotion: true)
        #expect(animation == nil, "Shake animation should be nil when Reduce Motion is enabled")
    }

    @Test func testDizzyAnimationWithReduceMotionDisabled() {
        let animation = Animation.dizzy(reduceMotion: false)
        #expect(animation != nil, "Dizzy animation should exist when Reduce Motion is disabled")
    }

    @Test func testDizzyAnimationWithReduceMotionEnabled() {
        let animation = Animation.dizzy(reduceMotion: true)
        #expect(animation == nil, "Dizzy animation should be nil when Reduce Motion is enabled")
    }

    // MARK: - Animation Type Tests

    @Test func testWellnessAnimationType() {
        // Wellness animation should be easeInOut
        let animation = Animation.wellness(duration: 2.0, reduceMotion: false)
        #expect(animation != nil)
        // Note: We can't directly test Animation properties, but we verify it creates successfully
    }

    @Test func testBreathingAnimationIsRepeating() {
        // Breathing should create a repeating animation
        let animation = Animation.breathing(reduceMotion: false)
        #expect(animation != nil)
        // Breathing uses repeatForever(autoreverses: true)
    }

    @Test func testFidgetAnimationDuration() {
        // Fidget should be quick (0.5s)
        let animation = Animation.fidget(reduceMotion: false)
        #expect(animation != nil)
    }

    @Test func testShakeAnimationRepeats() {
        // Shake should repeat 3 times
        let animation = Animation.shake(reduceMotion: false)
        #expect(animation != nil)
        // Uses repeatCount(3, autoreverses: true)
    }

    @Test func testDizzyAnimationIsContinuous() {
        // Dizzy should be continuous rotation
        let animation = Animation.dizzy(reduceMotion: false)
        #expect(animation != nil)
        // Uses linear + repeatForever(autoreverses: false)
    }

    // MARK: - Default Parameter Tests

    @Test func testWellnessAnimationDefaultsToMotionEnabled() {
        // Default should assume Reduce Motion is disabled
        let animation = Animation.wellness(duration: 1.0)
        #expect(animation != nil)
    }

    @Test func testBreathingAnimationDefaultsToMotionEnabled() {
        let animation = Animation.breathing()
        #expect(animation != nil)
    }

    @Test func testFidgetAnimationDefaultsToMotionEnabled() {
        let animation = Animation.fidget()
        #expect(animation != nil)
    }

    @Test func testShakeAnimationDefaultsToMotionEnabled() {
        let animation = Animation.shake()
        #expect(animation != nil)
    }

    @Test func testDizzyAnimationDefaultsToMotionEnabled() {
        let animation = Animation.dizzy()
        #expect(animation != nil)
    }

    // MARK: - Accessibility Transition Tests

    @Test func testAccessibleOpacityTransitionWithMotionDisabled() {
        let transition = AnyTransition.accessibleOpacity(reduceMotion: true)
        // Should return identity (no transition)
        // Note: Can't directly compare AnyTransition, but verify it creates
        let _ = transition
    }

    @Test func testAccessibleOpacityTransitionWithMotionEnabled() {
        let transition = AnyTransition.accessibleOpacity(reduceMotion: false)
        // Should return opacity transition
        let _ = transition
    }

    @Test func testAccessibleScaleTransitionWithMotionDisabled() {
        let transition = AnyTransition.accessibleScale(reduceMotion: true)
        let _ = transition
    }

    @Test func testAccessibleScaleTransitionWithMotionEnabled() {
        let transition = AnyTransition.accessibleScale(reduceMotion: false)
        let _ = transition
    }

    @Test func testAccessibleSlideTransitionWithMotionDisabled() {
        let transition = AnyTransition.accessibleSlide(reduceMotion: true, edge: .bottom)
        let _ = transition
    }

    @Test func testAccessibleSlideTransitionWithMotionEnabled() {
        let transition = AnyTransition.accessibleSlide(reduceMotion: false, edge: .bottom)
        let _ = transition
    }

    @Test func testAccessibleSlideTransitionAllEdges() {
        // Test all edge variations
        let _ = AnyTransition.accessibleSlide(reduceMotion: false, edge: .top)
        let _ = AnyTransition.accessibleSlide(reduceMotion: false, edge: .bottom)
        let _ = AnyTransition.accessibleSlide(reduceMotion: false, edge: .leading)
        let _ = AnyTransition.accessibleSlide(reduceMotion: false, edge: .trailing)
    }

    // MARK: - Animation Duration Tests

    @Test func testCustomWellnessDuration() {
        // Test custom duration parameter
        let shortAnimation = Animation.wellness(duration: 0.3, reduceMotion: false)
        let longAnimation = Animation.wellness(duration: 3.0, reduceMotion: false)

        #expect(shortAnimation != nil)
        #expect(longAnimation != nil)
    }

    // MARK: - Integration Tests

    @Test func testAllAnimationTypesWorkWithReduceMotion() {
        // Verify all animation types properly handle both states
        let motionStates = [true, false]

        for reduceMotion in motionStates {
            let wellness = Animation.wellness(reduceMotion: reduceMotion)
            let breathing = Animation.breathing(reduceMotion: reduceMotion)
            let fidget = Animation.fidget(reduceMotion: reduceMotion)
            let shake = Animation.shake(reduceMotion: reduceMotion)
            let dizzy = Animation.dizzy(reduceMotion: reduceMotion)

            if reduceMotion {
                #expect(wellness == nil)
                #expect(breathing == nil)
                #expect(fidget == nil)
                #expect(shake == nil)
                #expect(dizzy == nil)
            } else {
                #expect(wellness != nil)
                #expect(breathing != nil)
                #expect(fidget != nil)
                #expect(shake != nil)
                #expect(dizzy != nil)
            }
        }
    }

    // MARK: - View Modifier Tests

    @Test func testReduceMotionAwareModifierCreation() {
        // Test that ReduceMotionAwareModifier can be created
        struct TestView: View {
            var body: some View {
                Text("Test")
                    .animateIfMotionAllowed(.easeInOut, value: true)
            }
        }

        let view = TestView()
        let _ = view // Verify view compiles
    }

    @Test func testAnimateIfMotionAllowedModifier() {
        // Test the view extension
        struct TestView: View {
            @State var value = false

            var body: some View {
                Rectangle()
                    .fill(.blue)
                    .animateIfMotionAllowed(.easeInOut, value: value)
            }
        }

        let view = TestView()
        let _ = view // Verify view compiles
    }

    // MARK: - Edge Case Tests

    @Test func testZeroDurationWellnessAnimation() {
        let animation = Animation.wellness(duration: 0, reduceMotion: false)
        #expect(animation != nil, "Should handle zero duration")
    }

    @Test func testNegativeDurationWellnessAnimation() {
        // Negative duration should still create animation (SwiftUI will handle)
        let animation = Animation.wellness(duration: -1.0, reduceMotion: false)
        #expect(animation != nil)
    }

    @Test func testVeryLongDurationWellnessAnimation() {
        let animation = Animation.wellness(duration: 100.0, reduceMotion: false)
        #expect(animation != nil, "Should handle very long duration")
    }
}

// MARK: - Reduce Motion-Aware Modifier Integration Tests

@MainActor
struct ReduceMotionModifierIntegrationTests {

    @Test func testModifierWithEnvironmentValue() {
        struct TestView: View {
            @Environment(\.accessibilityReduceMotion) var reduceMotion
            @State var isActive = false

            var body: some View {
                Text("Test")
                    .modifier(ReduceMotionAwareModifier(
                        animation: .easeInOut,
                        value: isActive
                    ))
            }
        }

        let view = TestView()
        let _ = view // Verify compilation
    }

    @Test func testModifierWithNilAnimation() {
        struct TestView: View {
            @State var isActive = false

            var body: some View {
                Text("Test")
                    .modifier(ReduceMotionAwareModifier<Bool>(
                        animation: nil,
                        value: isActive
                    ))
            }
        }

        let view = TestView()
        let _ = view // Verify compilation
    }

    @Test func testModifierWithDifferentValueTypes() {
        struct TestView: View {
            @State var boolValue = false
            @State var intValue = 0
            @State var doubleValue = 0.0
            @State var stringValue = ""

            var body: some View {
                VStack {
                    Text("Bool").animateIfMotionAllowed(.easeInOut, value: boolValue)
                    Text("Int").animateIfMotionAllowed(.easeInOut, value: intValue)
                    Text("Double").animateIfMotionAllowed(.easeInOut, value: doubleValue)
                    Text("String").animateIfMotionAllowed(.easeInOut, value: stringValue)
                }
            }
        }

        let view = TestView()
        let _ = view // Verify compilation with different value types
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Utilities/ColorBlindnessSimulatorTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

#if DEBUG

// MARK: - Color Blindness Simulator Tests

/// Tests for Phase 3: Accessibility Enhancements - Color blindness simulator (DEBUG only)
/// Validates color transformations for accessibility testing
struct ColorBlindnessSimulatorTests {

    // MARK: - Color Blindness Type Tests

    @Test func testAllColorBlindnessTypesExist() {
        let allTypes = ColorBlindnessType.allCases
        #expect(allTypes.count == 4)
        #expect(allTypes.contains(.deuteranopia))
        #expect(allTypes.contains(.protanopia))
        #expect(allTypes.contains(.tritanopia))
        #expect(allTypes.contains(.normal))
    }

    @Test func testColorBlindnessTypeRawValues() {
        #expect(ColorBlindnessType.deuteranopia.rawValue == "deuteranopia")
        #expect(ColorBlindnessType.protanopia.rawValue == "protanopia")
        #expect(ColorBlindnessType.tritanopia.rawValue == "tritanopia")
        #expect(ColorBlindnessType.normal.rawValue == "normal")
    }

    @Test func testColorBlindnessDisplayNames() {
        #expect(ColorBlindnessType.deuteranopia.displayName == "Deuteranopia (Red-Green)")
        #expect(ColorBlindnessType.protanopia.displayName == "Protanopia (Red-Green)")
        #expect(ColorBlindnessType.tritanopia.displayName == "Tritanopia (Blue-Yellow)")
        #expect(ColorBlindnessType.normal.displayName == "Normal Vision")
    }

    // MARK: - Color Simulation Tests

    @Test func testNormalVisionNoSimulation() {
        let originalColor = Color.red
        let simulatedColor = ColorBlindnessType.normal.simulate(originalColor)

        // Normal vision should return the same color
        #expect(simulatedColor == originalColor)
    }

    @Test func testDeuteranopiaSimulation() {
        let originalColor = Color.green
        let simulatedColor = ColorBlindnessType.deuteranopia.simulate(originalColor)

        // Simulation should produce a different color
        #expect(simulatedColor != nil)
    }

    @Test func testProtanopiaSimulation() {
        let originalColor = Color.red
        let simulatedColor = ColorBlindnessType.protanopia.simulate(originalColor)

        #expect(simulatedColor != nil)
    }

    @Test func testTritanopiaSimulation() {
        let originalColor = Color.blue
        let simulatedColor = ColorBlindnessType.tritanopia.simulate(originalColor)

        #expect(simulatedColor != nil)
    }

    @Test func testSimulationPreservesAlpha() {
        let originalColor = Color.red.opacity(0.5)
        let simulatedColor = ColorBlindnessType.deuteranopia.simulate(originalColor)

        // Alpha should be preserved
        #expect(simulatedColor != nil)
    }

    // MARK: - Stress Color Simulation Tests

    @Test func testSimulateRelaxedColor() {
        let relaxedColor = StressCategory.relaxed.color
        let deuteranopia = ColorBlindnessType.deuteranopia.simulate(relaxedColor)
        let protanopia = ColorBlindnessType.protanopia.simulate(relaxedColor)
        let tritanopia = ColorBlindnessType.tritanopia.simulate(relaxedColor)

        #expect(deuteranopia != nil)
        #expect(protanopia != nil)
        #expect(tritanopia != nil)
    }

    @Test func testSimulateMildColor() {
        let mildColor = StressCategory.mild.color
        let deuteranopia = ColorBlindnessType.deuteranopia.simulate(mildColor)
        let protanopia = ColorBlindnessType.protanopia.simulate(mildColor)
        let tritanopia = ColorBlindnessType.tritanopia.simulate(mildColor)

        #expect(deuteranopia != nil)
        #expect(protanopia != nil)
        #expect(tritanopia != nil)
    }

    @Test func testSimulateModerateColor() {
        let moderateColor = StressCategory.moderate.color
        let deuteranopia = ColorBlindnessType.deuteranopia.simulate(moderateColor)
        let protanopia = ColorBlindnessType.protanopia.simulate(moderateColor)
        let tritanopia = ColorBlindnessType.tritanopia.simulate(moderateColor)

        #expect(deuteranopia != nil)
        #expect(protanopia != nil)
        #expect(tritanopia != nil)
    }

    @Test func testSimulateHighColor() {
        let highColor = StressCategory.high.color
        let deuteranopia = ColorBlindnessType.deuteranopia.simulate(highColor)
        let protanopia = ColorBlindnessType.protanopia.simulate(highColor)
        let tritanopia = ColorBlindnessType.tritanopia.simulate(highColor)

        #expect(deuteranopia != nil)
        #expect(protanopia != nil)
        #expect(tritanopia != nil)
    }

    // MARK: - Color Blindness Simulator Modifier Tests

    @Test func testColorBlindnessSimulatorModifierCreates() {
        let modifier = ColorBlindnessSimulatorModifier(type: .deuteranopia)
        #expect(modifier.type == .deuteranopia)
    }

    @Test func testSimulatorModifierWithNormalVision() {
        let modifier = ColorBlindnessSimulatorModifier(type: .normal)
        #expect(modifier.type == .normal)
    }

    @Test func testSimulatorModifierWithAllTypes() {
        for type in ColorBlindnessType.allCases {
            let modifier = ColorBlindnessSimulatorModifier(type: type)
            #expect(modifier.type == type)
        }
    }

    // MARK: - View Extension Tests

    @Test func testSimulateColorBlindnessViewExtension() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .fill(Color.red)
                    .simulateColorBlindness(.deuteranopia)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testSimulateAllColorBlindnessTypes() {
        for type in ColorBlindnessType.allCases {
            struct TestView: View {
                let type: ColorBlindnessType

                var body: some View {
                    Color.green
                        .simulateColorBlindness(type)
                }
            }

            let view = TestView(type: type)
            let _ = view
        }
    }

    // MARK: - Visual Indicator Tests

    @Test func testSimulatorShowsVisualIndicator() {
        // When simulation is active (not .normal), indicator should show
        struct TestView: View {
            var body: some View {
                Color.blue
                    .simulateColorBlindness(.deuteranopia)
            }
        }

        let view = TestView()
        let _ = view // Should include indicator overlay
    }

    @Test func testNormalVisionNoIndicator() {
        // Normal vision should not show indicator
        struct TestView: View {
            var body: some View {
                Color.blue
                    .simulateColorBlindness(.normal)
            }
        }

        let view = TestView()
        let _ = view // No indicator for normal vision
    }

    // MARK: - Color Blindness Preview Container Tests

    @Test func testColorBlindnessPreviewContainerCreates() {
        let container = ColorBlindnessPreviewContainer {
            Rectangle()
                .fill(Color.green)
                .frame(width: 100, height: 100)
        }

        #expect(container != nil)
    }

    @Test func testPreviewContainerShowsAllTypes() {
        struct TestContent: View {
            var body: some View {
                HStack {
                    Circle().fill(Color.green)
                    Circle().fill(Color.red)
                    Circle().fill(Color.blue)
                }
                .frame(height: 50)
            }
        }

        let container = ColorBlindnessPreviewContainer {
            TestContent()
        }

        let _ = container // Should show all 4 color blindness types
    }

    // MARK: - Stress Color Validator Tests

    @Test func testValidateStressColorsReturnsResults() {
        let results = StressColorValidator.validateStressColors()

        #expect(!results.isEmpty, "Should return validation results")
        #expect(results.count == 4, "Should validate all 4 stress categories")
    }

    @Test func testValidateStressColorsIncludesAllCategories() {
        let results = StressColorValidator.validateStressColors()

        #expect(results["relaxed"] != nil)
        #expect(results["mild"] != nil)
        #expect(results["moderate"] != nil)
        #expect(results["high"] != nil)
    }

    @Test func testValidateStressColorsIncludesAllColorBlindnessTypes() {
        let results = StressColorValidator.validateStressColors()

        for (_, simulations) in results {
            #expect(simulations.count == 4, "Each category should be simulated for all 4 types")
            #expect(simulations[.normal] != nil)
            #expect(simulations[.deuteranopia] != nil)
            #expect(simulations[.protanopia] != nil)
            #expect(simulations[.tritanopia] != nil)
        }
    }

    @Test func testPrintValidationResultsExecutes() {
        // Should execute without errors
        StressColorValidator.printValidationResults()
        // Note: This prints to console, we can't capture output in tests
    }

    // MARK: - Integration Tests

    @Test func testSimulatorWithComplexView() {
        struct ComplexView: View {
            var body: some View {
                VStack {
                    ForEach(StressCategory.allCases, id: \.self) { category in
                        HStack {
                            Circle()
                                .fill(category.color)
                                .frame(width: 30, height: 30)
                            Text(category.displayName)
                        }
                    }
                }
                .padding()
                .simulateColorBlindness(.deuteranopia)
            }
        }

        let view = ComplexView()
        let _ = view
    }

    @Test func testSimulatorWithGradients() {
        struct GradientView: View {
            var body: some View {
                LinearGradient(
                    colors: [.green, .blue, .orange],
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .simulateColorBlindness(.protanopia)
            }
        }

        let view = GradientView()
        let _ = view
    }

    @Test func testSimulatorWithTransparency() {
        struct TransparentView: View {
            var body: some View {
                ZStack {
                    Color.green.opacity(0.5)
                    Color.red.opacity(0.3)
                }
                .simulateColorBlindness(.tritanopia)
            }
        }

        let view = TransparentView()
        let _ = view
    }

    // MARK: - Debug-Only Tests

    @Test func testSimulatorOnlyAvailableInDebug() {
        // This test file is wrapped in #if DEBUG
        // Verifying compilation confirms it's DEBUG-only
        #expect(true, "Simulator should only be available in DEBUG builds")
    }

    // MARK: - Color Transformation Tests

    @Test func testDeuteranopiaAffectsRedGreen() {
        let red = Color.red
        let green = Color.green
        let blue = Color.blue

        let redSim = ColorBlindnessType.deuteranopia.simulate(red)
        let greenSim = ColorBlindnessType.deuteranopia.simulate(green)
        let blueSim = ColorBlindnessType.deuteranopia.simulate(blue)

        #expect(redSim != nil)
        #expect(greenSim != nil)
        #expect(blueSim != nil)
        // Red and green should be affected more than blue
    }

    @Test func testProtanopiaAffectsRedGreen() {
        let red = Color.red
        let green = Color.green

        let redSim = ColorBlindnessType.protanopia.simulate(red)
        let greenSim = ColorBlindnessType.protanopia.simulate(green)

        #expect(redSim != nil)
        #expect(greenSim != nil)
    }

    @Test func testTritanopiaAffectsBlueYellow() {
        let blue = Color.blue
        let yellow = Color.yellow

        let blueSim = ColorBlindnessType.tritanopia.simulate(blue)
        let yellowSim = ColorBlindnessType.tritanopia.simulate(yellow)

        #expect(blueSim != nil)
        #expect(yellowSim != nil)
    }

    // MARK: - Edge Case Tests

    @Test func testSimulateBlackColor() {
        let black = Color.black
        let simulated = ColorBlindnessType.deuteranopia.simulate(black)
        #expect(simulated != nil)
    }

    @Test func testSimulateWhiteColor() {
        let white = Color.white
        let simulated = ColorBlindnessType.protanopia.simulate(white)
        #expect(simulated != nil)
    }

    @Test func testSimulateClearColor() {
        let clear = Color.clear
        let simulated = ColorBlindnessType.tritanopia.simulate(clear)
        #expect(simulated != nil)
    }

    @Test func testSimulateGrayColor() {
        let gray = Color.gray
        let simulated = ColorBlindnessType.deuteranopia.simulate(gray)
        #expect(simulated != nil)
    }

    // MARK: - Accessibility Testing Workflow Tests

    @Test func testDesignerCanTestColorBlindness() {
        // Simulate designer workflow: create view, apply all simulations
        struct DesignView: View {
            var body: some View {
                HStack(spacing: 20) {
                    StressRingView(
                        stressLevel: 30,
                        category: .mild
                    )
                    .frame(width: 150, height: 150)
                }
            }
        }

        // Designer can preview all color blindness types
        for type in ColorBlindnessType.allCases {
            let preview = DesignView()
                .simulateColorBlindness(type)
            let _ = preview
        }
    }

    @Test func testValidatorHelpsIdentifyIssues() {
        // Validator should help identify color accessibility issues
        let results = StressColorValidator.validateStressColors()

        for (category, simulations) in results {
            // Each category should be testable under all color blindness types
            #expect(simulations.count == 4, "Category \(category) should have 4 simulations")

            // Normal vision should exist as baseline
            #expect(simulations[.normal] != nil, "Normal vision baseline missing for \(category)")
        }
    }
}

// MARK: - Color Blindness Simulator Integration Tests

@MainActor
struct ColorBlindnessSimulatorIntegrationTests {

    @Test func testSimulatorInPreviewEnvironment() {
        struct PreviewView: View {
            var body: some View {
                ColorBlindnessPreviewContainer {
                    VStack {
                        Text("Stress Level: High")
                            .foregroundStyle(StressCategory.high.color)
                        Text("Stress Level: Moderate")
                            .foregroundStyle(StressCategory.moderate.color)
                    }
                }
            }
        }

        let view = PreviewView()
        let _ = view
    }

    @Test func testSimulatorWithEnvironmentValues() {
        struct TestView: View {
            @Environment(\.colorScheme) var colorScheme

            var body: some View {
                Color.green
                    .simulateColorBlindness(.deuteranopia)
            }
        }

        let lightView = TestView()
            .environment(\.colorScheme, .light)
        let darkView = TestView()
            .environment(\.colorScheme, .dark)

        let _ = lightView
        let _ = darkView
    }
}

#endif
</file>

<file path="StressMonitor/StressMonitorTests/Utilities/DynamicTypeScalingTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - Dynamic Type Scaling Tests

/// Tests for Phase 3: Accessibility Enhancements - Dynamic Type support
/// Validates text scaling and readability across all Dynamic Type sizes
struct DynamicTypeScalingTests {

    // MARK: - Dynamic Type Scaling Modifier Tests

    @Test func testDynamicTypeScalingModifierCreates() {
        let modifier = DynamicTypeScalingModifier(minimumScale: 0.75)
        #expect(modifier != nil)
        #expect(modifier.minimumScale == 0.75)
    }

    @Test func testDynamicTypeScalingWithDefaultScale() {
        let modifier = DynamicTypeScalingModifier()
        #expect(modifier.minimumScale == 0.75)
    }

    @Test func testDynamicTypeScalingWithCustomScale() {
        let modifier = DynamicTypeScalingModifier(minimumScale: 0.5)
        #expect(modifier.minimumScale == 0.5)
    }

    // MARK: - View Extension Tests

    @Test func testScalableTextViewExtension() {
        struct TestView: View {
            var body: some View {
                Text("Scalable Text")
                    .scalableText()
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testScalableTextWithCustomMinimumScale() {
        struct TestView: View {
            var body: some View {
                Text("Custom Scale")
                    .scalableText(minimumScale: 0.6)
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Minimum Scale Factor Tests

    @Test func testMinimumScaleFactorApplied() {
        struct TestView: View {
            var body: some View {
                Text("Test")
                    .scalableText(minimumScale: 0.8)
            }
        }

        let view = TestView()
        let _ = view // Should apply minimumScaleFactor(0.8)
    }

    @Test func testVariousMinimumScales() {
        let scales: [CGFloat] = [0.5, 0.6, 0.7, 0.75, 0.8, 0.9, 1.0]

        for scale in scales {
            struct TestView: View {
                let scale: CGFloat

                var body: some View {
                    Text("Scale: \(scale)")
                        .scalableText(minimumScale: scale)
                }
            }

            let view = TestView(scale: scale)
            let _ = view
        }
    }

    // MARK: - Line Limit Tests

    @Test func testLineWrappingEnabled() {
        // scalableText should set lineLimit(nil) to allow wrapping
        struct TestView: View {
            var body: some View {
                Text("Long text that should wrap")
                    .scalableText()
            }
        }

        let view = TestView()
        let _ = view // lineLimit(nil) allows wrapping
    }

    // MARK: - Adaptive Text Size Modifier Tests

    @Test func testAdaptiveTextSizeModifierCreates() {
        let modifier = AdaptiveTextSizeModifier(baseSize: 16)
        #expect(modifier.baseSize == 16.0)
        #expect(modifier.weight == .regular)
        #expect(modifier.design == .default)
    }

    @Test func testAdaptiveTextSizeWithWeight() {
        let modifier = AdaptiveTextSizeModifier(baseSize: 20, weight: .bold)
        #expect(modifier.weight == .bold)
    }

    @Test func testAdaptiveTextSizeWithDesign() {
        let modifier = AdaptiveTextSizeModifier(baseSize: 18, weight: .medium, design: .rounded)
        #expect(modifier.design == .rounded)
    }

    @Test func testAdaptiveTextSizeViewExtension() {
        struct TestView: View {
            var body: some View {
                Text("Adaptive")
                    .adaptiveTextSize(16)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testAdaptiveTextSizeWithAllParameters() {
        struct TestView: View {
            var body: some View {
                Text("Bold Rounded")
                    .adaptiveTextSize(20, weight: .bold, design: .rounded)
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Dynamic Type Size Scaling Tests

    @Test func testScalingAtXSmall() {
        // xSmall should scale to 0.8x base size
        let modifier = AdaptiveTextSizeModifier(baseSize: 20)
        // Cannot directly test private scaledSize, but verify modifier creates
        #expect(modifier.baseSize == 20.0)
    }

    @Test func testScalingAtMedium() {
        // Medium should use base size (1.0x)
        let modifier = AdaptiveTextSizeModifier(baseSize: 20)
        #expect(modifier.baseSize == 20.0)
    }

    @Test func testScalingAtAccessibility5() {
        // Accessibility5 should scale to 2.6x base size
        let modifier = AdaptiveTextSizeModifier(baseSize: 20)
        #expect(modifier.baseSize == 20.0)
        // Result would be 20 * 2.6 = 52
    }

    // MARK: - Limited Dynamic Type Tests

    @Test func testLimitedDynamicTypeModifierCreates() {
        let modifier = LimitedDynamicTypeModifier()
        #expect(modifier != nil)
    }

    @Test func testLimitedDynamicTypeViewExtension() {
        struct TestView: View {
            var body: some View {
                Text("Limited")
                    .limitedDynamicType()
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testLimitedDynamicTypeMaxIsAccessibility3() {
        // Modifier limits to ...accessibility3
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Test 1").limitedDynamicType()
                    Text("Test 2").limitedDynamicType()
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Accessible Dynamic Type Tests

    @Test func testAccessibleDynamicTypeModifierCreates() {
        let modifier = AccessibleDynamicTypeModifier()
        #expect(modifier.minimumScale == 0.75)
        #expect(modifier.maxDynamicTypeSize == .accessibility3)
    }

    @Test func testAccessibleDynamicTypeWithCustomParameters() {
        let modifier = AccessibleDynamicTypeModifier(
            minimumScale: 0.6,
            maxDynamicTypeSize: .accessibility5
        )
        #expect(modifier.minimumScale == 0.6)
        #expect(modifier.maxDynamicTypeSize == .accessibility5)
    }

    @Test func testAccessibleDynamicTypeViewExtension() {
        struct TestView: View {
            var body: some View {
                Text("Accessible")
                    .accessibleDynamicType()
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testAccessibleDynamicTypeWithAllParameters() {
        struct TestView: View {
            var body: some View {
                Text("Custom Limits")
                    .accessibleDynamicType(
                        minimumScale: 0.8,
                        maxDynamicTypeSize: .accessibility2
                    )
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Integration Tests

    @Test func testAllDynamicTypeSizes() {
        let sizes: [DynamicTypeSize] = [
            .xSmall, .small, .medium, .large, .xLarge, .xxLarge, .xxxLarge,
            .accessibility1, .accessibility2, .accessibility3, .accessibility4, .accessibility5
        ]

        for size in sizes {
            struct TestView: View {
                let size: DynamicTypeSize

                var body: some View {
                    Text("Size: \(String(describing: size))")
                        .adaptiveTextSize(16)
                }
            }

            let view = TestView(size: size)
                .environment(\.dynamicTypeSize, size)
            let _ = view
        }
    }

    @Test func testScalableTextWithLongContent() {
        struct TestView: View {
            var body: some View {
                Text("This is a very long text that should wrap to multiple lines when necessary and scale appropriately based on Dynamic Type settings.")
                    .scalableText()
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testMultipleDynamicTypeModifiers() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Title")
                        .adaptiveTextSize(24, weight: .bold)

                    Text("Body")
                        .scalableText()

                    Text("Caption")
                        .adaptiveTextSize(12)
                        .limitedDynamicType()
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Font Weight Tests

    @Test func testAdaptiveTextWithAllWeights() {
        let weights: [Font.Weight] = [
            .ultraLight, .thin, .light, .regular, .medium, .semibold, .bold, .heavy, .black
        ]

        for weight in weights {
            struct TestView: View {
                let weight: Font.Weight

                var body: some View {
                    Text("Weight Test")
                        .adaptiveTextSize(16, weight: weight)
                }
            }

            let view = TestView(weight: weight)
            let _ = view
        }
    }

    // MARK: - Font Design Tests

    @Test func testAdaptiveTextWithAllDesigns() {
        let designs: [Font.Design] = [.default, .serif, .rounded, .monospaced]

        for design in designs {
            struct TestView: View {
                let design: Font.Design

                var body: some View {
                    Text("Design Test")
                        .adaptiveTextSize(16, design: design)
                }
            }

            let view = TestView(design: design)
            let _ = view
        }
    }

    // MARK: - Edge Case Tests

    @Test func testZeroMinimumScale() {
        struct TestView: View {
            var body: some View {
                Text("Zero Scale")
                    .scalableText(minimumScale: 0)
            }
        }

        let view = TestView()
        let _ = view // Should handle edge case
    }

    @Test func testOneMinimumScale() {
        struct TestView: View {
            var body: some View {
                Text("Full Scale")
                    .scalableText(minimumScale: 1.0)
            }
        }

        let view = TestView()
        let _ = view // No scaling allowed
    }

    @Test func testVerySmallBaseSize() {
        struct TestView: View {
            var body: some View {
                Text("Tiny")
                    .adaptiveTextSize(6)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testVeryLargeBaseSize() {
        struct TestView: View {
            var body: some View {
                Text("Huge")
                    .adaptiveTextSize(72)
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Accessibility Compliance Tests

    @Test func testTextScalesUpForAccessibility() {
        // Verify text can scale up for accessibility sizes
        struct TestView: View {
            var body: some View {
                Text("Accessibility Text")
                    .adaptiveTextSize(16)
            }
        }

        let normalView = TestView()
            .environment(\.dynamicTypeSize, .medium)
        let accessibilityView = TestView()
            .environment(\.dynamicTypeSize, .accessibility5)

        let _ = normalView
        let _ = accessibilityView // Both should compile
    }

    @Test func testTextRemainReadableAtMinimumScale() {
        // Minimum scale ensures text doesn't become unreadable
        struct TestView: View {
            var body: some View {
                Text("Readable")
                    .scalableText(minimumScale: 0.75)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testLineWrappingPreventsTruncation() {
        // lineLimit(nil) prevents text truncation
        struct TestView: View {
            var body: some View {
                Text("Long text that would otherwise be truncated at larger Dynamic Type sizes")
                    .scalableText()
            }
        }

        let view = TestView()
            .environment(\.dynamicTypeSize, .accessibility5)
        let _ = view
    }
}

// MARK: - Dynamic Type Environment Tests

@MainActor
struct DynamicTypeEnvironmentTests {

    @Test func testDynamicTypeSizeEnvironmentAccess() {
        struct TestView: View {
            @Environment(\.dynamicTypeSize) var dynamicTypeSize

            var body: some View {
                Text("Size: \(String(describing: dynamicTypeSize))")
                    .adaptiveTextSize(16)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testDynamicTypeSizeChanges() {
        struct TestView: View {
            var body: some View {
                Text("Dynamic")
                    .adaptiveTextSize(16)
            }
        }

        let smallView = TestView()
            .environment(\.dynamicTypeSize, .small)
        let largeView = TestView()
            .environment(\.dynamicTypeSize, .xxxLarge)

        let _ = smallView
        let _ = largeView
    }

    @Test func testLimitedDynamicTypeWithEnvironment() {
        struct TestView: View {
            @Environment(\.dynamicTypeSize) var dynamicTypeSize

            var body: some View {
                Text("Limited to Accessibility 3")
                    .limitedDynamicType()
            }
        }

        let view = TestView()
            .environment(\.dynamicTypeSize, .accessibility5)
        let _ = view // Should cap at accessibility3
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Utilities/HapticManagerTests.swift">
import XCTest
import UIKit
import CoreHaptics
@testable import StressMonitor

// MARK: - Haptic Manager Tests

final class HapticManagerTests: XCTestCase {

    // MARK: - Properties

    private var sut: HapticManager!

    // MARK: - Setup & Teardown

    @MainActor
    override func setUp() {
        super.setUp()
        sut = HapticManager.shared
    }

    override func tearDown() {
        sut = nil
        super.tearDown()
    }

    // MARK: - Singleton Tests

    @MainActor
    func testSharedInstance() {
        let instance1 = HapticManager.shared
        let instance2 = HapticManager.shared

        XCTAssertTrue(instance1 === instance2, "HapticManager should be a singleton")
    }

    // MARK: - Hardware Capability Tests

    func testHardwareCapabilitiesDetection() {
        let capabilities = CHHapticEngine.capabilitiesForHardware()
        let supportsHaptics = capabilities.supportsHaptics

        // Device may or may not support haptics
        // Test passes if detection works without crash
        XCTAssertNotNil(capabilities)
        print("Device supports haptics: \(supportsHaptics)")
    }

    // MARK: - Stress Level Change Haptics

    @MainActor
    func testStressLevelChangedToRelaxed() {
        // Test that relaxed category triggers success haptic
        XCTAssertNoThrow(sut.stressLevelChanged(to: .relaxed))
    }

    @MainActor
    func testStressLevelChangedToMild() {
        // Test that mild category triggers light haptic
        XCTAssertNoThrow(sut.stressLevelChanged(to: .mild))
    }

    @MainActor
    func testStressLevelChangedToModerate() {
        // Test that moderate category triggers warning haptic
        XCTAssertNoThrow(sut.stressLevelChanged(to: .moderate))
    }

    @MainActor
    func testStressLevelChangedToHigh() {
        // Test that high category triggers error haptic
        XCTAssertNoThrow(sut.stressLevelChanged(to: .high))
    }

    // MARK: - Breathing Cue Haptic Tests

    @MainActor
    func testBreathingCueHaptic() {
        // Test light impact at 50% intensity
        XCTAssertNoThrow(sut.breathingCue())

        // Breathing cue should be gentle and non-intrusive
        // Testing execution without crash
    }

    @MainActor
    func testBreathingCueIntensity() {
        // Breathing cue should use light impact style
        // at 0.5 intensity (50%)
        // This is a functional test - implementation uses UIImpactFeedbackGenerator(style: .light)
        XCTAssertNoThrow(sut.breathingCue())
    }

    // MARK: - Button Press Haptic Tests

    @MainActor
    func testButtonPressHaptic() {
        // Test medium impact for button presses
        XCTAssertNoThrow(sut.buttonPress())
    }

    // MARK: - Stress Buddy Mood Change Tests

    @MainActor
    func testStressBuddyMoodChangeHaptic() {
        let mood = StressBuddyMood.calm
        XCTAssertNoThrow(sut.stressBuddyMoodChange(to: mood))
    }

    // MARK: - Individual Haptic Methods Tests

    @MainActor
    func testSuccessHaptic() {
        XCTAssertNoThrow(sut.success())
    }

    @MainActor
    func testWarningHaptic() {
        XCTAssertNoThrow(sut.warning())
    }

    @MainActor
    func testErrorHaptic() {
        XCTAssertNoThrow(sut.error())
    }

    // MARK: - Graceful Fallback Tests

    func testGracefulFallbackWhenHapticsUnavailable() {
        // On devices without haptic engine (iPad, older devices),
        // methods should fail gracefully without crash

        let capabilities = CHHapticEngine.capabilitiesForHardware()
        if !capabilities.supportsHaptics {
            // Test that all methods complete without errors
            Task { @MainActor in
                XCTAssertNoThrow(sut.breathingCue())
                XCTAssertNoThrow(sut.buttonPress())
                XCTAssertNoThrow(sut.success())
                XCTAssertNoThrow(sut.warning())
                XCTAssertNoThrow(sut.error())
            }
        }
    }

    // MARK: - Thread Safety Tests

    @MainActor
    func testConcurrentHapticCalls() {
        // Test that multiple rapid haptic calls don't crash
        let expectation = expectation(description: "Multiple haptics complete")
        expectation.expectedFulfillmentCount = 5

        for _ in 0..<5 {
            Task { @MainActor in
                sut.buttonPress()
                expectation.fulfill()
            }
        }

        wait(for: [expectation], timeout: 2.0)
    }

    // MARK: - Haptic Pattern Tests

    @MainActor
    func testBreathingCuePattern() {
        // Breathing cue should be consistent and gentle
        // Test that calling it multiple times works
        for _ in 0..<3 {
            XCTAssertNoThrow(sut.breathingCue())
        }
    }

    // MARK: - Engine Initialization Tests

    func testHapticEngineInitialization() {
        // Test that engine initializes only when hardware supports it
        let capabilities = CHHapticEngine.capabilitiesForHardware()

        if capabilities.supportsHaptics {
            // Engine should be initialized
            do {
                let engine = try CHHapticEngine()
                XCTAssertNotNil(engine)
            } catch {
                XCTFail("Haptic engine should initialize on supported hardware")
            }
        } else {
            // Engine initialization might fail, which is expected
            print("Hardware does not support haptics - skipping engine test")
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Utilities/HighContrastTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - High Contrast Tests

/// Tests for Phase 3: Accessibility Enhancements - High contrast borders
/// Validates "Differentiate Without Color" support
struct HighContrastTests {

    // MARK: - High Contrast Border Modifier Tests

    @Test func testHighContrastBorderModifierCreates() {
        let modifier = HighContrastBorderModifier(isInteractive: true, cornerRadius: 8)
        #expect(modifier != nil)
    }

    @Test func testHighContrastBorderWithDefaultParameters() {
        let modifier = HighContrastBorderModifier()
        #expect(modifier.isInteractive == true)
        #expect(modifier.cornerRadius == 8.0)
    }

    @Test func testHighContrastBorderWithCustomCornerRadius() {
        let modifier = HighContrastBorderModifier(isInteractive: true, cornerRadius: 12)
        #expect(modifier.cornerRadius == 12.0)
    }

    @Test func testHighContrastBorderWithNonInteractive() {
        let modifier = HighContrastBorderModifier(isInteractive: false, cornerRadius: 8)
        #expect(modifier.isInteractive == false)
    }

    // MARK: - View Extension Tests

    @Test func testHighContrastBorderViewExtension() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .highContrastBorder()
            }
        }

        let view = TestView()
        let _ = view // Extension should apply
    }

    @Test func testHighContrastBorderWithParameters() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .highContrastBorder(interactive: false, cornerRadius: 16)
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - High Contrast Card Tests

    @Test func testHighContrastCardModifierCreates() {
        let modifier = HighContrastCardModifier()
        #expect(modifier != nil)
    }

    @Test func testHighContrastCardWithDefaultBackground() {
        let modifier = HighContrastCardModifier()
        #expect(modifier.backgroundColor == nil)
        #expect(modifier.cornerRadius == 12.0)
    }

    @Test func testHighContrastCardWithCustomBackground() {
        let modifier = HighContrastCardModifier(backgroundColor: .blue, cornerRadius: 16)
        #expect(modifier.backgroundColor == .blue)
        #expect(modifier.cornerRadius == 16.0)
    }

    @Test func testHighContrastCardViewExtension() {
        struct TestView: View {
            var body: some View {
                Text("Test")
                    .highContrastCard()
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testHighContrastCardWithParameters() {
        struct TestView: View {
            var body: some View {
                Text("Test")
                    .highContrastCard(backgroundColor: .green, cornerRadius: 20)
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - High Contrast Button Tests

    @Test func testHighContrastButtonModifierCreates() {
        let modifier = HighContrastButtonModifier(style: .primary)
        #expect(modifier != nil)
    }

    @Test func testHighContrastButtonPrimaryStyle() {
        let modifier = HighContrastButtonModifier(style: .primary)
        #expect(modifier.style == .primary)
    }

    @Test func testHighContrastButtonSecondaryStyle() {
        let modifier = HighContrastButtonModifier(style: .secondary)
        #expect(modifier.style == .secondary)
    }

    @Test func testHighContrastButtonTertiaryStyle() {
        let modifier = HighContrastButtonModifier(style: .tertiary)
        #expect(modifier.style == .tertiary)
    }

    @Test func testHighContrastButtonDefaultsToPrimary() {
        let modifier = HighContrastButtonModifier()
        #expect(modifier.style == .primary)
    }

    @Test func testHighContrastButtonViewExtension() {
        struct TestView: View {
            var body: some View {
                Button("Test") {}
                    .highContrastButton()
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testHighContrastButtonWithAllStyles() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Button("Primary") {}.highContrastButton(style: .primary)
                    Button("Secondary") {}.highContrastButton(style: .secondary)
                    Button("Tertiary") {}.highContrastButton(style: .tertiary)
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Border Width Tests

    @Test func testBorderWidthIsTwoPoints() {
        // Verify that the border width is 2pt for WCAG compliance
        struct TestView: View {
            @Environment(\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor

            var body: some View {
                Rectangle()
                    .highContrastBorder()
            }
        }

        let view = TestView()
        let _ = view // Border should be 2pt when enabled
    }

    // MARK: - Integration Tests

    @Test func testHighContrastModifiersOnInteractiveElements() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Button("Tap Me") {}
                        .highContrastButton()

                    Toggle("Setting", isOn: .constant(true))
                        .highContrastBorder()

                    TextField("Input", text: .constant(""))
                        .highContrastBorder()
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testHighContrastCardWithContent() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Title")
                    Text("Content")
                }
                .padding()
                .highContrastCard()
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testMultipleHighContrastModifiers() {
        struct TestView: View {
            var body: some View {
                Button("Action") {}
                    .highContrastBorder()
                    .highContrastButton()
            }
        }

        let view = TestView()
        let _ = view // Multiple modifiers should compose
    }

    // MARK: - Corner Radius Tests

    @Test func testVariousCornerRadii() {
        let radii: [CGFloat] = [0, 4, 8, 12, 16, 20]

        for radius in radii {
            struct TestView: View {
                let radius: CGFloat

                var body: some View {
                    Rectangle()
                        .highContrastBorder(cornerRadius: radius)
                }
            }

            let view = TestView(radius: radius)
            let _ = view
        }
    }

    @Test func testCardCornerRadii() {
        let radii: [CGFloat] = [8, 12, 16, 20]

        for radius in radii {
            struct TestView: View {
                let radius: CGFloat

                var body: some View {
                    Text("Test")
                        .highContrastCard(cornerRadius: radius)
                }
            }

            let view = TestView(radius: radius)
            let _ = view
        }
    }

    // MARK: - Background Color Tests

    @Test func testCardWithDifferentBackgrounds() {
        let backgrounds: [Color] = [.white, .black, .gray, .blue, .green]

        for bg in backgrounds {
            struct TestView: View {
                let bg: Color

                var body: some View {
                    Text("Test")
                        .highContrastCard(backgroundColor: bg)
                }
            }

            let view = TestView(bg: bg)
            let _ = view
        }
    }

    // MARK: - Accessibility Compliance Tests

    @Test func testBorderIsVisibleForInteractiveElements() {
        // Interactive elements should have border when differentiateWithoutColor is enabled
        struct TestView: View {
            var body: some View {
                Button("Test") {}
                    .highContrastBorder(interactive: true)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testNonInteractiveElementsCanSkipBorder() {
        struct TestView: View {
            var body: some View {
                Text("Static Text")
                    .highContrastBorder(interactive: false)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testBorderColorIsPrimary() {
        // Border should use Color.primary for proper contrast in all themes
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .highContrastBorder()
            }
        }

        let view = TestView()
        let _ = view // Border uses Color.primary
    }
}

// MARK: - High Contrast Environment Tests

@MainActor
struct HighContrastEnvironmentTests {

    @Test func testDifferentiateWithoutColorEnvironmentAccess() {
        struct TestView: View {
            @Environment(\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor

            var body: some View {
                Text("Environment: \(String(differentiateWithoutColor))")
                    .highContrastBorder()
            }
        }

        let view = TestView()
        let _ = view // Should access environment value
    }

    @Test func testColorSchemeEnvironmentAccess() {
        struct TestView: View {
            @Environment(\.colorScheme) var colorScheme

            var body: some View {
                Text("Scheme: \(String(describing: colorScheme))")
                    .highContrastCard()
            }
        }

        let view = TestView()
        let _ = view // Card background adapts to color scheme
    }

    @Test func testHighContrastModifiersInLightMode() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Light Mode")
                        .highContrastCard()
                }
            }
        }

        let view = TestView()
            .environment(\.colorScheme, .light)
        let _ = view
    }

    @Test func testHighContrastModifiersInDarkMode() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Dark Mode")
                        .highContrastCard()
                }
            }
        }

        let view = TestView()
            .environment(\.colorScheme, .dark)
        let _ = view
    }
}

// MARK: - High Contrast Layout Tests

@MainActor
struct HighContrastLayoutTests {

    @Test func testBorderDoesNotAffectLayout() {
        struct TestView: View {
            var body: some View {
                Text("Test")
                    .frame(width: 100, height: 50)
                    .highContrastBorder()
            }
        }

        let view = TestView()
        let _ = view // Border is overlay, should not affect frame
    }

    @Test func testCardClipsShape() {
        struct TestView: View {
            var body: some View {
                Color.red
                    .frame(width: 100, height: 100)
                    .highContrastCard()
            }
        }

        let view = TestView()
        let _ = view // Card should clip to rounded rectangle
    }

    @Test func testButtonBorderOverlaysContent() {
        struct TestView: View {
            var body: some View {
                Button("Test") {}
                    .frame(width: 120, height: 44)
                    .highContrastButton()
            }
        }

        let view = TestView()
        let _ = view // Button border should overlay without affecting size
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Utilities/PatternOverlayTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - Pattern Overlay Tests

/// Tests for Phase 3: Accessibility Enhancements - Pattern overlays for dual coding
/// Validates WCAG 2.1 compliance for color-blind users
struct PatternOverlayTests {

    // MARK: - Pattern Type Tests

    @Test func testAllPatternTypesExist() {
        let allPatterns = StressPattern.allCases
        #expect(allPatterns.count == 4, "Should have exactly 4 pattern types")
        #expect(allPatterns.contains(.solid))
        #expect(allPatterns.contains(.diagonal))
        #expect(allPatterns.contains(.dots))
        #expect(allPatterns.contains(.crosshatch))
    }

    @Test func testPatternMappingForRelaxed() {
        let pattern = StressPattern.pattern(for: .relaxed)
        #expect(pattern == .solid, "Relaxed should use solid pattern")
    }

    @Test func testPatternMappingForMild() {
        let pattern = StressPattern.pattern(for: .mild)
        #expect(pattern == .diagonal, "Mild should use diagonal pattern")
    }

    @Test func testPatternMappingForModerate() {
        let pattern = StressPattern.pattern(for: .moderate)
        #expect(pattern == .dots, "Moderate should use dots pattern")
    }

    @Test func testPatternMappingForHigh() {
        let pattern = StressPattern.pattern(for: .high)
        #expect(pattern == .crosshatch, "High should use crosshatch pattern")
    }

    @Test func testAllStressCategoriesHavePatterns() {
        let categories: [StressCategory] = [.relaxed, .mild, .moderate, .high]

        for category in categories {
            let pattern = StressPattern.pattern(for: category)
            #expect(pattern != nil, "Category \(category) should have a pattern")
        }
    }

    // MARK: - Pattern Raw Value Tests

    @Test func testPatternRawValues() {
        #expect(StressPattern.solid.rawValue == "solid")
        #expect(StressPattern.diagonal.rawValue == "diagonal")
        #expect(StressPattern.dots.rawValue == "dots")
        #expect(StressPattern.crosshatch.rawValue == "crosshatch")
    }

    // MARK: - ShapeStyle Tests

    @Test func testSolidPatternShapeStyle() {
        let shapeStyle = StressPattern.solid.shapeStyle
        #expect(shapeStyle != nil, "Solid pattern should have a shape style")
    }

    @Test func testDiagonalPatternShapeStyle() {
        let shapeStyle = StressPattern.diagonal.shapeStyle
        #expect(shapeStyle != nil, "Diagonal pattern should have a shape style")
    }

    @Test func testDotsPatternShapeStyle() {
        let shapeStyle = StressPattern.dots.shapeStyle
        #expect(shapeStyle != nil, "Dots pattern should have a shape style")
    }

    @Test func testCrosshatchPatternShapeStyle() {
        let shapeStyle = StressPattern.crosshatch.shapeStyle
        #expect(shapeStyle != nil, "Crosshatch pattern should have a shape style")
    }

    // MARK: - Pattern Overlay View Tests

    @Test func testSolidPatternOverlayIsEmpty() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .fill(Color.green)
                    .overlay {
                        StressPattern.solid.overlay(color: .green)
                    }
            }
        }

        let view = TestView()
        let _ = view // Solid should produce EmptyView
    }

    @Test func testDiagonalPatternOverlayCreates() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .fill(Color.blue)
                    .overlay {
                        StressPattern.diagonal.overlay(color: .blue)
                    }
            }
        }

        let view = TestView()
        let _ = view // Should compile and create diagonal overlay
    }

    @Test func testDotsPatternOverlayCreates() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .fill(Color.yellow)
                    .overlay {
                        StressPattern.dots.overlay(color: .yellow)
                    }
            }
        }

        let view = TestView()
        let _ = view // Should compile and create dots overlay
    }

    @Test func testCrosshatchPatternOverlayCreates() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .fill(Color.orange)
                    .overlay {
                        StressPattern.crosshatch.overlay(color: .orange)
                    }
            }
        }

        let view = TestView()
        let _ = view // Should compile and create crosshatch overlay
    }

    // MARK: - Pattern Opacity Tests

    @Test func testPatternOverlayWithDefaultOpacity() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .overlay {
                        StressPattern.diagonal.overlay(color: .blue)
                    }
            }
        }

        let view = TestView()
        let _ = view // Default opacity should be 0.3
    }

    @Test func testPatternOverlayWithCustomOpacity() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .overlay {
                        StressPattern.diagonal.overlay(color: .blue, opacity: 0.5)
                    }
            }
        }

        let view = TestView()
        let _ = view // Custom opacity should be applied
    }

    // MARK: - Pattern Modifier Tests

    @Test func testPatternOverlayModifierApplies() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .modifier(PatternOverlayModifier(
                        pattern: .diagonal,
                        color: .blue
                    ))
            }
        }

        let view = TestView()
        let _ = view // Modifier should apply correctly
    }

    @Test func testStressPatternViewExtension() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .stressPattern(.diagonal, color: .blue)
            }
        }

        let view = TestView()
        let _ = view // View extension should work
    }

    @Test func testStressPatternByCategoryViewExtension() {
        struct TestView: View {
            var body: some View {
                Rectangle()
                    .stressPattern(for: .mild)
            }
        }

        let view = TestView()
        let _ = view // Category-based extension should work
    }

    // MARK: - Integration Tests

    @Test func testAllPatternsWithAllCategories() {
        let categories: [StressCategory] = [.relaxed, .mild, .moderate, .high]

        for category in categories {
            struct TestView: View {
                let category: StressCategory

                var body: some View {
                    Rectangle()
                        .stressPattern(for: category)
                }
            }

            let view = TestView(category: category)
            let _ = view // All combinations should work
        }
    }

    @Test func testPatternsWithDifferentColors() {
        let colors: [Color] = [.green, .blue, .yellow, .orange, .red]
        let patterns: [StressPattern] = [.solid, .diagonal, .dots, .crosshatch]

        for pattern in patterns {
            for color in colors {
                struct TestView: View {
                    let pattern: StressPattern
                    let color: Color

                    var body: some View {
                        Rectangle()
                            .stressPattern(pattern, color: color)
                    }
                }

                let view = TestView(pattern: pattern, color: color)
                let _ = view // All color combinations should work
            }
        }
    }

    // MARK: - Accessibility Compliance Tests

    @Test func testPatternsDifferentiateStressLevels() {
        // Each stress level should have a unique pattern
        let relaxedPattern = StressPattern.pattern(for: .relaxed)
        let mildPattern = StressPattern.pattern(for: .mild)
        let moderatePattern = StressPattern.pattern(for: .moderate)
        let highPattern = StressPattern.pattern(for: .high)

        let patterns = [relaxedPattern, mildPattern, moderatePattern, highPattern]
        let uniquePatterns = Set(patterns)

        #expect(uniquePatterns.count == 4, "All stress levels should have unique patterns")
    }

    @Test func testPatternsProvideNonColorDifferentiation() {
        // Verify each category can be distinguished without color
        let categories: [StressCategory] = [.relaxed, .mild, .moderate, .high]
        var patternNames: [String] = []

        for category in categories {
            let pattern = StressPattern.pattern(for: category)
            patternNames.append(pattern.rawValue)
        }

        let uniqueNames = Set(patternNames)
        #expect(uniqueNames.count == 4, "Patterns provide non-color differentiation")
    }
}

// MARK: - Pattern Geometry Tests

@MainActor
struct PatternGeometryTests {

    @Test func testDiagonalLinesViewCompiles() {
        // Test that DiagonalLinesView can be created and used
        struct TestView: View {
            var body: some View {
                GeometryReader { geometry in
                    StressPattern.diagonal.overlay(color: .blue)
                }
                .frame(width: 100, height: 100)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testDotsViewCompiles() {
        struct TestView: View {
            var body: some View {
                GeometryReader { geometry in
                    StressPattern.dots.overlay(color: .yellow)
                }
                .frame(width: 100, height: 100)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testCrosshatchViewCompiles() {
        struct TestView: View {
            var body: some View {
                GeometryReader { geometry in
                    StressPattern.crosshatch.overlay(color: .orange)
                }
                .frame(width: 100, height: 100)
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testPatternsWithVariousSizes() {
        let sizes: [CGFloat] = [50, 100, 200, 300]

        for size in sizes {
            struct TestView: View {
                let size: CGFloat

                var body: some View {
                    Rectangle()
                        .stressPattern(.diagonal, color: .blue)
                        .frame(width: size, height: size)
                }
            }

            let view = TestView(size: size)
            let _ = view // Patterns should work at different sizes
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Views/Breathing/BreathingExerciseViewTests.swift">
import XCTest
import SwiftUI
@testable import StressMonitor

// MARK: - Breathing Exercise View Tests

final class BreathingExerciseViewTests: XCTestCase {

    // MARK: - Breathing Phase Tests

    func testBreathingPhaseDurations() {
        // Test 4-7-8 breathing pattern
        XCTAssertEqual(BreathingPhase.inhale.duration, 4.0, "Inhale should be 4 seconds")
        XCTAssertEqual(BreathingPhase.hold.duration, 7.0, "Hold should be 7 seconds")
        XCTAssertEqual(BreathingPhase.exhale.duration, 8.0, "Exhale should be 8 seconds")
        XCTAssertEqual(BreathingPhase.pause.duration, 1.0, "Pause should be 1 second")
    }

    func testBreathingPhaseDisplayText() {
        XCTAssertEqual(BreathingPhase.inhale.displayText, "Inhale")
        XCTAssertEqual(BreathingPhase.hold.displayText, "Hold")
        XCTAssertEqual(BreathingPhase.exhale.displayText, "Exhale")
        XCTAssertEqual(BreathingPhase.pause.displayText, "Pause")
    }

    func testBreathingPhaseInstructions() {
        XCTAssertEqual(BreathingPhase.inhale.instruction, "Breathe in slowly through your nose")
        XCTAssertEqual(BreathingPhase.hold.instruction, "Hold your breath gently")
        XCTAssertEqual(BreathingPhase.exhale.instruction, "Breathe out slowly through your mouth")
        XCTAssertEqual(BreathingPhase.pause.instruction, "Relax and prepare")
    }

    func testBreathingPhaseIcons() {
        XCTAssertEqual(BreathingPhase.inhale.icon, "arrow.down.circle.fill")
        XCTAssertEqual(BreathingPhase.hold.icon, "pause.circle.fill")
        XCTAssertEqual(BreathingPhase.exhale.icon, "arrow.up.circle.fill")
        XCTAssertEqual(BreathingPhase.pause.icon, "moon.circle.fill")
    }

    func testBreathingPhaseColors() {
        XCTAssertEqual(BreathingPhase.inhale.color, Color.blue)
        XCTAssertEqual(BreathingPhase.hold.color, Color.purple)
        XCTAssertEqual(BreathingPhase.exhale.color, Color.green)
        XCTAssertEqual(BreathingPhase.pause.color, Color.secondary)
    }

    // MARK: - Cycle Completion Tests

    func testCycleCompletion() {
        // Total duration: (4 + 7 + 8 + 1) * 4 cycles = 80 seconds
        let totalDuration = (BreathingPhase.inhale.duration +
                           BreathingPhase.hold.duration +
                           BreathingPhase.exhale.duration +
                           BreathingPhase.pause.duration) * 4

        XCTAssertEqual(totalDuration, 80.0, "Full 4-cycle session should take 80 seconds")
    }

    func testSingleCycleDuration() {
        let cycleDuration = BreathingPhase.inhale.duration +
                          BreathingPhase.hold.duration +
                          BreathingPhase.exhale.duration +
                          BreathingPhase.pause.duration

        XCTAssertEqual(cycleDuration, 20.0, "Single cycle should take 20 seconds")
    }

    // MARK: - Reduce Motion Support Tests

    func testReduceMotionStaticCircle() {
        // Test that static circle shows correct elements
        let phases: [BreathingPhase] = [.inhale, .hold, .exhale, .pause]

        for phase in phases {
            // Verify phase has all required properties for static display
            XCTAssertFalse(phase.displayText.isEmpty, "Phase should have display text")
            XCTAssertFalse(phase.instruction.isEmpty, "Phase should have instruction")
            XCTAssertFalse(phase.icon.isEmpty, "Phase should have icon")
        }
    }

    func testReduceMotionAnimatedCircle() {
        // Test that animated circle scale calculations work
        let inhale = BreathingPhase.inhale
        let hold = BreathingPhase.hold
        let exhale = BreathingPhase.exhale
        let pause = BreathingPhase.pause

        // Verify phases have consistent properties
        XCTAssertNotNil(inhale.color)
        XCTAssertNotNil(hold.color)
        XCTAssertNotNil(exhale.color)
        XCTAssertNotNil(pause.color)
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/Views/AccessibilityLabelsTests.swift">
import Foundation
import Testing
import SwiftUI
@testable import StressMonitor

// MARK: - Accessibility Labels Tests

/// Tests for Phase 3: Accessibility Enhancements - Accessibility labels and VoiceOver support
/// Validates that all interactive elements have proper labels, values, and hints
struct AccessibilityLabelsTests {

    // MARK: - Dashboard View Accessibility Tests

    @Test func testDashboardViewHasAccessibilityElements() {
        // Verify DashboardView configures accessibility elements
        struct TestView: View {
            var body: some View {
                DashboardView()
            }
        }

        let view = TestView()
        let _ = view // Should compile with accessibility labels
    }

    @Test func testStressRingViewHasAccessibilityLabel() {
        // StressRingView should have descriptive label
        struct TestView: View {
            var body: some View {
                StressRingView(stressLevel: 50, category: .moderate)
                    .accessibilityLabel("Stress level indicator")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testStressRingViewHasAccessibilityValue() {
        // StressRingView should communicate current value
        struct TestView: View {
            var body: some View {
                StressRingView(stressLevel: 75, category: .high)
                    .accessibilityValue("75 out of 100, high stress")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testStressRingViewHasAccessibilityHint() {
        // StressRingView should explain its purpose
        struct TestView: View {
            var body: some View {
                StressRingView(stressLevel: 30, category: .mild)
                    .accessibilityHint("Visual representation of your current stress level")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testMeasureButtonHasAccessibilityLabel() {
        struct TestView: View {
            var body: some View {
                MeasureButton(isLoading: false) {
                    // Action
                }
                .accessibilityLabel("Measure stress")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testMeasureButtonHasAccessibilityHint() {
        struct TestView: View {
            var body: some View {
                MeasureButton(isLoading: false) {
                    // Action
                }
                .accessibilityHint("Tap to calculate your current stress level from heart rate data")
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - History View Accessibility Tests

    @Test func testHistoryViewHasAccessibilityLabel() {
        struct TestView: View {
            var body: some View {
                NavigationStack {
                    Text("History")
                }
                .navigationTitle("History")
                .accessibilityLabel("Stress measurement history")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testHistoryListHasAccessibilityLabel() {
        struct TestView: View {
            var body: some View {
                List {
                    Text("Item 1")
                    Text("Item 2")
                }
                .accessibilityLabel("Stress measurements list")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testHistoryListHasAccessibilityHint() {
        let measurementCount = 10
        struct TestView: View {
            let count: Int

            var body: some View {
                List {
                    ForEach(0..<count, id: \.self) { _ in
                        Text("Item")
                    }
                }
                .accessibilityHint("\(count) measurements available")
            }
        }

        let view = TestView(count: measurementCount)
        let _ = view
    }

    @Test func testMeasurementRowHasAccessibilityLabel() {
        struct TestView: View {
            var body: some View {
                Text("Stress measurement")
                    .accessibilityLabel("Stress measurement from 10:30 AM")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testMeasurementRowHasAccessibilityValue() {
        struct TestView: View {
            var body: some View {
                HStack {
                    Text("High Stress")
                    Text("Level 80")
                }
                .accessibilityElement(children: .combine)
                .accessibilityValue("High stress, level 80 out of 100, with 35 milliseconds heart rate variability")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testMeasurementRowHasAccessibilityHint() {
        struct TestView: View {
            var body: some View {
                Text("Measurement")
                    .accessibilityHint("Tap for detailed information about this measurement")
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Accessibility Element Grouping Tests

    @Test func testMeasurementRowCombinesChildren() {
        struct TestView: View {
            var body: some View {
                HStack {
                    Text("Time: 10:30")
                    Text("Level: 50")
                    Text("Category: Moderate")
                }
                .accessibilityElement(children: .combine)
            }
        }

        let view = TestView()
        let _ = view // Children should be combined into single element
    }

    @Test func testStressRingIsAccessibilityElement() {
        struct TestView: View {
            var body: some View {
                StressRingView(stressLevel: 60, category: .moderate)
                    .accessibilityLabel("Stress indicator")
                    .accessibilityValue("60 out of 100")
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Dynamic Accessibility Value Tests

    @Test func testAccessibilityValueReflectsStressLevel() {
        let stressLevels: [Double] = [0, 25, 50, 75, 100]

        for level in stressLevels {
            struct TestView: View {
                let level: Double

                var body: some View {
                    Text("Stress Level")
                        .accessibilityValue("\(Int(level)) out of 100")
                }
            }

            let view = TestView(level: level)
            let _ = view
        }
    }

    @Test func testAccessibilityValueReflectsCategory() {
        let categories: [StressCategory] = [.relaxed, .mild, .moderate, .high]

        for category in categories {
            struct TestView: View {
                let category: StressCategory

                var body: some View {
                    Text("Category")
                        .accessibilityValue("\(category.rawValue) stress")
                }
            }

            let view = TestView(category: category)
            let _ = view
        }
    }

    // MARK: - Button State Accessibility Tests

    @Test func testLoadingButtonAccessibility() {
        struct TestView: View {
            var body: some View {
                Button("Loading") {}
                    .disabled(true)
                    .accessibilityLabel("Measuring stress")
                    .accessibilityHint("Please wait while we calculate your stress level")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testDisabledButtonAccessibility() {
        struct TestView: View {
            var body: some View {
                Button("Disabled") {}
                    .disabled(true)
                    .accessibilityLabel("Measure stress")
                    .accessibilityHint("Not available at this time")
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - VoiceOver Navigation Tests

    @Test func testNavigationTitleIsAccessible() {
        struct TestView: View {
            var body: some View {
                NavigationStack {
                    Text("Content")
                        .navigationTitle("Now")
                }
            }
        }

        let view = TestView()
        let _ = view // Navigation title should be announced by VoiceOver
    }

    @Test func testTabItemsHaveAccessibilityLabels() {
        struct TestView: View {
            var body: some View {
                TabView {
                    Text("Dashboard")
                        .tabItem {
                            Label("Now", systemImage: "heart.fill")
                        }

                    Text("History")
                        .tabItem {
                            Label("History", systemImage: "clock.fill")
                        }
                }
            }
        }

        let view = TestView()
        let _ = view // Tab items should have labels from Label
    }

    // MARK: - Complex View Accessibility Tests

    @Test func testStressRingWithCharacterAccessibility() {
        struct TestView: View {
            var body: some View {
                StressRingView(stressLevel: 45, category: .mild)
                    .accessibilityLabel("Stress level indicator with character animation")
                    .accessibilityValue("45 out of 100, mild stress")
                    .accessibilityHint("Shows your current stress level visually with an animated character")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testMeasurementCardAccessibility() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Time: 10:30 AM")
                    Text("Level: 65")
                    Text("Moderate Stress")
                }
                .accessibilityElement(children: .combine)
                .accessibilityLabel("Stress measurement from 10:30 AM")
                .accessibilityValue("Moderate stress, level 65 out of 100")
                .accessibilityHint("Tap to view details")
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Empty State Accessibility Tests

    @Test func testEmptyStateAccessibility() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("No measurements yet")
                    Button("Measure Now") {}
                }
                .accessibilityLabel("No stress measurements")
                .accessibilityHint("Tap Measure Now to record your first measurement")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testLoadingStateAccessibility() {
        struct TestView: View {
            var body: some View {
                VStack {
                    ProgressView()
                    Text("Loading stress data...")
                }
                .accessibilityLabel("Loading")
                .accessibilityHint("Please wait while we fetch your stress data")
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Error State Accessibility Tests

    @Test func testErrorAlertAccessibility() {
        struct TestView: View {
            @State private var showError = true

            var body: some View {
                Text("Content")
                    .alert("Error", isPresented: $showError) {
                        Button("OK") {
                            showError = false
                        }
                    } message: {
                        Text("Failed to load stress data")
                    }
            }
        }

        let view = TestView()
        let _ = view // Alert should be automatically accessible
    }

    // MARK: - Accessibility Trait Tests

    @Test func testButtonHasButtonTrait() {
        struct TestView: View {
            var body: some View {
                Button("Measure") {}
                    .accessibilityLabel("Measure stress")
            }
        }

        let view = TestView()
        let _ = view // Button should have .button trait
    }

    @Test func testHeaderHasHeaderTrait() {
        struct TestView: View {
            var body: some View {
                Text("Current Stress")
                    .font(.title)
                    .accessibilityAddTraits(.isHeader)
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Accessibility Sorting Priority Tests

    @Test func testImportantElementsHaveHigherPriority() {
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Stress Level: 75")
                        .accessibilityLabel("High stress level")
                        .accessibilitySortPriority(100)

                    Text("Last updated: 5 min ago")
                        .accessibilityLabel("Last update time")
                        .accessibilitySortPriority(50)
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    // MARK: - Integration Tests

    @Test func testAllDashboardElementsHaveAccessibilityLabels() {
        // Verify all interactive elements in dashboard have labels
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Header")
                        .accessibilityLabel("Dashboard header")

                    StressRingView(stressLevel: 50, category: .moderate)
                        .accessibilityLabel("Stress level indicator")

                    Button("Measure") {}
                        .accessibilityLabel("Measure stress")

                    Text("Status")
                        .accessibilityLabel("Current status")
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testAllHistoryElementsHaveAccessibilityLabels() {
        // Verify all interactive elements in history have labels
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("History")
                        .accessibilityLabel("Stress measurement history")

                    List {
                        ForEach(0..<5, id: \.self) { index in
                            Text("Measurement \(index)")
                                .accessibilityLabel("Stress measurement \(index)")
                        }
                    }
                    .accessibilityLabel("Measurements list")
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testAccessibilityLabelsAreDescriptive() {
        // Labels should be clear and descriptive
        let goodLabels = [
            "Stress level indicator",
            "Measure stress button",
            "Stress measurement from 10:30 AM",
            "High stress, level 80 out of 100"
        ]

        for label in goodLabels {
            #expect(label.count > 5, "Label '\(label)' should be descriptive")
            #expect(!label.isEmpty, "Label should not be empty")
        }
    }

    @Test func testAccessibilityValuesProvideContext() {
        // Values should provide current state information
        struct TestView: View {
            let stressLevel: Double = 65
            let category: StressCategory = .moderate

            var body: some View {
                Text("Stress")
                    .accessibilityValue("\(Int(stressLevel)) out of 100, \(category.rawValue) stress")
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testAccessibilityHintsExplainPurpose() {
        // Hints should explain what will happen when activated
        let goodHints = [
            "Tap to calculate your current stress level",
            "Tap for detailed information about this measurement",
            "Visual representation of your current stress level"
        ]

        for hint in goodHints {
            #expect(hint.count > 10, "Hint '\(hint)' should be explanatory")
        }
    }
}

// MARK: - VoiceOver User Experience Tests

@MainActor
struct VoiceOverExperienceTests {

    @Test func testVoiceOverReadingOrder() {
        // Elements should be read in logical order
        struct TestView: View {
            var body: some View {
                VStack {
                    Text("Title")
                        .accessibilityLabel("Dashboard title")
                        .accessibilitySortPriority(100)

                    Text("Subtitle")
                        .accessibilityLabel("Current date")
                        .accessibilitySortPriority(90)

                    Text("Content")
                        .accessibilityLabel("Stress level")
                        .accessibilitySortPriority(80)
                }
            }
        }

        let view = TestView()
        let _ = view
    }

    @Test func testVoiceOverAnnouncesChanges() {
        struct TestView: View {
            @State private var stressLevel = 50

            var body: some View {
                Button("Increase") {
                    stressLevel += 10
                }
                .accessibilityLabel("Stress level: \(stressLevel)")
            }
        }

        let view = TestView()
        let _ = view // State changes should be announced
    }

    @Test func testVoiceOverNavigatesTabBar() {
        struct TestView: View {
            var body: some View {
                TabView {
                    Text("Dashboard")
                        .tabItem {
                            Label("Now", systemImage: "heart.fill")
                        }
                        .accessibilityLabel("Dashboard tab")

                    Text("History")
                        .tabItem {
                            Label("History", systemImage: "clock.fill")
                        }
                        .accessibilityLabel("History tab")
                }
            }
        }

        let view = TestView()
        let _ = view
    }
}

// MARK: - Accessibility Audit Tests

@MainActor
struct AccessibilityAuditTests {

    @Test func testAllInteractiveElementsHaveLabels() {
        // Audit checklist for interactive elements
        let interactiveElements = [
            "Measure stress button",
            "Stress level indicator",
            "Measurement row",
            "Tab bar item",
            "Navigation button"
        ]

        for element in interactiveElements {
            #expect(!element.isEmpty, "\(element) should have accessibility label")
        }
    }

    @Test func testNoRedundantAccessibilityInfo() {
        // Labels should not repeat button type info
        let badLabel = "Measure stress button" // Redundant "button"
        let goodLabel = "Measure stress" // Clean, Button trait adds "button"

        #expect(goodLabel.count < badLabel.count)
    }

    @Test func testAccessibilitySupportsAllStressCategories() {
        for category in StressCategory.allCases {
            struct TestView: View {
                let category: StressCategory

                var body: some View {
                    Text(category.displayName)
                        .accessibilityLabel("\(category.rawValue) stress level")
                }
            }

            let view = TestView(category: category)
            let _ = view
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/BaselineCalculatorTests.swift">
import XCTest
@testable import StressMonitor

final class BaselineCalculatorTests: XCTestCase {

    var calculator: BaselineCalculator!

    override func setUp() {
        super.setUp()
        calculator = BaselineCalculator(minimumSampleCount: 30, timeWindowDays: 30)
    }

    // MARK: - calculateBaseline Tests

    func testCalculateBaselineWithValidSamples() async throws {
        let measurements = (0..<40).map { _ in
            HRVMeasurement(value: Double.random(in: 40...60))
        }

        let baseline = try await calculator.calculateBaseline(from: measurements)

        XCTAssertGreaterThan(baseline.baselineHRV, 0)
        XCTAssertEqual(baseline.restingHeartRate, 60)
    }

    func testCalculateBaselineWithInsufficientSamples() async {
        let measurements = (0..<10).map { _ in
            HRVMeasurement(value: 50)
        }

        do {
            _ = try await calculator.calculateBaseline(from: measurements)
            XCTFail("Should throw insufficientSamples error")
        } catch BaselineCalculatorError.insufficientSamples {
            XCTAssertTrue(true)
        } catch {
            XCTFail("Wrong error type: \(error)")
        }
    }

    func testCalculateBaselineFiltersOutliers() async throws {
        var measurements = (0..<35).map { _ in
            HRVMeasurement(value: Double.random(in: 40...60))
        }

        measurements.append(HRVMeasurement(value: 200))
        measurements.append(HRVMeasurement(value: 5))

        let baseline = try await calculator.calculateBaseline(from: measurements)

        XCTAssertGreaterThan(baseline.baselineHRV, 40)
        XCTAssertLessThan(baseline.baselineHRV, 60)
    }

    // MARK: - calculateRestingHeartRate Tests

    func testCalculateRestingHeartRate() {
        let samples = [
            HeartRateSample(value: 80),
            HeartRateSample(value: 75),
            HeartRateSample(value: 70),
            HeartRateSample(value: 65),
            HeartRateSample(value: 60),
            HeartRateSample(value: 58),
            HeartRateSample(value: 55),
            HeartRateSample(value: 52),
            HeartRateSample(value: 50),
            HeartRateSample(value: 48),
            HeartRateSample(value: 45)
        ]

        let restingHR = calculator.calculateRestingHeartRate(from: samples)
        XCTAssertEqual(restingHR, 48, accuracy: 1)
    }

    func testCalculateRestingHeartRateWithFewSamples() {
        let samples = [
            HeartRateSample(value: 60),
            HeartRateSample(value: 65)
        ]

        let restingHR = calculator.calculateRestingHeartRate(from: samples)
        XCTAssertEqual(restingHR, 60)
    }

    // MARK: - shouldUpdateBaseline Tests

    func testShouldUpdateBaselineAfterWeek() {
        let lastUpdate = Date().addingTimeInterval(-8 * 24 * 60 * 60)
        XCTAssertTrue(calculator.shouldUpdateBaseline(lastUpdate: lastUpdate, samples: 5))
    }

    func testShouldNotUpdateBaselineRecentlyUpdated() {
        let lastUpdate = Date().addingTimeInterval(-3 * 24 * 60 * 60)
        XCTAssertFalse(calculator.shouldUpdateBaseline(lastUpdate: lastUpdate, samples: 5))
    }

    func testShouldUpdateBaselineWithManyNewSamples() {
        let lastUpdate = Date().addingTimeInterval(-3 * 24 * 60 * 60)
        XCTAssertTrue(calculator.shouldUpdateBaseline(lastUpdate: lastUpdate, samples: 15))
    }

    // MARK: - filterOutliers Tests

    func testFilterOutliers() {
        let measurements = [
            HRVMeasurement(value: 45),
            HRVMeasurement(value: 48),
            HRVMeasurement(value: 50),
            HRVMeasurement(value: 52),
            HRVMeasurement(value: 55),
            HRVMeasurement(value: 200),
            HRVMeasurement(value: 5)
        ]

        let filtered = calculator.filterOutliers(measurements)

        XCTAssertFalse(filtered.contains(where: { $0.value == 200 }))
        XCTAssertFalse(filtered.contains(where: { $0.value == 5 }))
        XCTAssertEqual(filtered.count, 5)
    }

    func testFilterOutliersWithSmallDataset() {
        let measurements = [
            HRVMeasurement(value: 45),
            HRVMeasurement(value: 50),
            HRVMeasurement(value: 55)
        ]

        let filtered = calculator.filterOutliers(measurements)
        XCTAssertEqual(filtered.count, 3)
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/HealthKitErrorViewModelTests.swift">
import XCTest
@testable import StressMonitor

@MainActor
final class HealthKitErrorViewModelTests: XCTestCase {
    var viewModel: HealthKitErrorViewModel!

    override func setUp() {
        super.setUp()
        viewModel = HealthKitErrorViewModel()
    }

    override func tearDown() {
        viewModel = nil
        super.tearDown()
    }

    func testOpenSettingsURL() {
        // Test that the method doesn't crash
        XCTAssertNoThrow(viewModel.openSettings(), "Should not throw when opening settings")
    }

    func testDismissToWelcome() {
        // Test that the method doesn't crash
        XCTAssertNoThrow(viewModel.dismissToWelcome(), "Should not throw when dismissing")
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/HealthKitManagerTests.swift">
import Foundation
import Testing
import HealthKit
@testable import StressMonitor

struct HealthKitManagerTests {

    @Test func testHealthKitManager_initialization() async {
        let manager = await HealthKitManager()
        #expect(manager != nil)
    }

    @Test func testHealthKitManager_customHealthStore() async {
        let customStore = HKHealthStore()
        let manager = await HealthKitManager(healthStore: customStore)
        #expect(manager != nil)
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/OnboardingHealthSyncViewModelTests.swift">
import XCTest
import HealthKit
@testable import StressMonitor

@MainActor
final class OnboardingHealthSyncViewModelTests: XCTestCase {
    var viewModel: OnboardingHealthSyncViewModel!
    var mockHealthKitService: MockOnboardingHealthKitService!

    override func setUp() {
        super.setUp()
        mockHealthKitService = MockOnboardingHealthKitService()
        viewModel = OnboardingHealthSyncViewModel(healthKitService: mockHealthKitService)
    }

    override func tearDown() {
        viewModel = nil
        mockHealthKitService = nil
        super.tearDown()
    }

    func testInitialState() {
        XCTAssertFalse(viewModel.isLoading, "Should not be loading initially")
        XCTAssertFalse(viewModel.healthKitAuthorized, "Should not be authorized initially")
        XCTAssertNil(viewModel.authorizationError, "Should not have error initially")
        XCTAssertFalse(viewModel.canProceed, "Should not be able to proceed without authorization")
    }

    func testSuccessfulAuthorization() async {
        mockHealthKitService.shouldSucceed = true

        await viewModel.requestHealthKitAuthorization()

        XCTAssertTrue(viewModel.healthKitAuthorized, "Should be authorized after successful request")
        XCTAssertFalse(viewModel.isLoading, "Should not be loading after request completes")
        XCTAssertNil(viewModel.authorizationError, "Should not have error on success")
        XCTAssertTrue(viewModel.canProceed, "Should be able to proceed after authorization")
    }

    func testFailedAuthorization() async {
        mockHealthKitService.shouldSucceed = false
        mockHealthKitService.errorToThrow = OnboardingHealthKitError.notAvailable

        await viewModel.requestHealthKitAuthorization()

        XCTAssertFalse(viewModel.healthKitAuthorized, "Should not be authorized after failed request")
        XCTAssertFalse(viewModel.isLoading, "Should not be loading after request completes")
        XCTAssertNotNil(viewModel.authorizationError, "Should have error message on failure")
        XCTAssertFalse(viewModel.canProceed, "Should not be able to proceed without authorization")
    }

    func testLoadingStateClearedAfterAuthorization() async {
        mockHealthKitService.shouldSucceed = true

        XCTAssertFalse(viewModel.isLoading, "Should not be loading initially")

        await viewModel.requestHealthKitAuthorization()

        XCTAssertFalse(viewModel.isLoading, "Should not be loading after authorization completes")
    }
}

// Mock HealthKit Service for onboarding tests
final class MockOnboardingHealthKitService: HealthKitServiceProtocol {
    var shouldSucceed = true
    var errorToThrow: Error?

    func requestAuthorization() async throws {
        if !shouldSucceed {
            throw errorToThrow ?? NSError(domain: "TestError", code: -1)
        }
    }

    nonisolated func fetchLatestHRV() async throws -> HRVMeasurement? {
        return nil
    }

    nonisolated func fetchHeartRate(samples: Int) async throws -> [HeartRateSample] {
        return []
    }

    nonisolated func fetchHRVHistory(since: Date) async throws -> [HRVMeasurement] {
        return []
    }

    nonisolated func observeHeartRateUpdates() -> AsyncStream<HeartRateSample?> {
        return AsyncStream { _ in }
    }
}

enum OnboardingHealthKitError: Error {
    case notAvailable
}
</file>

<file path="StressMonitor/StressMonitorTests/OnboardingWelcomeViewModelTests.swift">
import XCTest
@testable import StressMonitor

@MainActor
final class OnboardingWelcomeViewModelTests: XCTestCase {
    var viewModel: OnboardingWelcomeViewModel!

    override func setUp() {
        super.setUp()
        viewModel = OnboardingWelcomeViewModel()
    }

    override func tearDown() {
        viewModel = nil
        super.tearDown()
    }

    func testInitialState() {
        XCTAssertTrue(viewModel.isAnimating, "Animation should start as true")
        XCTAssertFalse(viewModel.navigateToHealthKit, "Should not navigate to HealthKit initially")
        XCTAssertFalse(viewModel.navigateToSignIn, "Should not navigate to sign in initially")
    }

    func testHandleGetStarted() {
        viewModel.handleGetStarted()

        XCTAssertTrue(viewModel.navigateToHealthKit, "Should navigate to HealthKit after get started")
        XCTAssertFalse(viewModel.navigateToSignIn, "Should not navigate to sign in")
    }

    func testHandleSignIn() {
        viewModel.handleSignIn()

        XCTAssertTrue(viewModel.navigateToSignIn, "Should navigate to sign in")
        XCTAssertFalse(viewModel.navigateToHealthKit, "Should not navigate to HealthKit")
    }

    func testAnimationState() {
        let initialAnimationState = viewModel.isAnimating

        viewModel.handleGetStarted()

        XCTAssertEqual(viewModel.isAnimating, initialAnimationState, "Animation state should not change on navigation")
    }
}
</file>

<file path="StressMonitor/StressMonitorUITests/StressMonitorUITests.swift">
//
//  StressMonitorUITests.swift
//  StressMonitorUITests
//
//  Created by Phuong Doan Duy on 18/1/26.
//

import XCTest

final class StressMonitorUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorUITests/StressMonitorUITestsLaunchTests.swift">
//
//  StressMonitorUITestsLaunchTests.swift
//  StressMonitorUITests
//
//  Created by Phuong Doan Duy on 18/1/26.
//

import XCTest

final class StressMonitorUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Intents/OpenWatchAppIntent.swift">
import Foundation
import AppIntents
import WidgetKit

// MARK: - Open Watch App Intent
/// Simple AppIntent for deep linking from complications
/// Enables tappable complications that open the watch app
@available(watchOS 10.0, *)
struct OpenWatchAppIntent: AppIntent {

    // MARK: - AppIntent Configuration
    static var title: LocalizedStringResource = "Open Stress Monitor"
    static var description = IntentDescription("Opens the Stress Monitor app to view detailed stress information.")

    static var openAppWhenRun: Bool = true

    // MARK: - AppIntent Performance
    @MainActor
    func perform() async -> some IntentResult {
        return .result()
    }
}

// MARK: - Target Screen Enum
/// Defines available screens for deep linking
enum TargetScreen: String, AppEnum {
    case dashboard = "dashboard"
    case history = "history"
    case trends = "trends"
    case breathing = "breathing"

    static var typeDisplayRepresentation = TypeDisplayRepresentation(name: "Screen")

    static var caseDisplayRepresentations: [TargetScreen: DisplayRepresentation] = [
        .dashboard: "Dashboard",
        .history: "History",
        .trends: "Trends",
        .breathing: "Breathing"
    ]

    /// Deep link URL for the target screen
    var deepLinkURL: URL {
        switch self {
        case .dashboard:
            return URL(string: "stressmonitor://dashboard")!
        case .history:
            return URL(string: "stressmonitor://history")!
        case .trends:
            return URL(string: "stressmonitor://trends")!
        case .breathing:
            return URL(string: "stressmonitor://breathing")!
        }
    }
}

// MARK: - Complication Refresh Intent
/// Intent to manually refresh all complications
@available(watchOS 10.0, *)
struct RefreshComplicationsIntent: AppIntent {
    static var title: LocalizedStringResource = "Refresh Complications"
    static var description = IntentDescription("Refreshes all watch complications to show the latest data.")

    @MainActor
    func perform() async -> some IntentResult {
        // Reload all complication timelines
        WidgetCenter.shared.reloadAllTimelines()

        return .result(
            dialog: "Complications refreshed"
        )
    }
}

// MARK: - App Shortcuts
/// App shortcuts for quick access from the watch face
@available(watchOS 10.0, *)
struct StressMonitorAppShortcuts: AppShortcutsProvider {
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: OpenWatchAppIntent(),
            phrases: [
                "View stress with \(.applicationName)",
                "Check stress level on \(.applicationName)",
                "Open \(.applicationName) stress"
            ],
            shortTitle: "View Stress",
            systemImageName: "heart.fill"
        )

        AppShortcut(
            intent: RefreshComplicationsIntent(),
            phrases: [
                "Refresh complications with \(.applicationName)"
            ],
            shortTitle: "Refresh",
            systemImageName: "arrow.clockwise"
        )
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Providers/CircularComplicationProvider.swift">
import WidgetKit
import SwiftUI

// MARK: - Circular Complication Provider
/// WidgetKit provider for circular watchOS complications
/// Displays a full-circle stress gauge with color-coded levels
struct CircularComplicationProvider: TimelineProvider {

    // MARK: - TimelineProvider
    /// Placeholder entry during complication loading
    func placeholder(in context: Context) -> CircularComplicationEntry {
        CircularComplicationEntry(
            date: Date(),
            entry: ComplicationEntry.placeholder
        )
    }

    /// Snapshot for complication gallery
    func getSnapshot(in context: Context, completion: @escaping (CircularComplicationEntry) -> Void) {
        let entry = ComplicationDataProvider.shared.fetchLatestEntry()
        completion(CircularComplicationEntry(
            date: Date(),
            entry: entry
        ))
    }

    /// Timeline entries for complication display
    func getTimeline(in context: Context, completion: @escaping (Timeline<CircularComplicationEntry>) -> Void) {
        let entry = ComplicationDataProvider.shared.fetchLatestEntry()
        let nextRefresh = ComplicationDataProvider.shared.nextRefreshDate()

        completion(Timeline(
            entries: [
                CircularComplicationEntry(
                    date: Date(),
                    entry: entry
                )
            ],
            policy: .after(nextRefresh)
        ))
    }
}

// MARK: - Circular Complication Entry
/// Timeline entry for circular complications
struct CircularComplicationEntry: TimelineEntry {
    let date: Date
    let entry: ComplicationEntry
}

// MARK: - Circular Complication View
/// SwiftUI view for circular complication display
struct CircularComplicationView: View {
    @Environment(\.widgetFamily) var family
    let entry: CircularComplicationEntry

    var body: some View {
        ZStack {
            // Background ring
            Circle()
                .stroke(Color.gray.opacity(0.2), lineWidth: 4)

            // Stress level ring with color coding
            Circle()
                .trim(from: 0, to: stressLevelFraction)
                .stroke(
                    stressColor,
                    style: StrokeStyle(
                        lineWidth: 4,
                        lineCap: .round
                    )
                )
                .rotationEffect(.degrees(-90))
                .animation(.easeInOut, value: stressLevelFraction)

            // Center content
            VStack(spacing: 0) {
                if entry.entry.isPlaceholder {
                    Text("--")
                        .font(.system(size: 20, weight: .bold, design: .rounded))
                        .foregroundColor(.gray)
                } else {
                    Text(entry.entry.stressLevelText)
                        .font(.system(size: 20, weight: .bold, design: .rounded))
                        .foregroundColor(stressColor)

                    Text(entry.entry.categoryText)
                        .font(.system(size: 8, weight: .medium))
                        .foregroundColor(.secondary)
                }
            }
        }
        .widgetURL(deepLinkURL)
    }

    // MARK: - Computed Properties
    private var stressLevelFraction: CGFloat {
        CGFloat(entry.entry.stressLevel / 100.0)
    }

    private var stressColor: Color {
        entry.entry.category.color
    }

    private var deepLinkURL: URL? {
        URL(string: "stressmonitor://dashboard")
    }
}

// MARK: - Circular Complication Widget
/// Widget definition for circular complication family
struct CircularComplication: Widget {
    let kind: String = "CircularComplication"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: CircularComplicationProvider()) { entry in
            CircularComplicationView(entry: entry)
                .containerBackground(.fill.tertiary, for: .widget)
        }
        .configurationDisplayName("Stress Ring")
        .description("Shows your current stress level as a color-coded ring")
        .supportedFamilies([.accessoryCircular])
    }
}

// MARK: - Preview
#Preview(as: .accessoryCircular) {
    CircularComplication()
} timeline: {
    CircularComplicationEntry(
        date: Date(),
        entry: ComplicationEntry(
            stressLevel: 25,
            category: .mild,
            hrv: 45,
            heartRate: 68,
            timestamp: Date()
        )
    )
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Providers/InlineComplicationProvider.swift">
import WidgetKit
import SwiftUI

// MARK: - Inline Complication Provider
/// WidgetKit provider for inline watchOS complications
/// Displays text-only stress level for compact inline display
struct InlineComplicationProvider: TimelineProvider {

    // MARK: - TimelineProvider
    /// Placeholder entry during complication loading
    func placeholder(in context: Context) -> InlineComplicationEntry {
        InlineComplicationEntry(
            date: Date(),
            entry: ComplicationEntry.placeholder
        )
    }

    /// Snapshot for complication gallery
    func getSnapshot(in context: Context, completion: @escaping (InlineComplicationEntry) -> Void) {
        let entry = ComplicationDataProvider.shared.fetchLatestEntry()
        completion(InlineComplicationEntry(
            date: Date(),
            entry: entry
        ))
    }

    /// Timeline entries for complication display
    func getTimeline(in context: Context, completion: @escaping (Timeline<InlineComplicationEntry>) -> Void) {
        let entry = ComplicationDataProvider.shared.fetchLatestEntry()
        let nextRefresh = ComplicationDataProvider.shared.nextRefreshDate()

        completion(Timeline(
            entries: [
                InlineComplicationEntry(
                    date: Date(),
                    entry: entry
                )
            ],
            policy: .after(nextRefresh)
        ))
    }
}

// MARK: - Inline Complication Entry
/// Timeline entry for inline complications
struct InlineComplicationEntry: TimelineEntry {
    let date: Date
    let entry: ComplicationEntry
}

// MARK: - Inline Complication View
/// SwiftUI view for inline complication display
struct InlineComplicationView: View {
    let entry: InlineComplicationEntry

    var body: some View {
        HStack(spacing: 4) {
            // Category indicator
            Image(systemName: entry.entry.category.icon)
                .font(.system(size: 12))
                .foregroundColor(stressColor)

            // Stress level
            if entry.entry.isPlaceholder {
                Text("Stress: --")
                    .font(.system(size: 14, weight: .semibold, design: .rounded))
                    .foregroundColor(.secondary)
            } else {
                Text("Stress: \(entry.entry.stressLevelText)")
                    .font(.system(size: 14, weight: .semibold, design: .rounded))
                    .foregroundColor(stressColor)
            }
        }
        .widgetURL(deepLinkURL)
    }

    // MARK: - Computed Properties
    private var stressColor: Color {
        entry.entry.category.color
    }

    private var deepLinkURL: URL? {
        URL(string: "stressmonitor://dashboard")
    }
}

// MARK: - Inline Complication Widget
/// Widget definition for inline complication family
struct InlineComplication: Widget {
    let kind: String = "InlineComplication"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: InlineComplicationProvider()) { entry in
            InlineComplicationView(entry: entry)
                .containerBackground(.fill.tertiary, for: .widget)
        }
        .configurationDisplayName("Stress Level")
        .description("Shows your current stress level at a glance")
        .supportedFamilies([.accessoryInline])
    }
}

// MARK: - Preview
#Preview(as: .accessoryInline) {
    InlineComplication()
} timeline: {
    InlineComplicationEntry(
        date: Date(),
        entry: ComplicationEntry(
            stressLevel: 25,
            category: .mild,
            hrv: 45,
            heartRate: 68,
            timestamp: Date()
        )
    )
}

#Preview("High Stress") {
    InlineComplicationView(entry: InlineComplicationEntry(
        date: Date(),
        entry: ComplicationEntry(
            stressLevel: 82,
            category: .high,
            hrv: 25,
            heartRate: 98,
            timestamp: Date()
        )
    ))
    .previewContext(WidgetPreviewContext(family: .accessoryInline))
}

#Preview("Relaxed") {
    InlineComplicationView(entry: InlineComplicationEntry(
        date: Date(),
        entry: ComplicationEntry(
            stressLevel: 12,
            category: .relaxed,
            hrv: 68,
            heartRate: 54,
            timestamp: Date()
        )
    ))
    .previewContext(WidgetPreviewContext(family: .accessoryInline))
}

#Preview("Placeholder") {
    InlineComplicationView(entry: InlineComplicationEntry(
        date: Date(),
        entry: ComplicationEntry.placeholder
    ))
    .previewContext(WidgetPreviewContext(family: .accessoryInline))
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Providers/RectangularComplicationProvider.swift">
import WidgetKit
import SwiftUI

// MARK: - Rectangular Complication Provider
/// WidgetKit provider for rectangular watchOS complications
/// Displays stress score with HRV trend in a compact rectangular layout
struct RectangularComplicationProvider: TimelineProvider {

    // MARK: - TimelineProvider
    /// Placeholder entry during complication loading
    func placeholder(in context: Context) -> RectangularComplicationEntry {
        RectangularComplicationEntry(
            date: Date(),
            entry: ComplicationEntry.placeholder
        )
    }

    /// Snapshot for complication gallery
    func getSnapshot(in context: Context, completion: @escaping (RectangularComplicationEntry) -> Void) {
        let entry = ComplicationDataProvider.shared.fetchLatestEntry()
        completion(RectangularComplicationEntry(
            date: Date(),
            entry: entry
        ))
    }

    /// Timeline entries for complication display
    func getTimeline(in context: Context, completion: @escaping (Timeline<RectangularComplicationEntry>) -> Void) {
        let entry = ComplicationDataProvider.shared.fetchLatestEntry()
        let nextRefresh = ComplicationDataProvider.shared.nextRefreshDate()

        completion(Timeline(
            entries: [
                RectangularComplicationEntry(
                    date: Date(),
                    entry: entry
                )
            ],
            policy: .after(nextRefresh)
        ))
    }
}

// MARK: - Rectangular Complication Entry
/// Timeline entry for rectangular complications
struct RectangularComplicationEntry: TimelineEntry {
    let date: Date
    let entry: ComplicationEntry
}

// MARK: - Rectangular Complication View
/// SwiftUI view for rectangular complication display
struct RectangularComplicationView: View {
    let entry: RectangularComplicationEntry

    var body: some View {
        HStack(spacing: 8) {
            // Leading: Stress level indicator
            leadingSection

            Spacer(minLength: 4)

            // Middle: Current stress level
            middleSection

            Spacer(minLength: 4)

            // Trailing: HRV value
            trailingSection
        }
        .widgetURL(deepLinkURL)
    }

    // MARK: - View Sections
    /// Leading section with icon indicator
    private var leadingSection: some View {
        ZStack {
            Circle()
                .fill(stressColor.opacity(0.15))

            Image(systemName: entry.entry.category.icon)
                .font(.system(size: 10))
                .foregroundColor(stressColor)
        }
        .frame(width: 24, height: 24)
    }

    /// Middle section with stress level and label
    private var middleSection: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text("Stress")
                .font(.system(size: 9, weight: .medium))
                .foregroundColor(.secondary)

            if entry.entry.isPlaceholder {
                Text("--")
                    .font(.system(size: 16, weight: .bold, design: .rounded))
                    .foregroundColor(.secondary)
            } else {
                Text(entry.entry.stressLevelText)
                    .font(.system(size: 16, weight: .bold, design: .rounded))
                    .foregroundColor(stressColor)
                    .contentTransition(.numericText(value: entry.entry.stressLevel))
            }
        }
    }

    /// Trailing section with HRV value
    private var trailingSection: some View {
        VStack(alignment: .trailing, spacing: 2) {
            Text("HRV")
                .font(.system(size: 9, weight: .medium))
                .foregroundColor(.secondary)

            if entry.entry.isPlaceholder {
                Text("--")
                    .font(.system(size: 12, weight: .semibold, design: .rounded))
                    .foregroundColor(.secondary)
            } else {
                Text(entry.entry.hrvText)
                    .font(.system(size: 12, weight: .semibold, design: .rounded))
                    .foregroundColor(.primary)
                +
                Text(" ms")
                    .font(.system(size: 9, weight: .regular))
                    .foregroundColor(.secondary)
            }
        }
    }

    // MARK: - Computed Properties
    private var stressColor: Color {
        entry.entry.category.color
    }

    private var deepLinkURL: URL? {
        URL(string: "stressmonitor://dashboard")
    }
}

// MARK: - Rectangular Complication Widget
/// Widget definition for rectangular complication family
struct RectangularComplication: Widget {
    let kind: String = "RectangularComplication"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: RectangularComplicationProvider()) { entry in
            RectangularComplicationView(entry: entry)
                .containerBackground(.fill.tertiary, for: .widget)
        }
        .configurationDisplayName("Stress & HRV")
        .description("Shows your current stress level and HRV measurement")
        .supportedFamilies([.accessoryRectangular])
    }
}

// MARK: - Preview
#Preview(as: .accessoryRectangular) {
    RectangularComplication()
} timeline: {
    RectangularComplicationEntry(
        date: Date(),
        entry: ComplicationEntry(
            stressLevel: 25,
            category: .mild,
            hrv: 45,
            heartRate: 68,
            timestamp: Date()
        )
    )
}

#Preview("High Stress") {
    RectangularComplicationView(entry: RectangularComplicationEntry(
        date: Date(),
        entry: ComplicationEntry(
            stressLevel: 78,
            category: .high,
            hrv: 28,
            heartRate: 92,
            timestamp: Date()
        )
    ))
    .previewContext(WidgetPreviewContext(family: .accessoryRectangular))
}

#Preview("Placeholder") {
    RectangularComplicationView(entry: RectangularComplicationEntry(
        date: Date(),
        entry: ComplicationEntry.placeholder
    ))
    .previewContext(WidgetPreviewContext(family: .accessoryRectangular))
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Services/ComplicationDataProvider.swift">
import Foundation
import WidgetKit

// MARK: - Complication Data Provider
/// Provides stress data to complications via App Groups UserDefaults
/// Enables standalone operation without requiring iPhone connection
final class ComplicationDataProvider {

    // MARK: - Properties
    static let shared = ComplicationDataProvider()

    /// App Groups suite identifier for data sharing
    /// Must match entitlements configuration
    private let suiteName = "group.com.stressmonitor.watch"

    /// UserDefaults instance with App Groups access
    private let defaults: UserDefaults?

    /// Device identifier for standalone tracking
    private let deviceID: String

    // MARK: - Initialization
    private init() {
        // Initialize App Groups UserDefaults
        self.defaults = UserDefaults(suiteName: suiteName)

        // Get or create device identifier
        if let existingID = defaults?.string(forKey: Keys.deviceID) {
            self.deviceID = existingID
        } else {
            self.deviceID = UUID().uuidString
            defaults?.set(deviceID, forKey: Keys.deviceID)
        }
    }

    // MARK: - Public API
    /// Fetch the latest stress measurement for complication display
    /// - Returns: ComplicationEntry with current stress data or placeholder
    func fetchLatestEntry() -> ComplicationEntry {
        guard let defaults = defaults,
              let data = defaults.data(forKey: Keys.latestMeasurement),
              let measurement = try? JSONDecoder().decode(StoredMeasurement.self, from: data) else {
            return ComplicationEntry.placeholder
        }

        return ComplicationEntry(
            stressLevel: measurement.stressLevel,
            category: measurement.category,
            hrv: measurement.hrv,
            heartRate: measurement.heartRate,
            timestamp: measurement.timestamp
        )
    }

    /// Save a new stress measurement for complications
    /// - Parameter measurement: StressResult to store
    func saveMeasurement(_ measurement: StressResult) {
        guard let defaults = defaults else { return }

        let stored = StoredMeasurement(from: measurement)

        if let data = try? JSONEncoder().encode(stored) {
            defaults.set(data, forKey: Keys.latestMeasurement)
            defaults.synchronize()

            // Notify WidgetKit of data change
            WidgetCenter.shared.reloadTimelines(ofKind: "CircularComplication")
            WidgetCenter.shared.reloadTimelines(ofKind: "RectangularComplication")
            WidgetCenter.shared.reloadTimelines(ofKind: "InlineComplication")
        }
    }

    /// Get the next scheduled timeline refresh date
    /// - Returns: Date for next refresh within WidgetKit budget
    func nextRefreshDate() -> Date {
        // Refresh every 30 minutes to stay within budget
        // WidgetKit allows ~50 refreshes per day per complication
        return Date().addingTimeInterval(30 * 60)
    }

    /// Check if complications should show placeholder data
    /// - Returns: Boolean indicating if no data is available
    var shouldShowPlaceholder: Bool {
        defaults?.object(forKey: Keys.latestMeasurement) == nil
    }

    /// Clear all stored complication data
    func clearData() {
        defaults?.removeObject(forKey: Keys.latestMeasurement)
        defaults?.synchronize()

        WidgetCenter.shared.reloadAllTimelines()
    }

    // MARK: - Types
    /// Storage keys for UserDefaults
    enum Keys {
        static let latestMeasurement = "latestStressMeasurement"
        static let deviceID = "complicationDeviceID"
    }

    /// Codable wrapper for stress measurements
    struct StoredMeasurement: Codable {
        let stressLevel: Double
        let category: StressCategory
        let hrv: Double
        let heartRate: Double
        let timestamp: Date

        init(from result: StressResult) {
            self.stressLevel = result.level
            self.category = result.category
            self.hrv = result.hrv
            self.heartRate = result.heartRate
            self.timestamp = result.timestamp
        }
    }
}

// MARK: - Complication Entry Model
/// Simplified stress data model for complication timeline entries
struct ComplicationEntry {
    let stressLevel: Double
    let category: StressCategory
    let hrv: Double
    let heartRate: Double
    let timestamp: Date

    /// Placeholder entry when no data is available
    static let placeholder = ComplicationEntry(
        stressLevel: 0,
        category: .relaxed,
        hrv: 0,
        heartRate: 0,
        timestamp: Date()
    )

    /// Boolean indicating if this is placeholder data
    var isPlaceholder: Bool {
        stressLevel == 0 && hrv == 0 && heartRate == 0
    }

    /// Display text for stress level
    var stressLevelText: String {
        isPlaceholder ? "--" : "\(Int(stressLevel))"
    }

    /// Display text for HRV value
    var hrvText: String {
        isPlaceholder ? "--" : String(format: "%.0f", hrv)
    }

    /// Display text for category
    var categoryText: String {
        isPlaceholder ? "No Data" : category.rawValue.capitalized
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Views/CircularStressView.swift">
import SwiftUI

// MARK: - Circular Stress View
/// SwiftUI view component for circular stress display
/// Provides a reusable view that can be used in both complications and the main app
struct CircularStressView: View {
    let stressLevel: Double
    let category: StressCategory
    let showLabel: Bool
    let size: CGFloat

    init(
        stressLevel: Double,
        category: StressCategory,
        showLabel: Bool = true,
        size: CGFloat = 120
    ) {
        self.stressLevel = stressLevel
        self.category = category
        self.showLabel = showLabel
        self.size = size
    }

    var body: some View {
        ZStack {
            // Background ring (full circle, subtle gray)
            Circle()
                .stroke(
                    Color.gray.opacity(0.15),
                    style: StrokeStyle(lineWidth: ringWidth, lineCap: .round)
                )

            // Stress level ring (color-coded, partial fill)
            Circle()
                .trim(from: 0, to: stressFraction)
                .stroke(
                    category.color,
                    style: StrokeStyle(lineWidth: ringWidth, lineCap: .round)
                )
                .rotationEffect(.degrees(-90))
                .animation(.spring(response: 0.6, dampingFraction: 0.8), value: stressFraction)

            // Center content
            VStack(spacing: verticalSpacing) {
                // Stress level number
                Text(stressLevelText)
                    .font(.system(size: textSize, weight: .bold, design: .rounded))
                    .foregroundColor(category.color)
                    .contentTransition(.numericText(value: stressLevel))

                // Category label (optional)
                if showLabel {
                    Text(category.label)
                        .font(.system(size: labelSize, weight: .medium))
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                        .minimumScaleFactor(0.7)
                }
            }
        }
        .frame(width: size, height: size)
    }

    // MARK: - Layout Constants
    private var ringWidth: CGFloat { size * 0.08 }
    private var textSize: CGFloat { size * 0.22 }
    private var labelSize: CGFloat { size * 0.10 }
    private var verticalSpacing: CGFloat { size * 0.02 }

    // MARK: - Computed Properties
    private var stressFraction: CGFloat {
        CGFloat(min(max(stressLevel, 0), 100) / 100.0)
    }

    private var stressLevelText: String {
        Int(stressLevel).description
    }
}

// MARK: - Stress Category Extension
extension StressCategory {
    /// Human-readable label for the category
    var label: String {
        switch self {
        case .relaxed: return "Relaxed"
        case .mild: return "Mild"
        case .moderate: return "Moderate"
        case .high: return "High"
        }
    }
}

// MARK: - Preview
#Preview("Relaxed") {
    CircularStressView(
        stressLevel: 15,
        category: .relaxed
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Mild") {
    CircularStressView(
        stressLevel: 35,
        category: .mild
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Moderate") {
    CircularStressView(
        stressLevel: 60,
        category: .moderate
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("High") {
    CircularStressView(
        stressLevel: 85,
        category: .high
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Compact") {
    CircularStressView(
        stressLevel: 45,
        category: .mild,
        showLabel: false,
        size: 60
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Watch Size") {
    HStack(spacing: 20) {
        CircularStressView(
            stressLevel: 25,
            category: .relaxed,
            size: 80
        )

        CircularStressView(
            stressLevel: 50,
            category: .moderate,
            size: 80
        )

        CircularStressView(
            stressLevel: 75,
            category: .high,
            size: 80
        )
    }
    .padding()
    .previewLayout(.sizeThatFits)
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Views/InlineStressView.swift">
import SwiftUI

// MARK: - Inline Stress View
/// SwiftUI view component for inline stress display
/// Provides a compact, text-only view for minimal space requirements
struct InlineStressView: View {
    let stressLevel: Double
    let category: StressCategory
    let showIcon: Bool
    let showLabel: Bool

    init(
        stressLevel: Double,
        category: StressCategory,
        showIcon: Bool = true,
        showLabel: Bool = true
    ) {
        self.stressLevel = stressLevel
        self.category = category
        self.showIcon = showIcon
        self.showLabel = showLabel
    }

    var body: some View {
        HStack(spacing: 4) {
            // Optional category icon
            if showIcon {
                Image(systemName: category.icon)
                    .font(.system(size: 12))
                    .foregroundColor(category.color)
            }

            // Stress display text
            if hasData {
                if showLabel {
                    Text("Stress: ")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.secondary) +
                    Text(stressLevelText)
                        .font(.system(size: 14, weight: .semibold, design: .rounded))
                        .foregroundColor(category.color)
                } else {
                    Text(stressLevelText)
                        .font(.system(size: 14, weight: .semibold, design: .rounded))
                        .foregroundColor(category.color)
                }
            } else {
                if showLabel {
                    Text("Stress: --")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.secondary)
                } else {
                    Text("--")
                        .font(.system(size: 14, weight: .semibold, design: .rounded))
                        .foregroundColor(.secondary)
                }
            }
        }
        .lineLimit(1)
        .minimumScaleFactor(0.7)
    }

    // MARK: - Computed Properties
    private var stressLevelText: String {
        Int(stressLevel).description
    }

    private var hasData: Bool {
        stressLevel > 0
    }
}

// MARK: - Stress Label Component
/// Alternative component showing category instead of number
struct StressLabelInlineView: View {
    let category: StressCategory
    let showIcon: Bool

    init(category: StressCategory, showIcon: Bool = true) {
        self.category = category
        self.showIcon = showIcon
    }

    var body: some View {
        HStack(spacing: 4) {
            if showIcon {
                Image(systemName: category.icon)
                    .font(.system(size: 12))
                    .foregroundColor(category.color)
            }

            Text(category.label)
                .font(.system(size: 14, weight: .semibold))
                .foregroundColor(category.color)
        }
        .lineLimit(1)
    }
}

// MARK: - Preview
#Preview("Mild Stress") {
    InlineStressView(
        stressLevel: 35,
        category: .mild
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("High Stress") {
    InlineStressView(
        stressLevel: 88,
        category: .high
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Relaxed") {
    InlineStressView(
        stressLevel: 15,
        category: .relaxed
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Moderate") {
    InlineStressView(
        stressLevel: 62,
        category: .moderate
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("No Icon") {
    InlineStressView(
        stressLevel: 45,
        category: .moderate,
        showIcon: false
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Number Only") {
    InlineStressView(
        stressLevel: 50,
        category: .moderate,
        showIcon: false,
        showLabel: false
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("No Data") {
    InlineStressView(
        stressLevel: 0,
        category: .relaxed
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Category Label") {
    StressLabelInlineView(
        category: .high
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("All Categories") {
    VStack(alignment: .leading, spacing: 8) {
        InlineStressView(stressLevel: 12, category: .relaxed)
        InlineStressView(stressLevel: 35, category: .mild)
        InlineStressView(stressLevel: 58, category: .moderate)
        InlineStressView(stressLevel: 82, category: .high)
    }
    .padding()
    .previewLayout(.sizeThatFits)
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/Views/RectangularStressView.swift">
import SwiftUI

// MARK: - Rectangular Stress View
/// SwiftUI view component for rectangular stress display
/// Provides a reusable view for showing stress metrics in a compact layout
struct RectangularStressView: View {
    let stressLevel: Double
    let category: StressCategory
    let hrv: Double
    let heartRate: Double
    let width: CGFloat
    let height: CGFloat

    init(
        stressLevel: Double,
        category: StressCategory,
        hrv: Double,
        heartRate: Double,
        width: CGFloat = 160,
        height: CGFloat = 80
    ) {
        self.stressLevel = stressLevel
        self.category = category
        self.hrv = hrv
        self.heartRate = heartRate
        self.width = width
        self.height = height
    }

    var body: some View {
        HStack(spacing: horizontalSpacing) {
            // Left: Stress level indicator
            stressIndicator

            Spacer(minLength: 4)

            // Center: Current stress level
            stressLevelDisplay

            Spacer(minLength: 4)

            // Right: Health metrics
            healthMetrics
        }
        .frame(width: width, height: height)
        .padding(.horizontal, horizontalPadding)
        .padding(.vertical, verticalPadding)
    }

    // MARK: - View Components
    /// Stress level indicator with icon
    private var stressIndicator: some View {
        ZStack {
            Circle()
                .fill(category.color.opacity(0.15))

            Image(systemName: category.icon)
                .font(.system(size: iconSize))
                .foregroundColor(category.color)
        }
        .frame(width: indicatorSize, height: indicatorSize)
    }

    /// Stress level number display
    private var stressLevelDisplay: some View {
        VStack(alignment: .leading, spacing: verticalTextSpacing) {
            Text("Stress")
                .font(.system(size: labelSize, weight: .medium))
                .foregroundColor(.secondary)

            Text(stressLevelText)
                .font(.system(size: valueSize, weight: .bold, design: .rounded))
                .foregroundColor(category.color)
        }
    }

    /// Health metrics (HRV and heart rate)
    private var healthMetrics: some View {
        VStack(alignment: .trailing, spacing: verticalTextSpacing) {
            Text("HRV")
                .font(.system(size: metricLabelSize, weight: .medium))
                .foregroundColor(.secondary)

            HStack(spacing: 2) {
                Text(hrvText)
                    .font(.system(size: metricValueSize, weight: .semibold, design: .rounded))
                    .foregroundColor(.primary)

                Text("ms")
                    .font(.system(size: unitSize, weight: .regular))
                    .foregroundColor(.secondary)
            }

            // Heart rate (optional, shown if space allows)
            if height >= 70 {
                HStack(spacing: 2) {
                    Text(heartRateText)
                        .font(.system(size: metricValueSize, weight: .semibold, design: .rounded))
                        .foregroundColor(.primary)

                    Text("bpm")
                        .font(.system(size: unitSize, weight: .regular))
                        .foregroundColor(.secondary)
                }
            }
        }
    }

    // MARK: - Layout Constants (computed from size)
    private var horizontalSpacing: CGFloat { width * 0.05 }
    private var horizontalPadding: CGFloat { width * 0.04 }
    private var verticalPadding: CGFloat { height * 0.05 }

    private var indicatorSize: CGFloat { min(width, height) * 0.25 }
    private var iconSize: CGFloat { min(width, height) * 0.10 }

    private var labelSize: CGFloat { height * 0.14 }
    private var valueSize: CGFloat { height * 0.24 }
    private var metricLabelSize: CGFloat { height * 0.12 }
    private var metricValueSize: CGFloat { height * 0.18 }
    private var unitSize: CGFloat { height * 0.11 }
    private var verticalTextSpacing: CGFloat { height * 0.04 }

    // MARK: - Computed Properties
    private var stressLevelText: String {
        hasData ? Int(stressLevel).description : "--"
    }

    private var hrvText: String {
        hasData ? String(format: "%.0f", hrv) : "--"
    }

    private var heartRateText: String {
        hasData ? String(format: "%.0f", heartRate) : "--"
    }

    private var hasData: Bool {
        stressLevel > 0 || hrv > 0
    }
}

// MARK: - Preview
#Preview("Mild Stress") {
    RectangularStressView(
        stressLevel: 32,
        category: .mild,
        hrv: 48,
        heartRate: 72
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("High Stress") {
    RectangularStressView(
        stressLevel: 85,
        category: .high,
        hrv: 22,
        heartRate: 95
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Relaxed") {
    RectangularStressView(
        stressLevel: 18,
        category: .relaxed,
        hrv: 65,
        heartRate: 58
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("No Data") {
    RectangularStressView(
        stressLevel: 0,
        category: .relaxed,
        hrv: 0,
        heartRate: 0
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Compact") {
    RectangularStressView(
        stressLevel: 45,
        category: .moderate,
        hrv: 38,
        heartRate: 78,
        width: 140,
        height: 60
    )
    .previewLayout(.sizeThatFits)
    .padding()
}

#Preview("Large") {
    RectangularStressView(
        stressLevel: 62,
        category: .moderate,
        hrv: 35,
        heartRate: 82,
        width: 200,
        height: 100
    )
    .previewLayout(.sizeThatFits)
    .padding()
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Complications/ComplicationBundle.swift">
import WidgetKit
import SwiftUI

// MARK: - Complication Bundle
/// WidgetKit bundle configuration for watchOS complications
/// Manages all complication families: Circular, Rectangular, and Inline
struct ComplicationBundle: WidgetBundle {
    var body: some Widget {
        CircularComplication()
        RectangularComplication()
        InlineComplication()
    }
}

// MARK: - Widget Configuration
extension ComplicationBundle {
    /// Supported complication families for watchOS 10+
    static var supportedFamilies: [WidgetFamily] {
        if #available(watchOS 10.0, *) {
            return [
                .accessoryCircular,
                .accessoryRectangular,
                .accessoryInline
            ]
        } else {
            return []
        }
    }
}

// MARK: - Timeline Update Policy
extension ComplicationBundle {
    /// WidgetKit timeline refresh policy
    /// Complications update every 15-30 minutes to stay within budget
    static var timelinePolicy: TimelineReloadPolicy {
        .atEnd
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Models/HeartRateSample.swift">
import Foundation

struct HeartRateSample: Identifiable, Codable, Sendable {
    let id: UUID
    let value: Double
    let timestamp: Date

    init(value: Double, timestamp: Date = Date()) {
        self.id = UUID()
        self.value = value
        self.timestamp = timestamp
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Models/HRVMeasurement.swift">
import Foundation

struct HRVMeasurement: Identifiable, Codable, Sendable {
    let id: UUID
    let value: Double
    let timestamp: Date
    let unit: String

    init(value: Double, timestamp: Date = Date()) {
        self.id = UUID()
        self.value = value
        self.timestamp = timestamp
        self.unit = "ms"
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Models/PersonalBaseline.swift">
import Foundation

struct PersonalBaseline: Codable, Sendable {
    var restingHeartRate: Double
    var baselineHRV: Double
    var lastUpdated: Date

    init(restingHeartRate: Double = 60.0, baselineHRV: Double = 50.0, lastUpdated: Date = Date()) {
        self.restingHeartRate = restingHeartRate
        self.baselineHRV = baselineHRV
        self.lastUpdated = lastUpdated
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Models/StressMeasurement.swift">
import Foundation
import SwiftUI

@Observable
public final class WatchStressMeasurement: Sendable {
    public let timestamp: Date
    public let stressLevel: Double
    public let hrv: Double
    public let restingHeartRate: Double
    public private(set) var categoryRawValue: String
    public let confidences: [Double]?

    public init(
        timestamp: Date,
        stressLevel: Double,
        hrv: Double,
        restingHeartRate: Double,
        confidences: [Double]? = nil
    ) {
        self.timestamp = timestamp
        self.stressLevel = stressLevel
        self.hrv = hrv
        self.restingHeartRate = restingHeartRate
        self.categoryRawValue = (WatchStressCategory(rawValue: Int(stressLevel)) ?? .mild).rawValue
        self.confidences = confidences
    }

    public var category: WatchStressCategory {
        get { WatchStressCategory(rawValue: Int(stressLevel)) ?? .mild }
        set { categoryRawValue = newValue.rawValue }
    }
}

public enum WatchStressCategory: Int, Sendable {
    case relaxed = 0
    case mild = 25
    case moderate = 50
    case high = 75

    public var rawValue: String {
        switch self {
        case .relaxed: return "relaxed"
        case .mild: return "mild"
        case .moderate: return "moderate"
        case .high: return "high"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Models/StressResult.swift">
import Foundation

struct StressResult: Identifiable, Codable, Sendable {
    let id: UUID
    let level: Double
    let category: StressCategory
    let confidence: Double
    let hrv: Double
    let heartRate: Double
    let timestamp: Date

    init(level: Double, category: StressCategory, confidence: Double, hrv: Double, heartRate: Double, timestamp: Date = Date()) {
        self.id = UUID()
        self.level = level
        self.category = category
        self.confidence = confidence
        self.hrv = hrv
        self.heartRate = heartRate
        self.timestamp = timestamp
    }

    static func category(for level: Double) -> StressCategory {
        switch level {
        case 0..<25: return .relaxed
        case 25..<50: return .mild
        case 50..<75: return .moderate
        default: return .high
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/CloudKit/WatchCloudKitManager.swift">
import CloudKit
import Foundation
import Observation

@MainActor
@Observable
public final class WatchCloudKitManager: CloudKitServiceProtocol {
    // MARK: - Properties

    public private(set) var syncStatus: SyncStatus = .idle
    public private(set) var lastSyncDate: Date?

    private let container: CKContainer
    private let sharedDatabase: CKDatabase
    private let deviceID: String
    private let syncThrottleInterval: TimeInterval

    private var lastSyncAttempt: Date?
    private var subscriptionID = "com.stressmonitor.watch.subscription"

    // MARK: - Initialization

    public init(
        container: CKContainer = .default(),
        syncThrottleInterval: TimeInterval = 300.0 // 5 minutes
    ) {
        self.container = container
        self.sharedDatabase = container.sharedCloudDatabase
        self.deviceID = Self.getWatchDeviceID()
        self.syncThrottleInterval = syncThrottleInterval
    }

    // MARK: - Watch Device ID

    private static func getWatchDeviceID() -> String {
        let key = "com.stressmonitor.watch.deviceID"

        if let existingID = UserDefaults.standard.string(forKey: key) {
            return existingID
        }

        // Prefix with watch- for device priority resolution
        let newID = "watch-\(UUID().uuidString)"
        UserDefaults.standard.set(newID, forKey: key)
        return newID
    }

    // MARK: - Save Measurement

    public func saveMeasurement(_ measurement: WatchStressMeasurement) async throws {
        syncStatus = .syncing(progress: 0.0)

        let record = CKRecord(recordType: CloudKitRecordType.stressMeasurement.rawValue)
        record["timestamp"] = measurement.timestamp
        record["stressLevel"] = measurement.stressLevel
        record["hrv"] = measurement.hrv
        record["restingHeartRate"] = measurement.restingHeartRate
        record["category"] = measurement.categoryRawValue
        record["confidences"] = measurement.confidences ?? []
        record["deviceID"] = deviceID
        record["isDeleted"] = false
        record["cloudKitModTime"] = Date()

        do {
            try await sharedDatabase.save(record)
            lastSyncDate = Date()
            syncStatus = .success
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Fetch Measurements

    public func fetchMeasurements(since date: Date? = nil) async throws -> [WatchStressMeasurement] {
        // Throttle sync requests to save battery
        if let lastAttempt = lastSyncAttempt,
           Date().timeIntervalSince(lastAttempt) < syncThrottleInterval {
            return []
        }

        lastSyncAttempt = Date()
        syncStatus = .syncing(progress: 0.0)

        let predicate: NSPredicate
        if let sinceDate = date {
            predicate = NSPredicate(format: "timestamp >= %@", sinceDate as NSDate)
        } else {
            predicate = NSPredicate(value: true)
        }

        let query = CKQuery(recordType: CloudKitRecordType.stressMeasurement.rawValue, predicate: predicate)
        query.sortDescriptors = [NSSortDescriptor(key: "timestamp", ascending: false)]

        do {
            let (matchResults, _) = try await sharedDatabase.records(matching: query)

            var measurements: [WatchStressMeasurement] = []
            for (_, result) in matchResults {
                switch result {
                case .success(let record):
                    if let measurement = self.convertRecordToMeasurement(record) {
                        measurements.append(measurement)
                    }
                case .failure:
                    continue
                }
            }

            lastSyncDate = Date()
            syncStatus = .success
            return measurements
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Delete Measurement

    public func deleteMeasurement(_ measurement: WatchStressMeasurement) async throws {
        syncStatus = .syncing(progress: 0.0)

        let predicate = NSPredicate(format: "timestamp == %@ AND deviceID == %@",
                                    measurement.timestamp as NSDate,
                                    deviceID as NSString)
        let query = CKQuery(recordType: CloudKitRecordType.stressMeasurement.rawValue, predicate: predicate)

        do {
            let (matchResults, _) = try await sharedDatabase.records(matching: query)

            for (recordID, result) in matchResults {
                switch result {
                case .success:
                    try await sharedDatabase.deleteRecord(withID: recordID)
                case .failure:
                    continue
                }
            }

            lastSyncDate = Date()
            syncStatus = .success
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Sync

    public func sync() async throws {
        syncStatus = .syncing(progress: 0.0)

        do {
            _ = try await fetchMeasurements()
            lastSyncDate = Date()
            syncStatus = .success
        } catch let error as CKError {
            syncStatus = .error(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Batch Operations (Smaller for Watch)

    public func saveBatchMeasurements(_ measurements: [WatchStressMeasurement]) async throws {
        guard !measurements.isEmpty else { return }

        // Watch uses smaller batch size (5 instead of 10)
        let batchSize = 5
        let batches = measurements.chunked(into: batchSize)

        for batch in batches {
            try await saveBatch(batch)
        }
    }

    private func saveBatch(_ batch: [WatchStressMeasurement]) async throws {
        let records = batch.map { measurement -> CKRecord in
            let record = CKRecord(recordType: CloudKitRecordType.stressMeasurement.rawValue)
            record["timestamp"] = measurement.timestamp
            record["stressLevel"] = measurement.stressLevel
            record["hrv"] = measurement.hrv
            record["restingHeartRate"] = measurement.restingHeartRate
            record["category"] = measurement.categoryRawValue
            record["confidences"] = measurement.confidences ?? []
            record["deviceID"] = deviceID
            record["isDeleted"] = false
            record["cloudKitModTime"] = Date()
            return record
        }

        let operation = CKModifyRecordsOperation(recordsToSave: records, recordIDsToDelete: nil)

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            operation.modifyRecordsResultBlock = { result in
                switch result {
                case .success:
                    continuation.resume()
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }

            sharedDatabase.add(operation)
        }
    }

    // MARK: - Push Subscription

    public func setupPushSubscription() async throws {
        let subscription = CKQuerySubscription(
            recordType: CloudKitRecordType.stressMeasurement.rawValue,
            predicate: NSPredicate(value: true),
            subscriptionID: subscriptionID,
            options: [.firesOnRecordCreation, .firesOnRecordUpdate]
        )

        let notificationInfo = CKSubscription.NotificationInfo()
        notificationInfo.shouldSendContentAvailable = true
        notificationInfo.alertBody = "New stress measurements available"
        subscription.notificationInfo = notificationInfo

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            sharedDatabase.save(subscription) { _, error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume()
                }
            }
        }
    }

    // MARK: - Account Status

    public func checkAccountStatus() async throws -> CloudKitAccountStatus {
        do {
            let accountStatus = try await container.accountStatus()

            switch accountStatus {
            case .available:
                return .available
            case .noAccount:
                return .noAccount
            case .restricted:
                return .restricted
            case .couldNotDetermine:
                return .unknown
            case .temporarilyUnavailable:
                return .unknown
            @unknown default:
                return .unknown
            }
        } catch let error as CKError {
            throw adaptCloudKitError(error)
        }
    }

    // MARK: - Standalone Operation Support

    public func canPerformStandaloneSync() async -> Bool {
        let accountStatus = try? await checkAccountStatus()
        return accountStatus == .available
    }

    // MARK: - Battery-Aware Sync

    public func shouldSyncNow() async -> Bool {
        // Check if enough time has passed since last sync
        guard let lastSync = lastSyncDate else {
            return true
        }

        let timeSinceLastSync = Date().timeIntervalSince(lastSync)
        return timeSinceLastSync >= syncThrottleInterval
    }

    // MARK: - Helper Methods

    private func convertRecordToMeasurement(_ record: CKRecord) -> WatchStressMeasurement? {
        guard let timestamp = record["timestamp"] as? Date,
              let stressLevel = record["stressLevel"] as? Double,
              let hrv = record["hrv"] as? Double,
              let restingHeartRate = record["restingHeartRate"] as? Double else {
            return nil
        }

        let confidences = record["confidences"] as? [Double]

        let measurement = WatchStressMeasurement(
            timestamp: timestamp,
            stressLevel: stressLevel,
            hrv: hrv,
            restingHeartRate: restingHeartRate,
            confidences: confidences
        )

        return measurement
    }

    // MARK: - Error Handling

    private func adaptCloudKitError(_ error: CKError) -> CloudKitError {
        switch error.code {
        case .networkFailure, .networkUnavailable:
            return CloudKitError.networkUnavailable(.noInternet)
        case .notAuthenticated:
            return CloudKitError.networkUnavailable(.iCloudNotSignedIn)
        case .quotaExceeded:
            return CloudKitError.networkUnavailable(.quotaExceeded)
        case .requestRateLimited:
            return CloudKitError.rateLimited
        case .zoneNotFound:
            return CloudKitError.zoneNotFound
        case .unknownItem:
            return CloudKitError.recordNotFound
        default:
            return CloudKitError.unknown(error)
        }
    }
}

// MARK: - Batch Chunking Extension

private extension Array {
    func chunked(into size: Int) -> [[Element]] {
        guard size > 0 else { return [self] }
        return stride(from: 0, to: count, by: size).map {
            Array(self[$0..<Swift.min($0 + size, count)])
        }
    }
}

// MARK: - Watch CloudKit Error

public enum WatchCloudKitError: Error, Sendable {
    case syncThrottled
    case batteryLow
    case notPaired
    case companionAppNotInstalled

    public var localizedDescription: String {
        switch self {
        case .syncThrottled:
            return "Sync is throttled to conserve battery"
        case .batteryLow:
            return "Battery too low for sync"
        case .notPaired:
            return "Watch is not paired with iPhone"
        case .companionAppNotInstalled:
            return "Companion app is not installed"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/CloudKitSchema.swift">
import CloudKit
import Foundation

// MARK: - Record Types
public enum CloudKitRecordType: String, Sendable {
    case stressMeasurement = "CD_StressMeasurement"
    case personalBaseline = "CD_PersonalBaseline"
    case syncMetadata = "CD_SyncMetadata"
}

// MARK: - StressMeasurement Record
public struct CloudKitStressMeasurement: Sendable {
    let recordID: CKRecord.ID
    let timestamp: Date
    let stressLevel: Double
    let hrv: Double
    let restingHeartRate: Double
    let category: String
    let confidences: [Double]
    let deviceID: String
    let isDeleted: Bool
    let cloudKitModTime: Date?

    init?(record: CKRecord) {
        guard record.recordType == CloudKitRecordType.stressMeasurement.rawValue else {
            return nil
        }

        self.recordID = record.recordID
        self.timestamp = record["timestamp"] as? Date ?? Date()
        self.stressLevel = record["stressLevel"] as? Double ?? 0
        self.hrv = record["hrv"] as? Double ?? 0
        self.restingHeartRate = record["restingHeartRate"] as? Double ?? 0
        self.category = record["category"] as? String ?? ""
        self.confidences = record["confidences"] as? [Double] ?? []
        self.deviceID = record["deviceID"] as? String ?? ""
        self.isDeleted = record["isDeleted"] as? Bool ?? false
        self.cloudKitModTime = record["cloudKitModTime"] as? Date
    }

    func toCKRecord() -> CKRecord {
        let record = CKRecord(recordType: CloudKitRecordType.stressMeasurement.rawValue, recordID: recordID)
        record["timestamp"] = timestamp
        record["stressLevel"] = stressLevel
        record["hrv"] = hrv
        record["restingHeartRate"] = restingHeartRate
        record["category"] = category
        record["confidences"] = confidences
        record["deviceID"] = deviceID
        record["isDeleted"] = isDeleted
        return record
    }
}

// MARK: - CloudKitError
public enum CloudKitError: Error, Sendable {
    case networkUnavailable(NetworkReason)
    case rateLimited
    case zoneNotFound
    case recordNotFound
    case unknown(Error)

    public var localizedDescription: String {
        switch self {
        case .networkUnavailable(let reason):
            switch reason {
            case .noInternet:
                return "No internet connection available"
            case .iCloudNotSignedIn:
                return "iCloud is not signed in"
            case .cloudKitDisabled:
                return "CloudKit is disabled"
            case .quotaExceeded:
                return "iCloud storage quota exceeded"
            }
        case .rateLimited:
            return "Too many requests. Please try again later."
        case .zoneNotFound:
            return "CloudKit zone not found"
        case .recordNotFound:
            return "Record not found"
        case .unknown(let error):
            return error.localizedDescription
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/CloudKitServiceProtocol.swift">
import CloudKit
import Foundation

protocol CloudKitServiceProtocol: Sendable {
    var syncStatus: SyncStatus { get }
    var lastSyncDate: Date? { get }

    func saveMeasurement(_ measurement: WatchStressMeasurement) async throws
    func fetchMeasurements(since date: Date?) async throws -> [WatchStressMeasurement]
    func deleteMeasurement(_ measurement: WatchStressMeasurement) async throws
    func sync() async throws

    func setupPushSubscription() async throws
    func checkAccountStatus() async throws -> CloudKitAccountStatus
}

// MARK: - Sync Status
public enum SyncStatus: Sendable {
    case idle
    case syncing(progress: Double)
    case success
    case error(Error)
    case unavailable(NetworkReason)
}

public enum NetworkReason: Sendable {
    case noInternet
    case iCloudNotSignedIn
    case cloudKitDisabled
    case quotaExceeded
}

public enum CloudKitAccountStatus: Sendable {
    case available
    case noAccount
    case restricted
    case unknown
}

// MARK: - Conflict Resolution
enum ResolutionStrategy: Sendable {
    case timestamp
    case server
    case client
    case devicePriority
}

enum MergeDecision: Sendable {
    case keepLocal
    case keepRemote
    case merge
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/HealthKitServiceProtocol.swift">
import Foundation

@preconcurrency import HealthKit

protocol HealthKitServiceProtocol: Sendable {
    func requestAuthorization() async throws
    func fetchLatestHRV() async throws -> HRVMeasurement?
    func fetchHeartRate(samples: Int) async throws -> [HeartRateSample]
    func fetchHRVHistory(since: Date) async throws -> [HRVMeasurement]
    func observeHeartRateUpdates() -> AsyncStream<HeartRateSample?>
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/StressAlgorithmServiceProtocol.swift">
import Foundation

protocol StressAlgorithmServiceProtocol: Sendable {
    func calculateStress(hrv: Double, heartRate: Double) async throws -> StressResult
    func calculateConfidence(hrv: Double, heartRate: Double, samples: Int) -> Double
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/StressCalculator.swift">
import Foundation

// MARK: - Main Stress Calculator
/// Implements the stress algorithm combining HRV (70%) and heart rate (30%)
final class StressCalculator: StressAlgorithmServiceProtocol {

    // MARK: - Properties
    private let baseline: PersonalBaseline

    // MARK: - Initialization
    init(baseline: PersonalBaseline = PersonalBaseline()) {
        self.baseline = baseline
    }

    // MARK: - StressAlgorithmServiceProtocol
    func calculateStress(hrv: Double, heartRate: Double) async throws -> StressResult {
        // Calculate normalized values
        let normalizedHRV = normalizeHRV(hrv, baseline: baseline.baselineHRV)
        let normalizedHR = normalizeHeartRate(heartRate, resting: baseline.restingHeartRate)

        // Calculate components
        let hrvComponent = calculateHRVComponent(normalizedHRV)
        let hrComponent = calculateHRComponent(normalizedHR)

        // Combine components (70% HRV, 30% HR) on 0-1 scale
        let stressLevel = (hrvComponent * 0.7) + (hrComponent * 0.3)

        // Convert to 0-100 scale and clamp
        let clampedLevel = max(0, min(100, stressLevel * 100))

        // Determine category
        let category = StressResult.category(for: clampedLevel)

        // Calculate confidence (default samples for now)
        let confidence = calculateConfidence(hrv: hrv, heartRate: heartRate, samples: 1)

        return StressResult(
            level: clampedLevel,
            category: category,
            confidence: confidence,
            hrv: hrv,
            heartRate: heartRate,
            timestamp: Date()
        )
    }

    func calculateConfidence(hrv: Double, heartRate: Double, samples: Int) -> Double {
        var confidence = 1.0

        // Reduce confidence for low HRV readings
        if hrv < 20 {
            confidence *= 0.5
        }

        // Reduce confidence for extreme heart rates
        if heartRate < 40 || heartRate > 180 {
            confidence *= 0.6
        }

        // Adjust based on sample count (more samples = higher confidence)
        let sampleMultiplier = min(1.0, Double(samples) / 10.0)
        confidence *= (0.7 + (sampleMultiplier * 0.3))

        return max(0.0, min(1.0, confidence))
    }

    // MARK: - Private Helper Methods
    /// Normalizes HRV value relative to baseline
    /// Returns: (Baseline - HRV) / Baseline
    private func normalizeHRV(_ hrv: Double, baseline: Double) -> Double {
        guard baseline > 0 else { return 0 }
        return (baseline - hrv) / baseline
    }

    /// Normalizes heart rate value relative to resting heart rate
    /// Returns: (HR - Resting HR) / Resting HR
    private func normalizeHeartRate(_ heartRate: Double, resting: Double) -> Double {
        guard resting > 0 else { return 0 }
        return (heartRate - resting) / resting
    }

    /// Calculates HRV component using power function
    /// Returns: Normalized HRV ^ 0.8 (0-1 scale)
    private func calculateHRVComponent(_ normalizedHRV: Double) -> Double {
        // Ensure non-negative for power operation
        let value = max(0, normalizedHRV)
        return pow(value, 0.8)
    }

    /// Calculates heart rate component using atan function
    /// Returns: atan(Normalized HR * 2) / (π/2) (0-1 scale)
    private func calculateHRComponent(_ normalizedHR: Double) -> Double {
        let scaled = normalizedHR * 2
        let atanValue = atan(scaled)
        let result = atanValue / (.pi / 2)

        // Return 0-1 scale
        return max(0, result)
    }
}

// MARK: - Thread Safety
extension StressCalculator: @unchecked Sendable {}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Theme/Color+Extensions.swift">
import SwiftUI

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3:
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6:
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8:
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }

    init(light: Color, dark: Color) {
        // On watchOS, dynamic color provider is not available
        // Use the light variant as base - watchOS will handle appearance with system colors
        // For stress colors, the hex values are already appropriate for both modes
        self = light
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Theme/WatchDesignTokens.swift">
import Foundation
import SwiftUI

enum WatchDesignTokens {
  static let compactRingSize: CGFloat = 120
  static let compactRingWidth: CGFloat = 8
  static let compactValueSize: CGFloat = 32
  static let compactLabelSize: CGFloat = 10
  static let compactSpacing: CGFloat = 2

  static let buttonHeight: CGFloat = 44
  static let buttonCornerRadius: CGFloat = 8
  static let standardSpacing: CGFloat = 12
  static let smallSpacing: CGFloat = 8

  static let primaryButtonSize: CGFloat = 16
  static let secondaryButtonSize: CGFloat = 14
  static let captionSize: CGFloat = 11
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Views/Components/CompactStressView.swift">
import SwiftUI

struct CompactStressView: View {
  let stressLevel: Double
  let category: StressCategory

  var body: some View {
    ZStack {
      Circle()
        .stroke(colorForLevel(stressLevel), lineWidth: WatchDesignTokens.compactRingWidth)

      Circle()
        .trim(from: 0, to: stressLevel / 100)
        .stroke(
          colorForLevel(stressLevel),
          style: StrokeStyle(
            lineWidth: WatchDesignTokens.compactRingWidth,
            lineCap: .round
          )
        )
        .rotationEffect(.degrees(-90))
        .animation(.easeInOut(duration: 0.3), value: stressLevel)

      VStack(spacing: WatchDesignTokens.compactSpacing) {
        Text("\(Int(stressLevel))")
          .font(.system(size: WatchDesignTokens.compactValueSize))
          .fontWeight(.bold)
          .foregroundStyle(colorForLevel(stressLevel))

        Text(category.rawValue.capitalized)
          .font(.system(size: WatchDesignTokens.compactLabelSize))
          .foregroundStyle(.secondary)
      }
    }
    .frame(
      width: WatchDesignTokens.compactRingSize,
      height: WatchDesignTokens.compactRingSize
    )
  }

  private func colorForLevel(_ level: Double) -> Color {
    StressResult.category(for: level).color
  }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch AppTests/StressMonitorWatch_Watch_AppTests.swift">
//
//  StressMonitorWatch_Watch_AppTests.swift
//  StressMonitorWatch Watch AppTests
//
//  Created by Phuong Doan Duy on 18/1/26.
//

import Testing
@testable import StressMonitorWatch_Watch_App

struct StressMonitorWatch_Watch_AppTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}
</file>

<file path="StressMonitor/StressMonitorWatch Watch AppUITests/StressMonitorWatch_Watch_AppUITests.swift">
//
//  StressMonitorWatch_Watch_AppUITests.swift
//  StressMonitorWatch Watch AppUITests
//
//  Created by Phuong Doan Duy on 18/1/26.
//

import XCTest

final class StressMonitorWatch_Watch_AppUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch AppUITests/StressMonitorWatch_Watch_AppUITestsLaunchTests.swift">
//
//  StressMonitorWatch_Watch_AppUITestsLaunchTests.swift
//  StressMonitorWatch Watch AppUITests
//
//  Created by Phuong Doan Duy on 18/1/26.
//

import XCTest

final class StressMonitorWatch_Watch_AppUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
</file>

<file path="StressMonitor/StressMonitorWidget/Intents/UpdateWidgetIntent.swift">
import AppIntents
import WidgetKit

/// AppIntent for immediately updating the widget after a new measurement
/// This allows users to refresh widget content on-demand
@available(iOS 17.0, *)
public struct UpdateWidgetIntent: AppIntent {

    public static var title: LocalizedStringResource = "Update Widget"
    public static var description = IntentDescription("Refreshes the stress widget with the latest data.")

    // MARK: - Perform

    public func perform() async throws -> some IntentResult & ReturnsValue<Bool> {
        // Trigger widget reload
        WidgetCenter.shared.reloadAllTimelines()

        // Return success
        return .result(value: true)
    }
}

// MARK: - Update Widget Shortcuts

@available(iOS 17.0, *)
public struct UpdateStressWidgetShortcut: AppShortcut {

    public static var appItem: AppItem {
        AppItem(
            appName: "StressMonitor",
            appIdentifier: "com.stressmonitor.app"
        )
    }

    public static var phrases: [AppShortcutPhrase] {
        [
            .init(type: UpdateWidgetIntent.self(), phrases: [
                "Update stress widget",
                "Refresh stress widget",
                "Reload stress widget"
            ])
        ]
    }

    public static var shortTitle: LocalizedStringResource = "Update Widget"
    public static var systemImageName: String = "arrow.clockwise"
}

// MARK: - Helper for Main App

/// Helper class to update widget from main app
@available(iOS 17.0, *)
public final class WidgetUpdater {

    public static let shared = WidgetUpdater()

    private init() {}

    /// Call this after saving a new stress measurement
    public func widgetDidUpdate() {
        WidgetCenter.shared.reloadAllTimelines()
    }

    /// Reload only specific widget kind
    public func reloadWidget(kind: String) {
        WidgetCenter.shared.reloadTimelines(ofKind: kind)
    }

    /// Get all configured widgets
    public func getConfiguredWidgets() async -> [WidgetInfo] {
        return await WidgetCenter.shared.currentConfigurations
    }
}
</file>

<file path="StressMonitor/StressMonitorWidget/Models/WidgetDataProvider.swift">
import Foundation

/// Manages data access for widgets using App Groups UserDefaults
/// This allows sharing data between the main app and widget extension
@available(iOS 17.0, *)
public final class WidgetDataProvider {

    // MARK: - Constants

    static let appGroupID = "group.com.stressmonitor.app"

    // MARK: - UserDefaults Keys

    private enum Keys {
        static let latestStressLevel = "latest_stress_level"
        static let latestStressCategory = "latest_stress_category"
        static let latestHRV = "latest_hrv"
        static let latestHeartRate = "latest_heart_rate"
        static let latestTimestamp = "latest_timestamp"
        static let latestConfidence = "latest_confidence"
        static let historyData = "stress_history_data"
        static let personalBaseline = "personal_baseline"
    }

    // MARK: - Shared Instance

    public static let shared = WidgetDataProvider()

    private let userDefaults: UserDefaults

    private init() {
        guard let defaults = UserDefaults(suiteName: Self.appGroupID) else {
            fatalError("Unable to create UserDefaults with app group: \(Self.appGroupID)")
        }
        self.userDefaults = defaults
    }

    // MARK: - Latest Stress Data

    /// Saves the latest stress measurement for widget access
    public func saveLatestStress(level: Double, category: String, hrv: Double, heartRate: Double, confidence: Double, timestamp: Date) {
        userDefaults.set(level, forKey: Keys.latestStressLevel)
        userDefaults.set(category, forKey: Keys.latestStressCategory)
        userDefaults.set(hrv, forKey: Keys.latestHRV)
        userDefaults.set(heartRate, forKey: Keys.latestHeartRate)
        userDefaults.set(confidence, forKey: Keys.latestConfidence)
        userDefaults.set(timestamp.timeIntervalSince1970, forKey: Keys.latestTimestamp)
        userDefaults.synchronize()
    }

    /// Retrieves the latest stress measurement
    public func getLatestStress() -> StressData? {
        guard let timestampInterval = userDefaults.object(forKey: Keys.latestTimestamp) as? TimeInterval else {
            return nil
        }

        let timestamp = Date(timeIntervalSince1970: timestampInterval)
        let level = userDefaults.double(forKey: Keys.latestStressLevel)
        let category = userDefaults.string(forKey: Keys.latestStressCategory) ?? "mild"
        let hrv = userDefaults.double(forKey: Keys.latestHRV)
        let heartRate = userDefaults.double(forKey: Keys.latestHeartRate)
        let confidence = userDefaults.double(forKey: Keys.latestConfidence)

        // Validate we have actual data (level defaults to 0 if not set)
        if level == 0 && hrv == 0 && heartRate == 0 {
            return nil
        }

        return StressData(
            level: level,
            category: category,
            hrv: hrv,
            heartRate: heartRate,
            confidence: confidence,
            timestamp: timestamp
        )
    }

    // MARK: - History Data

    /// Saves stress history for the widget timeline
    public func saveHistory(_ history: [StressData]) {
        do {
            let encoder = JSONEncoder()
            encoder.dateEncodingStrategy = .iso8601
            let data = try encoder.encode(history)
            userDefaults.set(data, forKey: Keys.historyData)
            userDefaults.synchronize()
        } catch {
            print("Failed to encode history: \(error)")
        }
    }

    /// Retrieves stress history for widget display
    public func getHistory(limit: Int = 20) -> [StressData] {
        guard let data = userDefaults.data(forKey: Keys.historyData) else {
            return []
        }

        do {
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            let history = try decoder.decode([StressData].self, from: data)
            return Array(history.prefix(limit))
        } catch {
            print("Failed to decode history: \(error)")
            return []
        }
    }

    // MARK: - Personal Baseline

    /// Saves the user's personal baseline values
    public func saveBaseline(hrv: Double, restingHeartRate: Double) {
        userDefaults.set(hrv, forKey: "baseline_hrv")
        userDefaults.set(restingHeartRate, forKey: "baseline_hr")
        userDefaults.synchronize()
    }

    /// Retrieves the user's personal baseline
    public func getBaseline() -> (hrv: Double, restingHeartRate: Double)? {
        let hrv = userDefaults.double(forKey: "baseline_hrv")
        let hr = userDefaults.double(forKey: "baseline_hr")

        if hrv > 0 && hr > 0 {
            return (hrv: hrv, restingHeartRate: hr)
        }
        return nil
    }

    // MARK: - Clear Data

    /// Clears all widget data
    public func clearAllData() {
        Keys.allCases.forEach { key in
            userDefaults.removeObject(forKey: key.rawValue)
        }
        userDefaults.removeObject(forKey: "baseline_hrv")
        userDefaults.removeObject(forKey: "baseline_hr")
        userDefaults.synchronize()
    }
}

// MARK: - Stress Data Model

/// Simple stress data model for widget transmission
public struct StressData: Codable, Sendable {
    public let level: Double
    public let category: String
    public let hrv: Double
    public let heartRate: Double
    public let confidence: Double
    public let timestamp: Date

    public init(level: Double, category: String, hrv: Double, heartRate: Double, confidence: Double, timestamp: Date) {
        self.level = level
        self.category = category
        self.hrv = hrv
        self.heartRate = heartRate
        self.confidence = confidence
        self.timestamp = timestamp
    }

    /// Converts category string to StressCategory enum
    public var stressCategory: StressCategory {
        switch category.lowercased() {
        case "relaxed": return .relaxed
        case "mild": return .mild
        case "moderate": return .moderate
        case "high": return .high
        default: return .mild
        }
    }
}

// MARK: - StressCategory Enum for Widget

public enum StressCategory: String, Codable, Sendable {
    case relaxed
    case mild
    case moderate
    case high

    public var color: String {
        switch self {
        case .relaxed: return "#34C759"
        case .mild: return "#007AFF"
        case .moderate: return "#FFD60A"
        case .high: return "#FF9500"
        }
    }

    public var icon: String {
        switch self {
        case .relaxed: return "leaf.fill"
        case .mild: return "circle.fill"
        case .moderate: return "triangle.fill"
        case .high: return "exclamationmark.triangle.fill"
        }
    }

    public var displayName: String {
        switch self {
        case .relaxed: return "Relaxed"
        case .mild: return "Mild"
        case .moderate: return "Moderate"
        case .high: return "High"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorWidget/Providers/StressWidgetProvider.swift">
import WidgetKit
import Foundation

/// Timeline provider for stress monitoring widgets
/// Handles refresh logic and provides timeline entries for different widget sizes
@available(iOS 17.0, *)
public struct StressWidgetProvider: TimelineProvider {

    public typealias Entry = StressEntry

    // MARK: - Placeholder Entry

    public func placeholder(in context: Context) -> StressEntry {
        StressEntry(
            date: Date(),
            latestStress: createPlaceholderStress(),
            history: createPlaceholderHistory(),
            baseline: (50.0, 60.0),
            isPlaceholder: true
        )
    }

    // MARK: - Snapshot Entry

    /// Provides a preview entry for widget gallery
    public func getSnapshot(in context: Context, completion: @escaping (StressEntry) -> Void) {
        let entry = StressEntry(
            date: Date(),
            latestStress: createSampleStress(),
            history: createSampleHistory(),
            baseline: (50.0, 60.0),
            isPlaceholder: false
        )
        completion(entry)
    }

    // MARK: - Timeline Entry

    /// Provides the actual timeline entries for widget updates
    public func getTimeline(in context: Context, completion: @escaping (Timeline<StressEntry>) -> Void) {
        let dataProvider = WidgetDataProvider.shared
        let currentDate = Date()

        // Get current stress data
        let latestStress = dataProvider.getLatestStress()
        let history = dataProvider.getHistory(limit: 20)
        let baseline = dataProvider.getBaseline()

        // Create the entry
        let entry = StressEntry(
            date: currentDate,
            latestStress: latestStress,
            history: history,
            baseline: baseline,
            isPlaceholder: latestStress == nil
        )

        // Calculate next update time (every 15 minutes)
        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 15, to: currentDate) ?? currentDate

        // Create timeline with policy to update at next scheduled time
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))

        completion(timeline)
    }

    // MARK: - Placeholder Data

    private func createPlaceholderStress() -> StressData {
        StressData(
            level: 45,
            category: "mild",
            hrv: 50,
            heartRate: 70,
            confidence: 0.8,
            timestamp: Date()
        )
    }

    private func createPlaceholderHistory() -> [StressData] {
        (0..<8).map { i in
            StressData(
                level: Double.random(in: 20...70),
                category: "mild",
                hrv: Double.random(in: 30...70),
                heartRate: Double.random(in: 55...85),
                confidence: 0.8,
                timestamp: Date().addingTimeInterval(-Double(i * 3600))
            )
        }
    }

    // MARK: - Sample Data

    private func createSampleStress() -> StressData {
        StressData(
            level: 35,
            category: "mild",
            hrv: 55,
            heartRate: 68,
            confidence: 0.85,
            timestamp: Date()
        )
    }

    private func createSampleHistory() -> [StressData] {
        [
            StressData(level: 25, category: "relaxed", hrv: 65, heartRate: 62, confidence: 0.9, timestamp: Date().addingTimeInterval(-8 * 3600)),
            StressData(level: 40, category: "mild", hrv: 52, heartRate: 70, confidence: 0.85, timestamp: Date().addingTimeInterval(-6 * 3600)),
            StressData(level: 55, category: "moderate", hrv: 42, heartRate: 78, confidence: 0.8, timestamp: Date().addingTimeInterval(-4 * 3600)),
            StressData(level: 35, category: "mild", hrv: 58, heartRate: 65, confidence: 0.85, timestamp: Date().addingTimeInterval(-2 * 3600)),
            StressData(level: 30, category: "relaxed", hrv: 62, heartRate: 64, confidence: 0.88, timestamp: Date()),
        ]
    }
}

// MARK: - Timeline Entry

/// Represents a single timeline entry for the widget
public struct StressEntry: TimelineEntry {
    public let date: Date
    public let latestStress: StressData?
    public let history: [StressData]
    public let baseline: (hrv: Double, restingHeartRate: Double)?
    public let isPlaceholder: Bool

    /// Returns true if we have valid stress data to display
    public var hasValidData: Bool {
        latestStress != nil && !history.isEmpty
    }

    /// Average stress level from history
    public var averageStress: Double {
        guard !history.isEmpty else { return 0 }
        return history.reduce(0) { $0 + $1.level } / Double(history.count)
    }

    /// Trend direction compared to previous readings
    public var trend: TrendDirection {
        guard history.count >= 2 else { return .stable }

        let recent = history.prefix(3).reduce(0) { $0 + $1.level } / Double(min(3, history.count))
        let older = history.dropFirst(3).prefix(3).reduce(0) { $0 + $1.level } / Double(max(1, min(3, history.count - 3)))

        let diff = recent - older
        if diff > 10 { return .increasing }
        if diff < -10 { return .decreasing }
        return .stable
    }
}

// MARK: - Trend Direction

public enum TrendDirection: String, Codable {
    case increasing
    case stable
    case decreasing

    public var icon: String {
        switch self {
        case .increasing: return "arrow.up"
        case .stable: return "minus"
        case .decreasing: return "arrow.down"
        }
    }

    public var color: String {
        switch self {
        case .increasing: return "#FF9500"
        case .stable: return "#8E8E93"
        case .decreasing: return "#34C759"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorWidget/Views/LargeWidgetView.swift">
import SwiftUI
import Charts

/// Large widget view (32x32 modules)
/// Displays full stress history, trends, and personalized recommendations
@available(iOS 17.0, *)
public struct LargeWidgetView: View {

    let entry: StressEntry

    public init(entry: StressEntry) {
        self.entry = entry
    }

    public var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            if entry.isPlaceholder {
                placeholderView
            } else if let stress = entry.latestStress {
                stressContent(stress: stress)
            } else {
                emptyStateView
            }
        }
        .containerBackground(.fill.tertiary, for: .widget)
    }

    // MARK: - Stress Content

    @ViewBuilder
    private func stressContent(stress: StressData) -> some View {
        VStack(spacing: 0) {
            // Header with current stress
            headerSection(stress: stress)

            Divider()

            // History chart
            if entry.history.count >= 2 {
                historyChartSection
            }

            Divider()

            // Quick stats
            quickStatsSection(stress: stress)

            Divider()

            // Recommendations
            recommendationsSection
        }
    }

    // MARK: - Header Section

    private func headerSection(stress: StressData) -> some View {
        HStack(spacing: 12) {
            // Stress ring
            ZStack {
                Circle()
                    .stroke(Color.secondary.opacity(0.15), lineWidth: 8)

                Circle()
                    .trim(from: 0, to: stress.level / 100)
                    .stroke(
                        colorForLevel(stress.level),
                        style: StrokeStyle(lineWidth: 8, lineCap: .round)
                    )
                    .rotationEffect(.degrees(-90))

                VStack(spacing: 0) {
                    Text("\(Int(stress.level))")
                        .font(.system(size: 24, weight: .bold, design: .rounded))
                        .foregroundColor(.primary)

                    Text(stress.stressCategory.displayName.uppercased())
                        .font(.system(size: 8, weight: .semibold))
                        .foregroundColor(.secondary)
                        .tracking(0.3)
                }
            }
            .frame(width: 64, height: 64)

            VStack(alignment: .leading, spacing: 4) {
                // Category with icon
                HStack(spacing: 4) {
                    Image(systemName: stress.stressCategory.icon)
                        .font(.system(size: 12))
                        .foregroundColor(colorForLevel(stress.level))

                    Text("Stress Level")
                        .font(.system(size: 10, weight: .medium))
                        .foregroundColor(.secondary)
                }

                // HRV and Heart Rate
                HStack(spacing: 12) {
                    HStack(spacing: 3) {
                        Image(systemName: "heart.fill")
                            .font(.system(size: 8))
                            .foregroundColor(.red)
                        Text("\(Int(stress.hrv))ms")
                            .font(.system(size: 11, weight: .medium))
                            .foregroundColor(.primary)
                    }

                    HStack(spacing: 3) {
                        Image(systemName: "waveform.path")
                            .font(.system(size: 8))
                            .foregroundColor(.blue)
                        Text("\(Int(stress.heartRate))bpm")
                            .font(.system(size: 11, weight: .medium))
                            .foregroundColor(.primary)
                    }
                }

                // Trend
                HStack(spacing: 3) {
                    Image(systemName: entry.trend.icon)
                        .font(.system(size: 8))
                    Text("Trend: \(trendText)")
                        .font(.system(size: 10))
                }
                .foregroundColor(Color(hex: entry.trend.color))
            }

            Spacer()

            // Link to app
            Link(destination: URL(string: "stressmonitor://dashboard")!) {
                Image(systemName: "arrow.up.right.circle.fill")
                    .font(.system(size: 20))
                    .foregroundColor(.accentColor)
            }
        }
        .padding(12)
    }

    // MARK: - History Chart Section

    private var historyChartSection: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text("Stress History")
                .font(.system(size: 11, weight: .semibold))
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity, alignment: .leading)

            StressHistoryChart(data: entry.history.prefix(12).reversed())
                .frame(height: 70)
        }
        .padding(12)
    }

    // MARK: - Quick Stats Section

    private func quickStatsSection(stress: StressData) -> some View {
        HStack(spacing: 0) {
            // Average
            statItem(
                icon: "chart.bar.fill",
                title: "Average",
                value: "\(Int(entry.averageStress))",
                color: .blue
            )

            Divider()
                .frame(width: 1)

            // Best
            if let best = entry.history.min(by: { $0.level < $1.level }) {
                statItem(
                    icon: "arrow.down.right",
                    title: "Best",
                    value: "\(Int(best.level))",
                    color: .green
                )
            }

            Divider()
                .frame(width: 1)

            // Readings count
            statItem(
                icon: "calendar",
                title: "Readings",
                value: "\(entry.history.count)",
                color: .purple
            )
        }
        .frame(height: 50)
    }

    private func statItem(icon: String, title: String, value: String, color: Color) -> some View {
        VStack(spacing: 2) {
            Image(systemName: icon)
                .font(.system(size: 10))
                .foregroundColor(color)

            Text(value)
                .font(.system(size: 14, weight: .bold, design: .rounded))
                .foregroundColor(.primary)

            Text(title)
                .font(.system(size: 8))
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
    }

    // MARK: - Recommendations Section

    private var recommendationsSection -> some View {
        VStack(alignment: .leading, spacing: 6) {
            HStack {
                Image(systemName: "lightbulb.fill")
                    .font(.system(size: 10))
                    .foregroundColor(.yellow)

                Text("Insight")
                    .font(.system(size: 11, weight: .semibold))
                    .foregroundColor(.secondary)

                Spacer()
            }

            Text(recommendationText)
                .font(.system(size: 10))
                .foregroundColor(.primary)
                .lineLimit(3)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .padding(12)
    }

    // MARK: - Placeholder View

    private var placeholderView: some View {
        VStack(spacing: 12) {
            ZStack {
                Circle()
                    .stroke(Color.secondary.opacity(0.15), lineWidth: 8)
                    .frame(width: 64, height: 64)

                Image(systemName: "waveform.path")
                    .font(.system(size: 24))
                    .foregroundColor(.secondary)
            }

            Text("Loading...")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(.secondary)

            Text("Please wait while we load your stress data")
                .font(.system(size: 10))
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding()
    }

    // MARK: - Empty State

    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Image(systemName: "heart.text.square.fill")
                .font(.system(size: 40))
                .foregroundColor(.accentColor)

            Text("No Data Available")
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(.primary)

            Text("Open the Stress Monitor app to take your first measurement and start tracking your stress levels.")
                .font(.system(size: 11))
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .lineLimit(3)

            Link(destination: URL(string: "stressmonitor://dashboard")!) {
                Text("Open App")
                    .font(.system(size: 11, weight: .semibold))
                    .foregroundColor(.white)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 6)
                    .background(Color.accentColor)
                    .cornerRadius(8)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding()
    }

    // MARK: - Helpers

    private func colorForLevel(_ level: Double) -> Color {
        switch level {
        case 0...25: return Color(hex: "#34C759")
        case 26...50: return Color(hex: "#007AFF")
        case 51...75: return Color(hex: "#FFD60A")
        case 76...100: return Color(hex: "#FF9500")
        default: return .secondary
        }
    }

    private var trendText: String {
        switch entry.trend {
        case .increasing: return "Rising"
        case .stable: return "Stable"
        case .decreasing: return "Falling"
        }
    }

    private var recommendationText: String {
        guard let stress = entry.latestStress else {
            return "Start tracking your stress to receive personalized insights."
        }

        switch stress.stressCategory {
        case .relaxed:
            return "You're doing great! Your stress levels are in a healthy range. Keep up with your current routine."
        case .mild:
            return "Mild stress detected. Consider taking short breaks throughout the day and practicing deep breathing."
        case .moderate:
            return "Moderate stress levels. Try a 5-minute breathing exercise or a short walk to help reduce stress."
        case .high:
            return "High stress detected. Consider stepping away, practicing mindfulness, or engaging in physical activity."
        }
    }
}

// MARK: - Stress History Chart

@available(iOS 17.0, *)
struct StressHistoryChart: View {
    let data: [StressData]

    var body: some View {
        Chart {
            ForEach(Array(data.enumerated()), id: \.offset) { _, item in
                AreaMark(
                    x: .value("Time", item.timestamp),
                    y: .value("Stress", item.level)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(
                    LinearGradient(
                        colors: [
                            Color(hex: "#007AFF").opacity(0.3),
                            Color(hex: "#007AFF").opacity(0.05)
                        ],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )

                LineMark(
                    x: .value("Time", item.timestamp),
                    y: .value("Stress", item.level)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(Color(hex: "#007AFF"))
            }
        }
        .chartXAxis(.hidden)
        .chartYAxis(.hidden)
        .chartLegend(.hidden)
        .chartPlotStyle { plotArea in
            plotArea.background(Color.clear)
        }
    }
}

// MARK: - Preview

@available(iOS 17.0, *)
#Preview(as: .systemLarge) {
    LargeWidgetView(entry: StressEntry(
        date: Date(),
        latestStress: StressData(
            level: 38,
            category: "mild",
            hrv: 54,
            heartRate: 70,
            confidence: 0.85,
            timestamp: Date()
        ),
        history: [
            StressData(level: 25, category: "relaxed", hrv: 65, heartRate: 62, confidence: 0.9, timestamp: Date().addingTimeInterval(-12 * 3600)),
            StressData(level: 40, category: "mild", hrv: 52, heartRate: 70, confidence: 0.85, timestamp: Date().addingTimeInterval(-10 * 3600)),
            StressData(level: 55, category: "moderate", hrv: 42, heartRate: 78, confidence: 0.8, timestamp: Date().addingTimeInterval(-8 * 3600)),
            StressData(level: 35, category: "mild", hrv: 58, heartRate: 65, confidence: 0.85, timestamp: Date().addingTimeInterval(-6 * 3600)),
            StressData(level: 30, category: "relaxed", hrv: 62, heartRate: 64, confidence: 0.88, timestamp: Date().addingTimeInterval(-4 * 3600)),
            StressData(level: 45, category: "mild", hrv: 50, heartRate: 72, confidence: 0.82, timestamp: Date().addingTimeInterval(-2 * 3600)),
            StressData(level: 38, category: "mild", hrv: 54, heartRate: 70, confidence: 0.85, timestamp: Date()),
        ],
        baseline: (50.0, 60.0),
        isPlaceholder: false
    ))
} timeline: {
    StressEntry(
        date: Date(),
        latestStress: StressData(
            level: 38,
            category: "mild",
            hrv: 54,
            heartRate: 70,
            confidence: 0.85,
            timestamp: Date()
        ),
        history: [
            StressData(level: 25, category: "relaxed", hrv: 65, heartRate: 62, confidence: 0.9, timestamp: Date().addingTimeInterval(-12 * 3600)),
            StressData(level: 40, category: "mild", hrv: 52, heartRate: 70, confidence: 0.85, timestamp: Date().addingTimeInterval(-10 * 3600)),
            StressData(level: 55, category: "moderate", hrv: 42, heartRate: 78, confidence: 0.8, timestamp: Date().addingTimeInterval(-8 * 3600)),
            StressData(level: 35, category: "mild", hrv: 58, heartRate: 65, confidence: 0.85, timestamp: Date().addingTimeInterval(-6 * 3600)),
            StressData(level: 30, category: "relaxed", hrv: 62, heartRate: 64, confidence: 0.88, timestamp: Date().addingTimeInterval(-4 * 3600)),
            StressData(level: 45, category: "mild", hrv: 50, heartRate: 72, confidence: 0.82, timestamp: Date().addingTimeInterval(-2 * 3600)),
            StressData(level: 38, category: "mild", hrv: 54, heartRate: 70, confidence: 0.85, timestamp: Date()),
        ],
        baseline: (50.0, 60.0),
        isPlaceholder: false
    )
}
</file>

<file path="StressMonitor/StressMonitorWidget/Views/MediumWidgetView.swift">
import SwiftUI
import Charts

/// Medium widget view (32x16 modules)
/// Displays stress level, HRV trend chart, and quick stats
@available(iOS 17.0, *)
public struct MediumWidgetView: View {

    let entry: StressEntry

    public init(entry: StressEntry) {
        self.entry = entry
    }

    public var body: some View {
        HStack(spacing: 0) {
            if entry.isPlaceholder {
                placeholderView
            } else if let stress = entry.latestStress {
                stressContent(stress: stress)
            } else {
                emptyStateView
            }
        }
        .containerBackground(.fill.tertiary, for: .widget)
    }

    // MARK: - Stress Content

    @ViewBuilder
    private func stressContent(stress: StressData) -> some View {
        // Left side: Current stress
        VStack(alignment: .leading, spacing: 6) {
            // Category icon
            Image(systemName: stress.stressCategory.icon)
                .font(.system(size: 16))
                .foregroundColor(colorForLevel(stress.level))
                .frame(width: 28, height: 28)
                .background(colorForLevel(stress.level).opacity(0.15))
                .cornerRadius(6)

            // Stress level
            Text("\(Int(stress.level))")
                .font(.system(size: 32, weight: .bold, design: .rounded))
                .foregroundColor(.primary)

            // Category label
            Text(stress.stressCategory.displayName.uppercased())
                .font(.system(size: 10, weight: .semibold))
                .foregroundColor(.secondary)
                .tracking(0.5)

            Spacer()

            // HRV and HR
            VStack(alignment: .leading, spacing: 2) {
                HStack(spacing: 4) {
                    Image(systemName: "heart.fill")
                        .font(.system(size: 8))
                        .foregroundColor(.red)
                    Text("\(Int(stress.hrv))ms")
                        .font(.system(size: 10, weight: .medium))
                        .foregroundColor(.primary)
                }

                HStack(spacing: 4) {
                    Image(systemName: "waveform.path")
                        .font(.system(size: 8))
                        .foregroundColor(.blue)
                    Text("\(Int(stress.heartRate))bpm")
                        .font(.system(size: 10, weight: .medium))
                        .foregroundColor(.primary)
                }
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.leading, 12)
        .padding(.vertical, 12)

        Divider()
            .frame(width: 1)

        // Right side: HRV trend
        VStack(alignment: .trailing, spacing: 6) {
            Text("HRV Trend")
                .font(.system(size: 9, weight: .semibold))
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity, alignment: .trailing)

            if entry.history.count >= 2 {
                HRVTrendChart(data: entry.history.prefix(8).reversed())
                    .frame(height: 50)
            } else {
                Rectangle()
                    .fill(Color.secondary.opacity(0.1))
                    .frame(height: 50)
                    .overlay(
                        Image(systemName: "chart.line.flattrend")
                            .font(.system(size: 16))
                            .foregroundColor(.secondary)
                    )
            }

            // Trend indicator
            HStack(spacing: 2) {
                Image(systemName: entry.trend.icon)
                    .font(.system(size: 8))
                Text(trendText)
                    .font(.system(size: 9, weight: .medium))
            }
            .foregroundColor(Color(hex: entry.trend.color))

            Spacer()
        }
        .frame(maxWidth: .infinity, alignment: .trailing)
        .padding(.trailing, 12)
        .padding(.vertical, 12)
    }

    // MARK: - Placeholder View

    private var placeholderView: some View {
        HStack(spacing: 12) {
            VStack(alignment: .leading, spacing: 6) {
                Rectangle()
                    .fill(Color.secondary.opacity(0.2))
                    .frame(width: 28, height: 28)
                    .cornerRadius(6)

                Text("--")
                    .font(.system(size: 32, weight: .bold, design: .rounded))
                    .foregroundColor(.secondary)

                Text("LOADING")
                    .font(.system(size: 10, weight: .semibold))
                    .foregroundColor(.secondary)
                    .tracking(0.5)

                Spacer()
            }

            Divider()
                .frame(width: 1)

            VStack(alignment: .trailing, spacing: 6) {
                Text("HRV Trend")
                    .font(.system(size: 9, weight: .semibold))
                    .foregroundColor(.secondary)

                Rectangle()
                    .fill(Color.secondary.opacity(0.1))
                    .frame(height: 50)

                Spacer()
            }
        }
        .padding(12)
    }

    // MARK: - Empty State

    private var emptyStateView: some View {
        HStack(spacing: 12) {
            VStack(alignment: .leading, spacing: 8) {
                Image(systemName: "heart.text.square.fill")
                    .font(.system(size: 24))
                    .foregroundColor(.accentColor)

                Text("No Data")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(.primary)

                Text("Open app to take your first measurement")
                    .font(.system(size: 10))
                    .foregroundColor(.secondary)
                    .lineLimit(2)

                Spacer()
            }

            Spacer()
        }
        .padding(12)
    }

    // MARK: - Helpers

    private func colorForLevel(_ level: Double) -> Color {
        switch level {
        case 0...25: return Color(hex: "#34C759")
        case 26...50: return Color(hex: "#007AFF")
        case 51...75: return Color(hex: "#FFD60A")
        case 76...100: return Color(hex: "#FF9500")
        default: return .secondary
        }
    }

    private var trendText: String {
        switch entry.trend {
        case .increasing: return "Rising"
        case .stable: return "Stable"
        case .decreasing: return "Falling"
        }
    }
}

// MARK: - HRV Trend Chart

@available(iOS 17.0, *)
struct HRVTrendChart: View {
    let data: [StressData]

    var body: some View {
        Chart {
            ForEach(Array(data.enumerated()), id: \.offset) { _, item in
                LineMark(
                    x: .value("Time", item.timestamp),
                    y: .value("HRV", item.hrv)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(
                    LinearGradient(
                        colors: [
                            Color(hex: "#34C759"),
                            Color(hex: "#007AFF")
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            }
        }
        .chartXAxis(.hidden)
        .chartYAxis(.hidden)
        .chartLegend(.hidden)
        .chartPlotStyle { plotArea in
            plotArea
                .background(Color.clear)
        }
    }
}

// MARK: - Preview

@available(iOS 17.0, *)
#Preview(as: .systemMedium) {
    MediumWidgetView(entry: StressEntry(
        date: Date(),
        latestStress: StressData(
            level: 42,
            category: "mild",
            hrv: 52,
            heartRate: 72,
            confidence: 0.85,
            timestamp: Date()
        ),
        history: [
            StressData(level: 35, category: "mild", hrv: 55, heartRate: 68, confidence: 0.85, timestamp: Date().addingTimeInterval(-4 * 3600)),
            StressData(level: 45, category: "mild", hrv: 48, heartRate: 75, confidence: 0.8, timestamp: Date().addingTimeInterval(-2 * 3600)),
            StressData(level: 42, category: "mild", hrv: 52, heartRate: 72, confidence: 0.85, timestamp: Date()),
        ],
        baseline: (50.0, 60.0),
        isPlaceholder: false
    ))
} timeline: {
    StressEntry(
        date: Date(),
        latestStress: StressData(
            level: 42,
            category: "mild",
            hrv: 52,
            heartRate: 72,
            confidence: 0.85,
            timestamp: Date()
        ),
        history: [
            StressData(level: 35, category: "mild", hrv: 55, heartRate: 68, confidence: 0.85, timestamp: Date().addingTimeInterval(-4 * 3600)),
            StressData(level: 45, category: "mild", hrv: 48, heartRate: 75, confidence: 0.8, timestamp: Date().addingTimeInterval(-2 * 3600)),
            StressData(level: 42, category: "mild", hrv: 52, heartRate: 72, confidence: 0.85, timestamp: Date()),
        ],
        baseline: (50.0, 60.0),
        isPlaceholder: false
    )
}
</file>

<file path="StressMonitor/StressMonitorWidget/Views/SmallWidgetView.swift">
import SwiftUI

/// Small widget view (16x16 modules)
/// Displays stress ring and current stress level
@available(iOS 17.0, *)
public struct SmallWidgetView: View {

    let entry: StressEntry

    public init(entry: StressEntry) {
        self.entry = entry
    }

    public var body: some View {
        VStack(spacing: 0) {
            if entry.isPlaceholder {
                placeholderView
            } else if let stress = entry.latestStress {
                stressContent(stress: stress)
            } else {
                emptyStateView
            }
        }
        .containerBackground(.fill.tertiary, for: .widget)
    }

    // MARK: - Stress Content

    @ViewBuilder
    private func stressContent(stress: StressData) -> some View {
        VStack(spacing: 4) {
            // Stress ring
            ZStack {
                Circle()
                    .stroke(Color.secondary.opacity(0.2), lineWidth: 6)

                Circle()
                    .trim(from: 0, to: stress.level / 100)
                    .stroke(
                        colorForLevel(stress.level),
                        style: StrokeStyle(lineWidth: 6, lineCap: .round)
                    )
                    .rotationEffect(.degrees(-90))
                    .animation(.easeInOut(duration: 0.5), value: stress.level)

                // Category icon
                Image(systemName: stress.stressCategory.icon)
                    .font(.system(size: 20))
                    .foregroundColor(colorForLevel(stress.level))
            }
            .frame(width: 52, height: 52)

            // Stress level
            Text("\(Int(stress.level))")
                .font(.system(size: 28, weight: .bold, design: .rounded))
                .foregroundColor(.primary)

            // Category label
            Text(stress.stressCategory.displayName.uppercased())
                .font(.system(size: 9, weight: .semibold))
                .foregroundColor(.secondary)
                .tracking(0.5)
        }
        .padding(12)
    }

    // MARK: - Placeholder View

    private var placeholderView: some View {
        VStack(spacing: 4) {
            ZStack {
                Circle()
                    .stroke(Color.secondary.opacity(0.2), lineWidth: 6)

                Image(systemName: "waveform.path")
                    .font(.system(size: 18))
                    .foregroundColor(.secondary)
            }
            .frame(width: 52, height: 52)

            Text("--")
                .font(.system(size: 28, weight: .bold, design: .rounded))
                .foregroundColor(.secondary)

            Text("LOADING")
                .font(.system(size: 9, weight: .semibold))
                .foregroundColor(.secondary)
                .tracking(0.5)
        }
        .padding(12)
    }

    // MARK: - Empty State

    private var emptyStateView: some View {
        VStack(spacing: 8) {
            Image(systemName: "heart.text.square.fill")
                .font(.system(size: 24))
                .foregroundColor(.accentColor)

            Text("No Data")
                .font(.system(size: 12, weight: .medium))
                .foregroundColor(.primary)

            Text("Open app to measure")
                .font(.system(size: 9))
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
        .padding(12)
    }

    // MARK: - Helpers

    private func colorForLevel(_ level: Double) -> Color {
        switch level {
        case 0...25: return Color(hex: "#34C759")
        case 26...50: return Color(hex: "#007AFF")
        case 51...75: return Color(hex: "#FFD60A")
        case 76...100: return Color(hex: "#FF9500")
        default: return .secondary
        }
    }
}

// MARK: - Color Extension for Widget

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3:
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6:
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8:
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

// MARK: - Preview

@available(iOS 17.0, *)
#Preview(as: .systemSmall) {
    SmallWidgetView(entry: StressEntry(
        date: Date(),
        latestStress: StressData(
            level: 35,
            category: "mild",
            hrv: 55,
            heartRate: 68,
            confidence: 0.85,
            timestamp: Date()
        ),
        history: [],
        baseline: (50.0, 60.0),
        isPlaceholder: false
    ))
} timeline: {
    StressEntry(
        date: Date(),
        latestStress: StressData(
            level: 35,
            category: "mild",
            hrv: 55,
            heartRate: 68,
            confidence: 0.85,
            timestamp: Date()
        ),
        history: [],
        baseline: (50.0, 60.0),
        isPlaceholder: false
    )
}
</file>

<file path="StressMonitor/StressMonitorWidget/StressMonitorWidget.swift">
import WidgetKit
import SwiftUI

/// Main widget configuration for Stress Monitor
/// Configures all supported widget sizes with their respective providers and views
@main
public struct StressMonitorWidget: Widget {

    // MARK: - Widget Configuration

    public static let kind: String = "StressMonitorWidget"

    public var body: some WidgetConfiguration {
        StaticConfiguration(kind: Self.kind, provider: StressWidgetProvider()) { entry in
            switch entry.family {
            case .systemSmall:
                SmallWidgetView(entry: entry)
            case .systemMedium:
                MediumWidgetView(entry: entry)
            case .systemLarge:
                LargeWidgetView(entry: entry)
            default:
                SmallWidgetView(entry: entry)
            }
        }
        .configurationDisplayName("Stress Monitor")
        .description("Monitor your stress levels, HRV trends, and receive personalized insights.")
        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
    }

    // MARK: - Initialization

    public init() {}
}

// MARK: - Widget Bundle

/// Widget bundle for all stress monitoring widgets
@available(iOS 17.0, *)
public struct StressMonitorWidgetBundle: WidgetBundle {

    public var body: some Widget {
        StressMonitorWidget()
    }
}

// MARK: - Widget Deep Link Handling

/// Helper for deep linking from widget to main app
@available(iOS 17.0, *)
public enum WidgetDeepLink {

    case dashboard
    case history
    case trends
    case measurement

    var url: URL {
        switch self {
        case .dashboard:
            return URL(string: "stressmonitor://dashboard")!
        case .history:
            return URL(string: "stressmonitor://history")!
        case .trends:
            return URL(string: "stressmonitor://trends")!
        case .measurement:
            return URL(string: "stressmonitor://measurement")!
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Components/Character/StressCharacterCard.swift">
import SwiftUI

// MARK: - Stress Character Card (Figma Design)

/// Character-based stress visualization matching Figma design
/// Displays Stress Buddy mascot with mood-based appearance in a 390x408px card
/// Full Reduce Motion support with static fallbacks
struct StressCharacterCard: View {
    let mood: StressBuddyMood
    let stressLevel: Double
    let hrv: Double?
    let size: StressBuddyMood.CharacterContext
    let lastUpdated: Date?
    let onRefresh: (() -> Void)?

    @Environment(\.accessibilityReduceMotion) var reduceMotion

    init(
        mood: StressBuddyMood,
        stressLevel: Double,
        hrv: Double? = nil,
        size: StressBuddyMood.CharacterContext,
        lastUpdated: Date? = nil,
        onRefresh: (() -> Void)? = nil
    ) {
        self.mood = mood
        self.stressLevel = stressLevel
        self.hrv = hrv
        self.size = size
        self.lastUpdated = lastUpdated
        self.onRefresh = onRefresh
    }

    var body: some View {
        VStack(spacing: 0) {
            // Date header with refresh button
            HStack(alignment: .top) {
                DateHeaderView(date: lastUpdated ?? Date())
                Spacer()
                refreshButton
            }
            .padding(.horizontal, 20)
            .padding(.top, 22)

            Spacer()

            // Status text (centered)
            Text(mood.displayName)
                .font(.system(size: 26, weight: .bold))
                .foregroundStyle(moodColor)
                .padding(.top, 30)

            Spacer()

            // Character illustration
            characterView
                .padding(.vertical, 20)

            Spacer()

            // Last updated timestamp
            if let lastUpdated = lastUpdated {
                Text("Last Updated: \(lastUpdated, style: .relative)")
                    .font(.system(size: 13, weight: .bold))
                    .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
                    .padding(.bottom, 24)
            }
        }
        .frame(width: cardSize.width, height: cardSize.height)
        .background(Color.Wellness.adaptiveCardBackground)
        .clipShape(RoundedRectangle(cornerRadius: 24))
        .shadow(color: .black.opacity(0.04), radius: 7.7, x: 0, y: 3)
        .shadow(color: .black.opacity(0.03), radius: 13.9, x: 0, y: 7)
        .shadow(color: .black.opacity(0.02), radius: 26.4, x: 0, y: 13.9)
        .shadow(color: .black.opacity(0.01), radius: 46.9, x: 0, y: 24.5)
        .accessibilityElement(children: .combine)
        .accessibilityLabel(accessibilityLabel)
    }

    // MARK: - Refresh Button

    @ViewBuilder
    private var refreshButton: some View {
        if let onRefresh = onRefresh {
            Button(action: onRefresh) {
                Image(systemName: "arrow.clockwise")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
                    .frame(width: 32, height: 32)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
            .accessibilityLabel("Refresh stress data")
        }
    }

    // MARK: - Character View

    @ViewBuilder
    private var characterView: some View {
        ZStack {
            // Main character symbol
            Image(systemName: mood.symbol)
                .font(.system(size: mood.symbolSize(for: size)))
                .foregroundStyle(mood.color)
                .symbolRenderingMode(.hierarchical)
                .characterAnimation(for: mood)

            // Accessories
            accessoriesView
        }
        .accessibilityHidden(true)
    }

    @ViewBuilder
    private var accessoriesView: some View {
        if !mood.accessories.isEmpty {
            ForEach(Array(mood.accessories.enumerated()), id: \.offset) { index, accessory in
                Image(systemName: accessory)
                    .font(.system(size: mood.accessorySize(for: size)))
                    .foregroundStyle(mood.color.opacity(0.7))
                    .offset(accessoryOffset(for: index, total: mood.accessories.count))
                    .accessoryAnimation(index: index)
            }
        }
    }

    // MARK: - Layout Helpers

    private var cardSize: CGSize {
        switch size {
        case .dashboard:
            return CGSize(width: 390, height: 408)
        case .widget:
            return CGSize(width: 338, height: 354)
        case .watchOS:
            return CGSize(width: 180, height: 180)
        }
    }

    /// Position accessories around the character
    private func accessoryOffset(for index: Int, total: Int) -> CGSize {
        let radius = mood.symbolSize(for: size) * 0.6
        let angle = (Double(index) / Double(total)) * 2 * Double.pi

        return CGSize(
            width: CGFloat(cos(angle)) * radius,
            height: CGFloat(sin(angle)) * radius
        )
    }

    /// Mood color matching Figma design (#86CECD for relaxed)
    private var moodColor: Color {
        switch mood {
        case .sleeping, .calm:
            return Color.Wellness.exerciseCyan // #86CECD
        case .concerned:
            return Color.Wellness.daylightYellow
        case .worried:
            return Color.stressModerate
        case .overwhelmed:
            return Color.stressHigh
        }
    }

    private var accessibilityLabel: String {
        var timeText = ""
        if let lastUpdated = lastUpdated {
            let formatter = RelativeDateTimeFormatter()
            formatter.unitsStyle = .abbreviated
            timeText = "Last updated \(formatter.localizedString(for: lastUpdated, relativeTo: Date()))"
        }
        return "\(mood.accessibilityDescription). Stress level: \(Int(stressLevel)). \(timeText)"
    }
}

// MARK: - Convenience Initializers

extension StressCharacterCard {
    /// Create character card from StressResult
    init(
        result: StressResult,
        size: StressBuddyMood.CharacterContext,
        onRefresh: (() -> Void)? = nil
    ) {
        self.mood = StressBuddyMood.from(stressLevel: result.level)
        self.stressLevel = result.level
        self.hrv = result.hrv
        self.size = size
        self.lastUpdated = result.timestamp
        self.onRefresh = onRefresh
    }

    /// Create character card with minimal data
    init(
        stressLevel: Double,
        size: StressBuddyMood.CharacterContext,
        lastUpdated: Date? = nil,
        onRefresh: (() -> Void)? = nil
    ) {
        self.mood = StressBuddyMood.from(stressLevel: stressLevel)
        self.stressLevel = stressLevel
        self.hrv = nil
        self.size = size
        self.lastUpdated = lastUpdated
        self.onRefresh = onRefresh
    }
}

// MARK: - Preview

#Preview("All Moods - Dashboard") {
    ScrollView {
        VStack(spacing: 24) {
            ForEach([0.0, 5.0, 15.0, 35.0, 60.0, 85.0], id: \.self) { level in
                StressCharacterCard(
                    mood: .from(stressLevel: level),
                    stressLevel: level,
                    hrv: 65,
                    size: .dashboard,
                    lastUpdated: Date().addingTimeInterval(-30000)
                ) {
                    print("Refresh tapped")
                }
            }
        }
        .padding()
        .background(Color.Wellness.adaptiveBackground)
    }
}

#Preview("Widget Size") {
    VStack(spacing: 16) {
        StressCharacterCard(
            mood: .calm,
            stressLevel: 15,
            hrv: 70,
            size: .widget,
            lastUpdated: Date().addingTimeInterval(-3600)
        )

        StressCharacterCard(
            mood: .worried,
            stressLevel: 60,
            hrv: 45,
            size: .widget,
            lastUpdated: Date().addingTimeInterval(-7200)
        )
    }
    .padding()
    .background(Color.Wellness.adaptiveBackground)
}

#Preview("watchOS Size") {
    VStack(spacing: 12) {
        StressCharacterCard(
            mood: .sleeping,
            stressLevel: 5,
            size: .watchOS,
            lastUpdated: Date()
        )
    }
    .padding()
    .background(Color.Wellness.adaptiveBackground)
}

#Preview("Dark Mode") {
    VStack(spacing: 24) {
        StressCharacterCard(
            mood: .overwhelmed,
            stressLevel: 90,
            hrv: 30,
            size: .dashboard,
            lastUpdated: Date().addingTimeInterval(-1800)
        )
    }
    .padding()
    .background(Color.Wellness.adaptiveBackground)
    .preferredColorScheme(.dark)
}
</file>

<file path="StressMonitor/StressMonitor/Services/Algorithm/StressCalculator.swift">
import Foundation

// MARK: - Main Stress Calculator
/// Implements the stress algorithm combining HRV (70%) and heart rate (30%)
final class StressCalculator: StressAlgorithmServiceProtocol {

    // MARK: - Properties
    private let baseline: PersonalBaseline

    // MARK: - Initialization
    init(baseline: PersonalBaseline = PersonalBaseline()) {
        self.baseline = baseline
    }

    // MARK: - StressAlgorithmServiceProtocol
    func calculateStress(hrv: Double, heartRate: Double) async throws -> StressResult {
        // Calculate normalized values
        let normalizedHRV = normalizeHRV(hrv, baseline: baseline.baselineHRV)
        let normalizedHR = normalizeHeartRate(heartRate, resting: baseline.restingHeartRate)

        // Calculate components
        let hrvComponent = calculateHRVComponent(normalizedHRV)
        let hrComponent = calculateHRComponent(normalizedHR)

        // Combine components (70% HRV, 30% HR) on 0-1 scale
        let stressLevel = (hrvComponent * 0.7) + (hrComponent * 0.3)

        // Convert to 0-100 scale and clamp
        let clampedLevel = max(0, min(100, stressLevel * 100))

        // Determine category
        let category = StressResult.category(for: clampedLevel)

        // Calculate confidence (default samples for now)
        let confidence = calculateConfidence(hrv: hrv, heartRate: heartRate, samples: 1)

        return StressResult(
            level: clampedLevel,
            category: category,
            confidence: confidence,
            hrv: hrv,
            heartRate: heartRate,
            timestamp: Date()
        )
    }

    func calculateConfidence(hrv: Double, heartRate: Double, samples: Int) -> Double {
        var confidence = 1.0

        // Reduce confidence for low HRV readings
        if hrv < 20 {
            confidence *= 0.5
        }

        // Reduce confidence for extreme heart rates
        if heartRate < 40 || heartRate > 180 {
            confidence *= 0.6
        }

        // Adjust based on sample count (more samples = higher confidence)
        let sampleMultiplier = min(1.0, Double(samples) / 10.0)
        confidence *= (0.7 + (sampleMultiplier * 0.3))

        return max(0.0, min(1.0, confidence))
    }

    // MARK: - Private Helper Methods
    /// Normalizes HRV value relative to baseline
    /// Returns: (Baseline - HRV) / Baseline
    private func normalizeHRV(_ hrv: Double, baseline: Double) -> Double {
        guard baseline > 0 else { return 0 }
        return (baseline - hrv) / baseline
    }

    /// Normalizes heart rate value relative to resting heart rate
    /// Returns: (HR - Resting HR) / Resting HR
    private func normalizeHeartRate(_ heartRate: Double, resting: Double) -> Double {
        guard resting > 0 else { return 0 }
        return (heartRate - resting) / resting
    }

    /// Calculates HRV component using power function
    /// Returns: Normalized HRV ^ 0.8 (0-1 scale)
    private func calculateHRVComponent(_ normalizedHRV: Double) -> Double {
        // Ensure non-negative for power operation
        let value = max(0, normalizedHRV)
        return pow(value, 0.8)
    }

    /// Calculates heart rate component using atan function
    /// Returns: atan(Normalized HR * 2) / (π/2) (0-1 scale)
    private func calculateHRComponent(_ normalizedHR: Double) -> Double {
        let scaled = normalizedHR * 2
        let atanValue = atan(scaled)
        let result = atanValue / (.pi / 2)

        // Return 0-1 scale
        return max(0, result)
    }
}

// MARK: - Thread Safety
extension StressCalculator: @unchecked Sendable {}
</file>

<file path="StressMonitor/StressMonitor/Services/Background/HealthBackgroundScheduler.swift">
import BackgroundTasks
import Foundation
import UIKit

@MainActor
final class HealthBackgroundScheduler {
  private let healthKit: HealthKitServiceProtocol
  private let algorithm: StressAlgorithmServiceProtocol
  private let repository: StressRepositoryProtocol
  private let notificationManager: NotificationManager

  private let backgroundTaskIdentifier = "com.stressmonitor.background.refresh"

  init(
    healthKit: HealthKitServiceProtocol,
    algorithm: StressAlgorithmServiceProtocol,
    repository: StressRepositoryProtocol
  ) {
    self.healthKit = healthKit
    self.algorithm = algorithm
    self.repository = repository
    self.notificationManager = .shared
  }

  func scheduleBackgroundRefresh() throws {
    let request = BGAppRefreshTaskRequest(identifier: backgroundTaskIdentifier)
    request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)
    try BGTaskScheduler.shared.submit(request)
  }

  func registerBackgroundTask() {
    BGTaskScheduler.shared.register(
      forTaskWithIdentifier: backgroundTaskIdentifier,
      using: nil
    ) { [weak self] task in
      guard let self else { return }
      Task {
        await self.handleBackgroundRefresh(task: task as! BGAppRefreshTask)
      }
    }
  }

  func handleBackgroundRefresh(task: BGAppRefreshTask) async {
    let operation = Task {
      do {
        try await self.fetchAndCalculateStress()
      } catch {
        print("Background refresh failed: \(error)")
      }
    }

    task.expirationHandler = {
      operation.cancel()
      task.setTaskCompleted(success: false)
    }

    _ = await operation.value
    task.setTaskCompleted(success: !operation.isCancelled)

    if !operation.isCancelled {
      try? scheduleBackgroundRefresh()
    }
  }

  func cancelAllTasks() {
    BGTaskScheduler.shared.cancel(taskRequestWithIdentifier: backgroundTaskIdentifier)
  }

  private func fetchAndCalculateStress() async throws {
    async let hrv = healthKit.fetchLatestHRV()
    async let hr = healthKit.fetchHeartRate(samples: 1)

    let (hrvData, hrData) = try await (hrv, hr)

    guard let hrvValue = hrvData?.value else {
      return
    }

    let heartRateValue = hrData.first?.value ?? 70
    let result = try await algorithm.calculateStress(hrv: hrvValue, heartRate: heartRateValue)

    let measurement = StressMeasurement(
      timestamp: result.timestamp,
      stressLevel: result.level,
      hrv: result.hrv,
      restingHeartRate: result.heartRate,
      confidences: [result.confidence]
    )

    try await repository.save(measurement)

    if result.level > 75 {
      await notificationManager.notifyHighStress(level: result.level)
    }
  }
}
</file>

<file path="StressMonitor/StressMonitor/Services/Protocols/HealthKitServiceProtocol.swift">
import Foundation

@preconcurrency import HealthKit

protocol HealthKitServiceProtocol: Sendable {
    func requestAuthorization() async throws
    func fetchLatestHRV() async throws -> HRVMeasurement?
    func fetchHeartRate(samples: Int) async throws -> [HeartRateSample]
    func fetchHRVHistory(since: Date) async throws -> [HRVMeasurement]
    func observeHeartRateUpdates() -> AsyncStream<HeartRateSample?>
}
</file>

<file path="StressMonitor/StressMonitor/Services/MockServices.swift">
import Foundation
import SwiftData

// MARK: - Mock HealthKit Service

/// Mock HealthKit service for SwiftUI previews and testing
final class MockHealthKitService: HealthKitServiceProtocol, @unchecked Sendable {
    var mockHRV: Double = 50.0
    var mockHeartRate: Double = 72.0
    var mockHRVHistory: [HRVMeasurement] = []
    var shouldThrowError: Bool = false

    func requestAuthorization() async throws {
        if shouldThrowError { throw NSError(domain: "Mock", code: -1) }
    }

    func fetchLatestHRV() async throws -> HRVMeasurement? {
        if shouldThrowError { throw NSError(domain: "Mock", code: -1) }
        return HRVMeasurement(value: mockHRV, timestamp: Date())
    }

    func fetchHeartRate(samples: Int) async throws -> [HeartRateSample] {
        if shouldThrowError { throw NSError(domain: "Mock", code: -1) }
        return [HeartRateSample(value: mockHeartRate, timestamp: Date())]
    }

    func fetchHRVHistory(since: Date) async throws -> [HRVMeasurement] {
        if shouldThrowError { throw NSError(domain: "Mock", code: -1) }
        return mockHRVHistory.isEmpty
            ? [HRVMeasurement(value: mockHRV, timestamp: Date())]
            : mockHRVHistory
    }

    func observeHeartRateUpdates() -> AsyncStream<HeartRateSample?> {
        AsyncStream { continuation in
            continuation.yield(HeartRateSample(value: mockHeartRate, timestamp: Date()))
            continuation.finish()
        }
    }
}

// MARK: - Mock Algorithm Service

/// Mock stress algorithm service for SwiftUI previews
final class MockStressAlgorithmService: StressAlgorithmServiceProtocol, @unchecked Sendable {
    var mockStressLevel: Double = 35.0
    var mockConfidence: Double = 0.85

    func calculateStress(hrv: Double, heartRate: Double) async throws -> StressResult {
        StressResult(
            level: mockStressLevel,
            category: StressCategory(from: mockStressLevel),
            confidence: mockConfidence,
            hrv: hrv,
            heartRate: heartRate,
            timestamp: Date()
        )
    }

    func calculateConfidence(hrv: Double, heartRate: Double, samples: Int) -> Double {
        mockConfidence
    }
}

// MARK: - Mock Repository Service

/// Mock stress repository for SwiftUI previews
/// Note: @MainActor provides implicit Sendable conformance
@MainActor
final class MockStressRepository: StressRepositoryProtocol {
    var mockMeasurements: [StressMeasurement] = []
    var mockBaseline: PersonalBaseline = PersonalBaseline(restingHeartRate: 65, baselineHRV: 50)

    func save(_ measurement: StressMeasurement) async throws {
        mockMeasurements.append(measurement)
    }

    func fetchRecent(limit: Int) async throws -> [StressMeasurement] {
        Array(mockMeasurements.prefix(limit))
    }

    func fetchAll() async throws -> [StressMeasurement] {
        mockMeasurements
    }

    func deleteOlderThan(_ date: Date) async throws {}

    func getBaseline() async throws -> PersonalBaseline {
        mockBaseline
    }

    func updateBaseline(_ baseline: PersonalBaseline) async throws {
        mockBaseline = baseline
    }

    func fetchMeasurements(from: Date, to: Date) async throws -> [StressMeasurement] {
        mockMeasurements.filter { $0.timestamp >= from && $0.timestamp <= to }
    }

    func delete(_ measurement: StressMeasurement) async throws {
        mockMeasurements.removeAll { $0.id == measurement.id }
    }

    func fetchAverageHRV(hours: Int) async throws -> Double {
        mockBaseline.baselineHRV
    }

    func fetchAverageHRV(days: Int) async throws -> Double {
        mockBaseline.baselineHRV
    }

    func deleteAllMeasurements() async throws {
        mockMeasurements.removeAll()
    }
}

// MARK: - Preview Data Factory

/// Factory for creating preview data for SwiftUI previews
enum PreviewDataFactory {

    // MARK: Stress Results

    /// Relaxed stress result (0-25 range)
    static func relaxedStress() -> StressResult {
        StressResult(level: 15, category: .relaxed, confidence: 0.92, hrv: 65, heartRate: 58)
    }

    /// Mild stress result (25-50 range)
    static func mildStress() -> StressResult {
        StressResult(level: 38, category: .mild, confidence: 0.85, hrv: 45, heartRate: 72)
    }

    /// Moderate stress result (50-75 range)
    static func moderateStress() -> StressResult {
        StressResult(level: 62, category: .moderate, confidence: 0.78, hrv: 32, heartRate: 85)
    }

    /// High stress result (75-100 range)
    static func highStress() -> StressResult {
        StressResult(level: 85, category: .high, confidence: 0.88, hrv: 22, heartRate: 98)
    }

    // MARK: Mock Services

    /// Mock HealthKit service with default preview data
    static func mockHealthKit(
        hrv: Double = 50,
        heartRate: Double = 72
    ) -> MockHealthKitService {
        let service = MockHealthKitService()
        service.mockHRV = hrv
        service.mockHeartRate = heartRate
        return service
    }

    /// Mock algorithm service with default preview data
    static func mockAlgorithm(
        stressLevel: Double = 35,
        confidence: Double = 0.85
    ) -> MockStressAlgorithmService {
        let service = MockStressAlgorithmService()
        service.mockStressLevel = stressLevel
        service.mockConfidence = confidence
        return service
    }

    /// Mock repository with pre-populated measurements
    static func mockRepository(
        measurements: [StressMeasurement] = []
    ) -> MockStressRepository {
        let repo = MockStressRepository()
        repo.mockMeasurements = measurements
        return repo
    }

    // MARK: Mock ViewModels

    /// StressViewModel configured for previews with mock services
    static func mockStressViewModel(
        stressResult: StressResult? = nil,
        liveHeartRate: Double? = nil,
        isLoading: Bool = false,
        errorMessage: String? = nil
    ) -> StressViewModel {
        let healthKit = mockHealthKit(
            hrv: stressResult?.hrv ?? 50,
            heartRate: stressResult?.heartRate ?? 72
        )
        let algorithm = mockAlgorithm(
            stressLevel: stressResult?.level ?? 35,
            confidence: stressResult?.confidence ?? 0.85
        )
        let repository = mockRepository()

        let viewModel = StressViewModel(
            healthKit: healthKit,
            algorithm: algorithm,
            repository: repository
        )

        // Set preview state directly
        viewModel.currentStress = stressResult
        viewModel.liveHeartRate = liveHeartRate
        viewModel.isLoading = isLoading
        viewModel.errorMessage = errorMessage

        return viewModel
    }

    // MARK: - Dashboard Mock Data

    /// Generate mock measurements for today's timeline
    static func mockTodayMeasurements() -> [StressMeasurement] {
        let now = Date()
        let calendar = Calendar.current
        return (0..<8).map { i in
            let hourOffset = -(i * 2)
            let timestamp = calendar.date(byAdding: .hour, value: hourOffset, to: now) ?? now
            return StressMeasurement(
                timestamp: timestamp,
                stressLevel: Double.random(in: 25...65),
                hrv: Double.random(in: 35...70),
                restingHeartRate: Double.random(in: 58...75),
                confidences: [Double.random(in: 0.75...0.95)]
            )
        }.reversed().asArray
    }

    /// Generate mock HRV history for mini chart
    static func mockHRVHistory() -> [Double] {
        [42, 48, 45, 52, 49, 55, 58]
    }

    /// Mock weekly comparison data
    static func mockWeeklyComparison() -> (current: Double, previous: Double) {
        (current: 38.5, previous: 42.0)
    }

    /// Mock AI insight
    static func mockAIInsight() -> AIInsight {
        AIInsight(
            title: "Stable Stress Pattern",
            message: "Your stress has been consistent today. Regular breaks can help maintain this balance.",
            actionTitle: "Start Breathing",
            trendData: [35, 42, 38, 45, 40, 38]
        )
    }

    /// Fully populated StressViewModel for dashboard preview
    static func mockDashboardViewModel() -> StressViewModel {
        let viewModel = mockStressViewModel(
            stressResult: mildStress(),
            liveHeartRate: 68
        )

        // Populate dashboard-specific properties
        viewModel.hrvHistory = mockHRVHistory()
        viewModel.todayMeasurements = mockTodayMeasurements()
        viewModel.historicalData = generateMockHistoricalData()
        viewModel.weeklyCurrentAvg = 38.5
        viewModel.weeklyPreviousAvg = 42.0
        viewModel.heartRateTrend = .down
        viewModel.aiInsight = mockAIInsight()

        return viewModel
    }

    /// Generate 14 days of mock historical data
    static func generateMockHistoricalData() -> [StressMeasurement] {
        let calendar = Calendar.current
        let now = Date()

        return (0..<14).flatMap { dayOffset -> [StressMeasurement] in
            let day = calendar.date(byAdding: .day, value: -dayOffset, to: now) ?? now
            return (0..<3).map { hourOffset in
                let timestamp = calendar.date(byAdding: .hour, value: hourOffset * 6, to: day) ?? day
                return StressMeasurement(
                    timestamp: timestamp,
                    stressLevel: Double.random(in: 20...70),
                    hrv: Double.random(in: 30...65),
                    restingHeartRate: Double.random(in: 60...80),
                    confidences: [Double.random(in: 0.7...0.95)]
                )
            }
        }.sorted { $0.timestamp > $1.timestamp }
    }
}

// MARK: - Array Extension

private extension Array {
    var asArray: Array<Element> { self }
}

// MARK: - StressResult Preview Extensions

extension StressResult {
    /// Sample relaxed state for previews
    static var previewRelaxed: StressResult {
        PreviewDataFactory.relaxedStress()
    }

    /// Sample mild stress for previews
    static var previewMild: StressResult {
        PreviewDataFactory.mildStress()
    }

    /// Sample moderate stress for previews
    static var previewModerate: StressResult {
        PreviewDataFactory.moderateStress()
    }

    /// Sample high stress for previews
    static var previewHigh: StressResult {
        PreviewDataFactory.highStress()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Theme/Color+Wellness.swift">
import SwiftUI

// MARK: - Wellness Color Palette
extension Color {
    /// Wellness color palette based on calm blues and health greens
    struct Wellness {
        // MARK: - Primary Colors

        /// Calm Blue - Healthcare trust color
        static let calmBlue = Color(
            light: Color(hex: "#0891B2"), // Cyan-600
            dark: Color(hex: "#22D3EE")   // Cyan-400
        )

        /// Health Green - Wellness/growth
        static let healthGreen = Color(
            light: Color(hex: "#10B981"), // Emerald-500
            dark: Color(hex: "#34D399")   // Emerald-400
        )

        /// Gentle Purple - Mindfulness
        static let gentlePurple = Color(
            light: Color(hex: "#8B5CF6"), // Violet-500
            dark: Color(hex: "#A78BFA")   // Violet-400
        )

        // MARK: - Background Colors

        /// Pure black for OLED dark mode
        static let backgroundDark = Color(hex: "#000000")

        /// Light mode background
        static let backgroundLight = Color(hex: "#F2F2F7")

        /// Card surface in dark mode
        static let surfaceDark = Color(hex: "#1C1C1E")

        /// Card surface in light mode
        static let surfaceLight = Color.white

        // MARK: - Adaptive Colors

        /// Primary background that adapts to color scheme
        static let background = Color(
            light: backgroundLight,
            dark: backgroundDark
        )

        /// Surface color that adapts to color scheme
        static let surface = Color(
            light: surfaceLight,
            dark: surfaceDark
        )

        // MARK: - Adaptive UI Colors (Dashboard Redesign)

        /// Adaptive background - warm cream light, deep dark
        static let adaptiveBackground = Color(
            light: Color(hex: "#FFFDF6"),
            dark: Color(hex: "#121212")
        )

        /// Adaptive card background
        static let adaptiveCardBackground = Color(
            light: Color.white,
            dark: Color(hex: "#1E1E1E")
        )

        /// Adaptive primary text
        static let adaptivePrimaryText = Color(
            light: Color(hex: "#101223"),
            dark: Color.white
        )

        /// Adaptive secondary text
        static let adaptiveSecondaryText = Color(
            light: Color(hex: "#777986"),
            dark: Color(hex: "#9CA3AF")
        )

        // MARK: - Fixed Accent Colors

        /// Elevated badge accent (yellow-gold)
        static let elevatedBadge = Color(hex: "#FDD57A")

        /// Teal card accent
        static let tealCard = Color(hex: "#85C9C9")

        /// Exercise cyan accent
        static let exerciseCyan = Color(hex: "#86CECD")

        /// Sleep purple accent
        static let sleepPurple = Color(hex: "#BE8BE5")

        /// Daylight yellow accent
        static let daylightYellow = Color(hex: "#FFBD42")

        // MARK: - Quick Action Colors

        /// Gratitude purple
        static let gratitudePurple = Color(hex: "#9E85C9")

        /// Mini walk blue
        static let miniWalkBlue = Color(hex: "#859DC9")

        /// Box breathing purple
        static let boxBreathingPurple = Color(hex: "#A58FC7")

        // MARK: - Insight Colors

        /// AI insight title color
        static let insightTitle = Color(hex: "#FFBF00")

        /// AI insight text color
        static let insightText = Color(hex: "#5E5E5E")
    }
}

// MARK: - Stress Level Colors with Dual Coding
extension Color {
    /// Get stress color with dual coding support (color + icon)
    /// - Parameters:
    ///   - category: The stress category
    ///   - highContrast: Whether to use high contrast variant
    /// - Returns: Color for the stress level
    static func accessibleStressColor(for category: StressCategory, highContrast: Bool = false) -> Color {
        if highContrast {
            // WCAG AAA compliant high contrast colors (7:1 ratio)
            switch category {
            case .relaxed:
                return Color(hex: "#00A000") // Darker green
            case .mild:
                return Color(hex: "#0050FF") // Darker blue
            case .moderate:
                return Color(hex: "#FFA500") // Orange (not yellow for better contrast)
            case .high:
                return Color(hex: "#CC0000") // Dark red
            }
        }

        // Standard colors with WCAG AA compliance (4.5:1 ratio)
        // Delegate to StressCategory as single source of truth
        return category.color
    }
}

// MARK: - Accessibility-Aware View Modifier
struct AccessibilityContrastModifier: ViewModifier {
    @Environment(\.colorSchemeContrast) var colorSchemeContrast
    let category: StressCategory

    func body(content: Content) -> some View {
        content
            .foregroundStyle(
                Color.accessibleStressColor(
                    for: category,
                    highContrast: colorSchemeContrast == .increased
                )
            )
    }
}

extension View {
    /// Apply accessible stress color based on system contrast setting
    /// - Parameter category: The stress category
    /// - Returns: View with accessible color applied
    func accessibleStressColor(for category: StressCategory) -> some View {
        modifier(AccessibilityContrastModifier(category: category))
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Components/HapticManager.swift">
import UIKit
import CoreHaptics

@MainActor
final class HapticManager {
    static let shared = HapticManager()

    private var engine: CHHapticEngine?
    private var supportsHaptics: Bool {
        CHHapticEngine.capabilitiesForHardware().supportsHaptics
    }

    private init() {
        setupHapticEngine()
    }

    private func setupHapticEngine() {
        guard supportsHaptics else { return }

        do {
            engine = try CHHapticEngine()
            try engine?.start()
        } catch {
            print("Haptic engine failed to start: \(error)")
        }
    }

    func stressLevelChanged(to category: StressCategory) {
        guard supportsHaptics else { return }

        switch category {
        case .relaxed:
            success()
        case .mild:
            light()
        case .moderate:
            warning()
        case .high:
            error()
        }
    }

    func stressBuddyMoodChange(to mood: StressBuddyMood) {
        guard supportsHaptics else { return }

        let generator = UIImpactFeedbackGenerator(style: .medium)
        generator.impactOccurred()
    }

    func breathingCue() {
        guard supportsHaptics else { return }

        let generator = UIImpactFeedbackGenerator(style: .light)
        generator.impactOccurred(intensity: 0.5)
    }

    func buttonPress() {
        guard supportsHaptics else { return }

        let generator = UIImpactFeedbackGenerator(style: .medium)
        generator.impactOccurred()
    }

    func success() {
        guard supportsHaptics else { return }

        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.success)
    }

    func warning() {
        guard supportsHaptics else { return }

        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.warning)
    }

    func error() {
        guard supportsHaptics else { return }

        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(.error)
    }

    private func light() {
        guard supportsHaptics else { return }

        let generator = UIImpactFeedbackGenerator(style: .light)
        generator.impactOccurred()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/DateHeaderView.swift">
import SwiftUI

/// Day and date header view for dashboard
/// Matches Figma design: 28px bold day, 14px bold date
struct DateHeaderView: View {
    private let date: Date

    init(date: Date = Date()) {
        self.date = date
    }

    private var dayName: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE"
        return formatter.string(from: date)
    }

    private var fullDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM d, yyyy"
        return formatter.string(from: date)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(dayName)
                .font(.system(size: 28, weight: .bold))
                .foregroundStyle(Color.Wellness.adaptivePrimaryText)

            Text(fullDate)
                .font(.system(size: 14, weight: .bold))
                .foregroundStyle(Color.Wellness.adaptivePrimaryText)
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(dayName), \(fullDate)")
    }
}

#Preview("DateHeaderView") {
    VStack {
        DateHeaderView()
        Spacer()
    }
    .padding()
    .background(Color.Wellness.adaptiveBackground)
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/MetricCardView.swift">
import SwiftUI

/// Enhanced metric card with optional mini chart and trend indicator
struct MetricCardView: View {
    let icon: String
    let iconColor: Color
    let title: String
    let value: String
    let unit: String
    let trend: Trend?
    let chartData: [Double]?

    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    // MARK: - Trend Types

    enum Trend {
        case up(String)    // Value to display (e.g., "+5%")
        case down(String)  // Value to display (e.g., "-2 bpm")
        case stable

        var color: Color {
            switch self {
            case .down: return .stressRelaxed
            case .up: return .stressHigh
            case .stable: return .secondary
            }
        }

        var icon: String {
            switch self {
            case .up: return "arrow.up.right"
            case .down: return "arrow.down.right"
            case .stable: return "arrow.right"
            }
        }

        var displayValue: String {
            switch self {
            case .up(let v), .down(let v): return v
            case .stable: return "—"
            }
        }
    }

    // MARK: - Body

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header with icon and title
            HStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 14))
                    .foregroundColor(iconColor)
                    .frame(width: 28, height: 28)
                    .background(iconColor.opacity(0.15))
                    .cornerRadius(8)

                Text(title)
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(Color.oledTextSecondary)

                Spacer()
            }

            // Value row with animation
            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text(value)
                    .font(.system(size: 32, weight: .bold, design: .rounded))
                    .foregroundColor(.white)
                    .contentTransition(
                        reduceMotion ? .identity : .numericText()
                    )
                    .animation(
                        reduceMotion ? .none : .spring(response: 0.3, dampingFraction: 0.7),
                        value: value
                    )

                if !unit.isEmpty {
                    Text(unit)
                        .font(.caption)
                        .foregroundColor(Color.oledTextSecondary)
                }

                Spacer()
            }

            // Chart or trend indicator - fixed height for equal card heights
            Group {
                if let chartData = chartData, !chartData.isEmpty {
                    MiniLineChartView(dataPoints: chartData, color: iconColor)
                } else if let trend = trend {
                    HStack(spacing: 4) {
                        Image(systemName: trend.icon)
                            .font(.caption2)
                        Text(trend.displayValue)
                            .font(.caption2)
                            .fontWeight(.medium)
                    }
                    .foregroundColor(trend.color)
                    .frame(height: 40, alignment: .leading)
                }
            }
            .frame(height: 40)
        }
        .padding(16)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color.oledCardBackground)
        .cornerRadius(16)
        .accessibilityElement(children: .combine)
        .accessibilityLabel(accessibilityLabel)
        .accessibilityValue("\(value) \(unit)")
    }

    // MARK: - Accessibility

    private var accessibilityLabel: String {
        var label = title
        if let trend = trend {
            label += ", trend: \(trend.displayValue)"
        }
        return label
    }
}

// MARK: - Convenience Initializers

extension MetricCardView {
    /// HRV metric card with chart
    static func hrv(value: String, chartData: [Double]) -> MetricCardView {
        MetricCardView(
            icon: "heart.fill",
            iconColor: .hrvAccent,
            title: "HRV",
            value: value,
            unit: "ms",
            trend: nil,
            chartData: chartData
        )
    }

    /// Heart rate metric card with trend
    static func heartRate(value: String, trendValue: String, isDown: Bool) -> MetricCardView {
        MetricCardView(
            icon: "heart.fill",
            iconColor: .heartRateAccent,
            title: "RESTING HR",
            value: value,
            unit: "bpm",
            trend: isDown ? .down(trendValue) : .up(trendValue),
            chartData: nil
        )
    }
}

#Preview("Metric Cards") {
    ZStack {
        Color.oledBackground.ignoresSafeArea()

        HStack(spacing: 12) {
            MetricCardView.hrv(
                value: "65",
                chartData: [45, 52, 48, 55, 50, 58, 65]
            )

            MetricCardView.heartRate(
                value: "58",
                trendValue: "-2 bpm",
                isDown: true
            )
        }
        .padding()
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/Components/StressRingView.swift">
import SwiftUI

struct StressRingView: View {
    let stressLevel: Double
    let category: StressCategory

    @State private var animateRing = false
    @Environment(\.accessibilityReduceMotion) private var reduceMotion

    var body: some View {
        ZStack {
            Circle()
                .stroke(
                    Color.secondary.opacity(0.15),
                    lineWidth: 30
                )
                .frame(width: 260, height: 260)

            Circle()
                .trim(from: 0, to: animateRing ? stressLevel / 100 : 0)
                .stroke(
                    colorForCategory(category),
                    style: StrokeStyle(lineWidth: 30, lineCap: .round)
                )
                .frame(width: 260, height: 260)
                .rotationEffect(.degrees(-90))
                .animation(
                    reduceMotion
                        ? .linear(duration: 0.3)
                        : .spring(response: 0.6, dampingFraction: 0.7),
                    value: animateRing
                )

            VStack(spacing: 4) {
                Image(systemName: iconForCategory(category))
                    .font(.system(size: 44))
                    .foregroundColor(colorForCategory(category))
                    .symbolEffect(.bounce, value: category)

                Text("\(Int(stressLevel))")
                    .font(.system(size: 72, weight: .bold, design: .rounded))
                    .foregroundColor(.primary)
                    .contentTransition(
                        reduceMotion
                            ? .identity
                            : .numericText(countsDown: false)
                    )

                Text("STRESS")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Stress level")
        .accessibilityValue("\(Int(stressLevel)) out of 100")
        .onAppear {
            withAnimation(.spring(response: 0.8, dampingFraction: 0.7)) {
                animateRing = true
            }
        }
        .onChange(of: stressLevel) { _, newValue in
            withAnimation(.spring(response: 0.6, dampingFraction: 0.7)) {
                animateRing = true
            }
        }
    }

    private func colorForCategory(_ category: StressCategory) -> Color {
        Color.stressColor(for: category)
    }

    private func iconForCategory(_ category: StressCategory) -> String {
        category.icon
    }
}

#Preview {
    VStack(spacing: 32) {
        StressRingView(stressLevel: 15, category: .relaxed)
        StressRingView(stressLevel: 45, category: .mild)
        StressRingView(stressLevel: 70, category: .moderate)
        StressRingView(stressLevel: 90, category: .high)
    }
    .padding()
}
</file>

<file path="StressMonitor/StressMonitor/Views/Settings/SettingsView.swift">
import SwiftUI
import SwiftData

struct SettingsView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: SettingsViewModel
    @State private var showingDeleteConfirmation = false
    @State private var exportURL: URL?

    init() {
        _viewModel = State(initialValue: SettingsViewModel(
            modelContext: ModelContext(try! ModelContainer(for: StressMeasurement.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true)))
        ))
    }

    var body: some View {
        Form {
            Section("Profile") {
                HStack {
                    Text("Name")
                    Spacer()
                    TextField("Your Name", text: $viewModel.userProfile.name)
                        .textFieldStyle(.plain)
                        .multilineTextAlignment(.trailing)
                }

                HStack {
                    Text("Resting HR")
                    Spacer()
                    Text("\(Int(viewModel.userProfile.restingHeartRate)) bpm")
                        .foregroundColor(.secondary)
                }

                HStack {
                    Text("Baseline HRV")
                    Spacer()
                    Text("\(Int(viewModel.userProfile.baselineHRV)) ms")
                        .foregroundColor(.secondary)
                }
            }

            Section("Notifications") {
                Toggle("High Stress Alerts", isOn: $viewModel.notificationSettings.highStressAlerts)
                Toggle("Daily Reminders", isOn: $viewModel.notificationSettings.dailyReminders)
                Toggle("Weekly Report", isOn: $viewModel.notificationSettings.weeklyReport)
            }

            // MARK: - Data Management Section
            Section("Data Management") {
                // CloudKit Sync Status
                HStack {
                    Image(systemName: "icloud.fill")
                        .foregroundColor(viewModel.cloudKitStatus.color)
                    Text("iCloud Sync")
                        .foregroundColor(.primary)
                    Spacer()
                    Text(viewModel.cloudKitStatus.statusText)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .accessibilityElement(children: .combine)
                .accessibilityLabel("iCloud sync status: \(viewModel.cloudKitStatus.statusText)")

                NavigationLink(destination: DataExportView()) {
                    HStack {
                        Image(systemName: "square.and.arrow.up")
                            .foregroundColor(.primaryBlue)
                        Text("Export Data")
                    }
                }
                .accessibilityLabel("Export data")

                NavigationLink(destination: DataDeleteView()) {
                    HStack {
                        Image(systemName: "trash")
                            .foregroundColor(.error)
                        Text("Delete Data")
                            .foregroundColor(.primary)
                    }
                }
                .accessibilityLabel("Delete data")
            }

            Section {
                HStack {
                    Text("Version")
                    Spacer()
                    Text("1.0.0")
                        .foregroundColor(.secondary)
                }

                HStack {
                    Text("Build")
                    Spacer()
                    Text("2025.01.19")
                        .foregroundColor(.secondary)
                }
            }
        }
        .navigationTitle("Settings")
        .onAppear {
            viewModel = SettingsViewModel(modelContext: modelContext)
            Task { await viewModel.loadUserProfile() }
        }
        .sheet(isPresented: $showingDeleteConfirmation) {
            deleteConfirmationSheet
        }
    }

    private var deleteConfirmationSheet: some View {
        NavigationView {
            VStack(spacing: 24) {
                Spacer()

                Image(systemName: "trash.circle.fill")
                    .font(.system(size: 64))
                    .foregroundColor(.error)

                Text("Delete All Data")
                    .font(.title2)
                    .fontWeight(.bold)

                Text("This will permanently delete all your stress measurements. This action cannot be undone.")
                    .font(.body)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                VStack(spacing: 12) {
                    Button(role: .destructive, action: {
                        Task {
                            try? await viewModel.deleteAllMeasurements()
                        }
                        showingDeleteConfirmation = false
                    }) {
                        Text("Delete Everything")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .frame(height: 52)
                            .background(Color.error)
                            .cornerRadius(26)
                    }

                    Button(action: { showingDeleteConfirmation = false }) {
                        Text("Cancel")
                            .font(.headline)
                            .foregroundColor(.primaryBlue)
                            .frame(maxWidth: .infinity)
                            .frame(height: 52)
                            .background(Color.primaryBlue.opacity(0.1))
                            .cornerRadius(26)
                    }
                }
                .padding(.horizontal, 32)

                Spacer()
            }
            .padding(.top, 32)
            .navigationTitle("Confirm Deletion")
            .navigationBarTitleDisplayMode(.inline)
        }
    }

    private func shareExport(url: URL) {
        let activityVC = UIActivityViewController(
            activityItems: [url],
            applicationActivities: nil
        )

        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootVC = windowScene.windows.first?.rootViewController {
            rootVC.present(activityVC, animated: true)
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/Settings/SettingsViewModel.swift">
import SwiftUI
import SwiftData

@Observable
class SettingsViewModel {
    var userProfile: UserProfile
    var notificationSettings: NotificationSettings
    var exportSettings: ExportSettings
    var isDeletingAllData = false
    var cloudKitStatus: CloudKitSyncStatus = .unknown

    private let repository: StressRepositoryProtocol

    init(modelContext: ModelContext, baselineCalculator: BaselineCalculator? = nil) {
        self.repository = StressRepository(modelContext: modelContext, baselineCalculator: baselineCalculator)
        self.userProfile = UserProfile(name: "", age: nil, restingHeartRate: 60, baselineHRV: 50)
        self.notificationSettings = NotificationSettings()
        self.exportSettings = ExportSettings()
    }

    func loadUserProfile() async {
        if let baseline = try? await repository.getBaseline() {
            userProfile = UserProfile(
                name: "",
                age: nil,
                restingHeartRate: baseline.restingHeartRate,
                baselineHRV: baseline.baselineHRV
            )
        }

        // Check CloudKit status
        await checkCloudKitStatus()
    }

    private func checkCloudKitStatus() async {
        // TODO: Implement actual CloudKit status check
        // For now, default to upToDate
        cloudKitStatus = .upToDate
    }

    func updateProfile(_ profile: UserProfile) async throws {
        let baseline = PersonalBaseline(
            restingHeartRate: profile.restingHeartRate,
            baselineHRV: profile.baselineHRV,
            lastUpdated: Date()
        )
        try await repository.updateBaseline(baseline)
        userProfile = profile
    }

    func deleteAllMeasurements() async throws {
        isDeletingAllData = true
        defer { isDeletingAllData = false }
        try await repository.deleteAllMeasurements()
    }
}

struct UserProfile: Codable {
    var name: String
    var age: Int?
    var restingHeartRate: Double
    var baselineHRV: Double
}

struct NotificationSettings: Codable {
    var highStressAlerts: Bool = true
    var dailyReminders: Bool = true
    var reminderTime: Date = Calendar.current.date(from: DateComponents(hour: 9, minute: 0)) ?? Date()
    var weeklyReport: Bool = true
}

struct ExportSettings: Codable {
    var includeHRV: Bool = true
    var includeHeartRate: Bool = true
    var includeStressLevel: Bool = true
    var dateRange: ExportDateRange = .week
    var format: ExportFormat = .csv
}

enum ExportDateRange: String, CaseIterable, Codable {
    case day = "Last 24 Hours"
    case week = "Last 7 Days"
    case month = "Last 4 Weeks"
    case threeMonths = "Last 3 Months"
    case all = "All Time"
    case custom = "Custom"
}

enum ExportFormat: String, CaseIterable, Codable {
    case csv = "CSV"
    case json = "JSON"
}

/// CloudKit sync status for display in settings
enum CloudKitSyncStatus {
    case unknown
    case notSignedIn
    case syncing
    case syncFailed
    case upToDate

    var statusText: String {
        switch self {
        case .unknown: return "Unknown"
        case .notSignedIn: return "Not Signed In"
        case .syncing: return "Syncing..."
        case .syncFailed: return "Sync Failed"
        case .upToDate: return "Up to Date"
        }
    }

    var color: Color {
        switch self {
        case .unknown: return .secondary
        case .notSignedIn: return .secondary
        case .syncing: return .primaryBlue
        case .syncFailed: return .error
        case .upToDate: return .success
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/TestHelpers/TestDataFactory.swift">
import Foundation
import SwiftData
@testable import StressMonitor

struct TestDataFactory {

    static func createMeasurement(
        stressLevel: Double = 50,
        hrv: Double = 50,
        heartRate: Double = 60,
        daysAgo: Int = 0
    ) -> StressMeasurement {
        let timestamp = Date().addingTimeInterval(-Double(daysAgo * 86400))
        return StressMeasurement(
            timestamp: timestamp,
            stressLevel: stressLevel,
            hrv: hrv,
            restingHeartRate: heartRate,
            confidences: [0.8]
        )
    }

    static func createMeasurementBatch(
        count: Int,
        stressRange: ClosedRange<Double> = 20...80,
        hrvRange: ClosedRange<Double> = 30...70,
        startDaysAgo: Int = 0
    ) -> [StressMeasurement] {
        (0..<count).map { index in
            let stress = Double.random(in: stressRange)
            let hrv = Double.random(in: hrvRange)
            let heartRate = Double.random(in: 50...90)
            return createMeasurement(
                stressLevel: stress,
                hrv: hrv,
                heartRate: heartRate,
                daysAgo: startDaysAgo + index
            )
        }
    }

    static func createInMemoryContainer() throws -> ModelContainer {
        let schema = Schema([StressMeasurement.self])
        let configuration = ModelConfiguration(isStoredInMemoryOnly: true)
        return try ModelContainer(for: schema, configurations: [configuration])
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/OnboardingBaselineCalibrationViewModelTests.swift">
import XCTest
@testable import StressMonitor

@MainActor
final class OnboardingBaselineCalibrationViewModelTests: XCTestCase {
    var viewModel: OnboardingBaselineCalibrationViewModel!
    var mockRepository: MockBaselineRepository!

    override func setUp() {
        super.setUp()
        mockRepository = MockBaselineRepository()
        viewModel = OnboardingBaselineCalibrationViewModel(repository: mockRepository)
    }

    override func tearDown() {
        viewModel = nil
        mockRepository = nil
        UserDefaults.standard.removeObject(forKey: "calibrationDay")
        UserDefaults.standard.removeObject(forKey: "calibrationCompleted")
        super.tearDown()
    }

    func testInitialState() {
        XCTAssertEqual(viewModel.currentDay, 1, "Should start on day 1")
        XCTAssertFalse(viewModel.calibrationCompleted, "Should not be completed initially")
        XCTAssertFalse(viewModel.dailyMeasurementTaken, "Should not have measurement taken initially")
    }

    func testStartCalibration() {
        viewModel.currentDay = 5
        viewModel.dailyMeasurementTaken = true

        viewModel.startCalibration()

        XCTAssertEqual(viewModel.currentDay, 1, "Should reset to day 1")
        XCTAssertFalse(viewModel.dailyMeasurementTaken, "Should reset measurement status")
        XCTAssertFalse(viewModel.calibrationCompleted, "Should not be completed")
    }

    func testRecordDailyMeasurement() async {
        viewModel.currentDay = 1

        await viewModel.recordDailyMeasurement()

        // After recording, day advances and measurement resets for next day
        XCTAssertEqual(viewModel.currentDay, 2, "Should advance to next day")
        XCTAssertFalse(viewModel.dailyMeasurementTaken, "Should reset for next day")
    }

    func testRecordFinalDayMeasurement() async {
        viewModel.currentDay = 7

        await viewModel.recordDailyMeasurement()

        XCTAssertTrue(viewModel.calibrationCompleted, "Should be completed after day 7")
    }

    func testCalibrationPhases() {
        viewModel.currentDay = 1
        XCTAssertEqual(viewModel.currentPhase, .learning, "Day 1 should be learning phase")

        viewModel.currentDay = 2
        XCTAssertEqual(viewModel.currentPhase, .learning, "Day 2 should be learning phase")

        viewModel.currentDay = 4
        XCTAssertEqual(viewModel.currentPhase, .calibration, "Day 4 should be calibration phase")

        viewModel.currentDay = 6
        XCTAssertEqual(viewModel.currentPhase, .validation, "Day 6 should be validation phase")

        viewModel.currentDay = 8
        XCTAssertEqual(viewModel.currentPhase, .complete, "Day 8 should be complete phase")
    }

    func testCompleteCalibration() {
        XCTAssertFalse(UserDefaults.standard.bool(forKey: "baselineCalibrated"))

        viewModel.completeCalibration()

        XCTAssertTrue(UserDefaults.standard.bool(forKey: "baselineCalibrated"))
    }

    func testPersistCalibrationState() {
        viewModel.currentDay = 3
        viewModel.startCalibration()

        let persistedDay = UserDefaults.standard.integer(forKey: "calibrationDay")
        XCTAssertEqual(persistedDay, 1, "Should persist calibration state when starting")
    }
}

// Mock Repository for baseline calibration tests
final class MockBaselineRepository: StressRepositoryProtocol {
    func save(_ measurement: StressMeasurement) async throws {}

    func fetchRecent(limit: Int) async throws -> [StressMeasurement] {
        return []
    }

    func fetchAll() async throws -> [StressMeasurement] {
        return []
    }

    func deleteOlderThan(_ date: Date) async throws {}

    func getBaseline() async throws -> PersonalBaseline {
        return PersonalBaseline()
    }

    func updateBaseline(_ baseline: PersonalBaseline) async throws {}

    func fetchMeasurements(from: Date, to: Date) async throws -> [StressMeasurement] {
        return []
    }

    func delete(_ measurement: StressMeasurement) async throws {}

    func fetchAverageHRV(hours: Int) async throws -> Double {
        return 0.0
    }

    func fetchAverageHRV(days: Int) async throws -> Double {
        return 0.0
    }

    func deleteAllMeasurements() async throws {}
}
</file>

<file path="StressMonitor/StressMonitorTests/OnboardingSuccessViewModelTests.swift">
import XCTest
@testable import StressMonitor

@MainActor
final class OnboardingSuccessViewModelTests: XCTestCase {
    var viewModel: OnboardingSuccessViewModel!
    var mockRepository: MockSuccessRepository!

    override func setUp() {
        super.setUp()
        mockRepository = MockSuccessRepository()
        viewModel = OnboardingSuccessViewModel(repository: mockRepository)
    }

    override func tearDown() {
        viewModel = nil
        mockRepository = nil
        UserDefaults.standard.removeObject(forKey: "hasCompletedOnboarding")
        super.tearDown()
    }

    func testInitialState() {
        XCTAssertNil(viewModel.personalBaseline, "Baseline should be nil initially")
    }

    func testLoadBaseline() async {
        mockRepository.baselineToReturn = PersonalBaseline(restingHeartRate: 60, baselineHRV: 50, lastUpdated: Date())

        viewModel.loadBaseline()

        try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 second

        XCTAssertNotNil(viewModel.personalBaseline, "Should load baseline")
        XCTAssertEqual(viewModel.personalBaseline?.restingHeartRate, 60)
        XCTAssertEqual(viewModel.personalBaseline?.baselineHRV, 50)
    }

    func testCompleteOnboarding() {
        XCTAssertFalse(UserDefaults.standard.bool(forKey: "hasCompletedOnboarding"))

        viewModel.completeOnboarding()

        XCTAssertTrue(UserDefaults.standard.bool(forKey: "hasCompletedOnboarding"))
    }

    func testCompleteOnboardingPersists() {
        viewModel.completeOnboarding()

        let flag = UserDefaults.standard.bool(forKey: "hasCompletedOnboarding")
        XCTAssertTrue(flag, "Onboarding completion flag should persist")
    }
}

// Mock Repository for success view tests
final class MockSuccessRepository: StressRepositoryProtocol {
    var baselineToReturn: PersonalBaseline?

    func save(_ measurement: StressMeasurement) async throws {}

    func fetchRecent(limit: Int) async throws -> [StressMeasurement] {
        return []
    }

    func fetchAll() async throws -> [StressMeasurement] {
        return []
    }

    func deleteOlderThan(_ date: Date) async throws {}

    func getBaseline() async throws -> PersonalBaseline {
        if let baseline = baselineToReturn {
            return baseline
        }
        return PersonalBaseline()
    }

    func updateBaseline(_ baseline: PersonalBaseline) async throws {}

    func fetchMeasurements(from: Date, to: Date) async throws -> [StressMeasurement] {
        return []
    }

    func delete(_ measurement: StressMeasurement) async throws {}

    func fetchAverageHRV(hours: Int) async throws -> Double {
        return 0.0
    }

    func fetchAverageHRV(days: Int) async throws -> Double {
        return 0.0
    }

    func deleteAllMeasurements() async throws {}
}
</file>

<file path="StressMonitor/StressMonitorTests/StressCalculatorTests.swift">
import XCTest
@testable import StressMonitor

// MARK: - Stress Calculator Tests
final class StressCalculatorTests: XCTestCase {

    // MARK: - Properties
    private var sut: StressCalculator!
    private var defaultBaseline: PersonalBaseline!

    // MARK: - Setup & Teardown
    override func setUp() async throws {
        try await super.setUp()
        defaultBaseline = PersonalBaseline(restingHeartRate: 60.0, baselineHRV: 50.0)
        sut = StressCalculator(baseline: defaultBaseline)
    }

    override func tearDown() async throws {
        sut = nil
        defaultBaseline = nil
        try await super.tearDown()
    }

    // MARK: - Normal Stress Calculation Tests
    func testNormalStress() async throws {
        // Given: Normal HRV (50ms) and normal heart rate (60bpm)
        let hrv = 50.0
        let heartRate = 60.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: Should be relaxed (low stress)
        XCTAssertEqual(result.level, 0, accuracy: 10, "Normal readings should result in near-zero stress")
        XCTAssertEqual(result.category, .relaxed, "Normal readings should be categorized as relaxed")
        XCTAssertEqual(result.hrv, hrv, accuracy: 0.001)
        XCTAssertEqual(result.heartRate, heartRate, accuracy: 0.001)
        XCTAssertTrue(result.confidence > 0, "Confidence should be positive")
    }

    func testHighStressElevatedHeartRate() async throws {
        // Given: Normal HRV but elevated heart rate (100bpm)
        let hrv = 50.0
        let heartRate = 100.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: Should show mild stress (HR component has 30% weight)
        // normalizedHR = (100-60)/60 = 0.667
        // hrComponent = atan(0.667*2) / (π/2) ≈ 0.59
        // stress = 0.59 * 0.3 * 100 ≈ 17.7
        XCTAssertEqual(result.level, 17.7, accuracy: 2, "Elevated heart rate should result in mild stress")
        XCTAssertEqual(result.category, .relaxed, "Normal HRV with elevated HR should be relaxed due to 70% HRV weight")
    }

    func testHighStressLowHRV() async throws {
        // Given: Low HRV (25ms) indicating stress
        let hrv = 25.0
        let heartRate = 60.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: Should show elevated stress
        XCTAssertGreaterThan(result.level, 30, "Low HRV should significantly increase stress")
        XCTAssertTrue([.mild, .moderate].contains(result.category), "Should be mild or moderate stress")
    }

    func testSevereStress() async throws {
        // Given: Very low HRV (20ms) and elevated heart rate (90bpm)
        let hrv = 20.0
        let heartRate = 90.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: Should show high stress
        // normalizedHRV = (50-20)/50 = 0.6, hrvComponent = pow(0.6, 0.8) ≈ 0.66
        // normalizedHR = (90-60)/60 = 0.5, hrComponent = atan(1) / (π/2) ≈ 0.64
        // stress = (0.66 * 0.7 + 0.64 * 0.3) * 100 ≈ 65
        XCTAssertEqual(result.level, 65, accuracy: 5, "Severe stress indicators should result in high stress level")
        XCTAssertEqual(result.category, .moderate, "Should be categorized as moderate stress (65)")
    }

    // MARK: - Category Boundary Tests
    func testCategoryBoundary_RelaxedToMild() async throws {
        // Test the boundary between relaxed (0-25) and mild (25-50)

        // Just below 25 - should be relaxed
        let result1 = try await sut.calculateStress(hrv: 40.0, heartRate: 70.0)
        if result1.level < 25 {
            XCTAssertEqual(result1.category, .relaxed, "Level below 25 should be relaxed")
        }

        // Just above 25 - should be mild
        let result2 = try await sut.calculateStress(hrv: 35.0, heartRate: 85.0)
        if result2.level >= 25 && result2.level < 50 {
            XCTAssertEqual(result2.category, .mild, "Level 25-50 should be mild")
        }
    }

    func testCategoryBoundary_MildToModerate() async throws {
        // Test the boundary between mild (25-50) and moderate (50-75)

        // HRV low enough to push into moderate
        let result = try await sut.calculateStress(hrv: 22.0, heartRate: 80.0)
        if result.level >= 50 && result.level < 75 {
            XCTAssertEqual(result.category, .moderate, "Level 50-75 should be moderate")
        }
    }

    func testCategoryBoundary_ModerateToHigh() async throws {
        // Test the boundary between moderate (50-75) and high (75-100)

        // Very low HRV and high heart rate
        let result = try await sut.calculateStress(hrv: 15.0, heartRate: 110.0)
        if result.level >= 75 {
            XCTAssertEqual(result.category, .high, "Level 75+ should be high stress")
        }
    }

    // MARK: - Edge Cases
    func testZeroHRV() async throws {
        // Given: Edge case with zero HRV
        let hrv = 0.0
        let heartRate = 60.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: Should handle gracefully with high stress (70% max from HRV)
        // normalizedHRV = (50-0)/50 = 1, hrvComponent = 1, stress = 1 * 0.7 * 100 = 70
        XCTAssertEqual(result.level, 70, accuracy: 5, "Zero HRV with normal HR should result in 70 stress")
        XCTAssertEqual(result.category, .moderate, "Level 70 falls in moderate range (50-75)")
    }

    func testZeroHeartRate() async throws {
        // Given: Edge case with zero heart rate (physiologically impossible)
        let hrv = 50.0
        let heartRate = 0.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: Should handle gracefully
        XCTAssertGreaterThanOrEqual(result.level, 0, "Stress level should be non-negative")
        XCTAssertLessThanOrEqual(result.level, 100, "Stress level should not exceed 100")
    }

    func testExtremeValues() async throws {
        // Given: Extremely high heart rate
        let hrv = 50.0
        let heartRate = 200.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: atan function asymptotes, so won't reach 100 but should be moderate
        // normalizedHRV = 0, hrvComponent = 0
        // normalizedHR = (200-60)/60 = 2.33
        // hrComponent = atan(2.33*2) / (π/2) ≈ 0.87
        // stress = 0.87 * 0.3 * 100 ≈ 26
        XCTAssertEqual(result.level, 26, accuracy: 5, "Extreme heart rate should result in mild stress")
        XCTAssertEqual(result.category, .mild, "Should be categorized as mild stress (26)")
    }

    func testNegativeValues() async throws {
        // Given: Negative HRV (physiologically impossible)
        let hrv = -10.0
        let heartRate = 60.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: Should handle gracefully
        XCTAssertGreaterThanOrEqual(result.level, 0, "Stress level should be non-negative")
        XCTAssertLessThanOrEqual(result.level, 100, "Stress level should not exceed 100")
    }

    // MARK: - Confidence Scoring Tests
    func testConfidence_NormalReading() async throws {
        // Given: Normal physiological values
        let hrv = 50.0
        let heartRate = 60.0
        let samples = 10

        // When: Calculating confidence
        let confidence = sut.calculateConfidence(hrv: hrv, heartRate: heartRate, samples: samples)

        // Then: Should have high confidence
        XCTAssertEqual(confidence, 1.0, accuracy: 0.1, "Normal readings should have high confidence")
    }

    func testConfidence_LowHRV() async throws {
        // Given: Low HRV (< 20ms)
        let hrv = 15.0
        let heartRate = 60.0
        let samples = 10

        // When: Calculating confidence
        let confidence = sut.calculateConfidence(hrv: hrv, heartRate: heartRate, samples: samples)

        // Then: Should have reduced confidence
        XCTAssertEqual(confidence, 0.5, accuracy: 0.1, "Low HRV should reduce confidence by 50%")
    }

    func testConfidence_LowHeartRate() async throws {
        // Given: Very low heart rate (< 40 bpm)
        let hrv = 50.0
        let heartRate = 35.0
        let samples = 10

        // When: Calculating confidence
        let confidence = sut.calculateConfidence(hrv: hrv, heartRate: heartRate, samples: samples)

        // Then: Should have reduced confidence
        XCTAssertEqual(confidence, 0.6, accuracy: 0.1, "Extreme heart rate should reduce confidence")
    }

    func testConfidence_HighHeartRate() async throws {
        // Given: Very high heart rate (> 180 bpm)
        let hrv = 50.0
        let heartRate = 190.0
        let samples = 10

        // When: Calculating confidence
        let confidence = sut.calculateConfidence(hrv: hrv, heartRate: heartRate, samples: samples)

        // Then: Should have reduced confidence
        XCTAssertEqual(confidence, 0.6, accuracy: 0.1, "Extreme heart rate should reduce confidence")
    }

    func testConfidence_SampleCount() async throws {
        // Given: Different sample counts

        // When: Calculating confidence with few samples
        let confidenceLow = sut.calculateConfidence(hrv: 50.0, heartRate: 60.0, samples: 1)

        // When: Calculating confidence with many samples
        let confidenceHigh = sut.calculateConfidence(hrv: 50.0, heartRate: 60.0, samples: 20)

        // Then: More samples should increase confidence
        XCTAssertLessThan(confidenceLow, confidenceHigh, "More samples should increase confidence")
        XCTAssertGreaterThanOrEqual(confidenceLow, 0.7, "Minimum confidence should be 70% with normal readings")
        XCTAssertEqual(confidenceHigh, 1.0, accuracy: 0.01, "10+ samples should give maximum confidence")
    }

    func testConfidence_MultipleReductions() async throws {
        // Given: Low HRV AND extreme heart rate
        let hrv = 15.0
        let heartRate = 35.0
        let samples = 1

        // When: Calculating confidence
        let confidence = sut.calculateConfidence(hrv: hrv, heartRate: heartRate, samples: samples)

        // Then: Should have significantly reduced confidence
        // Expected: 1.0 * 0.5 (low HRV) * 0.6 (extreme HR) * 0.7 (low samples) = 0.21
        XCTAssertEqual(confidence, 0.21, accuracy: 0.05, "Multiple factors should compound confidence reduction")
    }

    // MARK: - Algorithm Component Tests
    func testHRVComponentWeight() async throws {
        // Given: Low HRV with normal heart rate
        let hrv = 25.0
        let heartRate = 60.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: HRV should dominate (70% weight)
        // HRV alone would give significant stress
        XCTAssertGreaterThan(result.level, 30, "HRV component should drive stress level")
    }

    func testHRComponentWeight() async throws {
        // Given: Normal HRV with elevated heart rate
        let hrv = 50.0
        let heartRate = 100.0

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: hrv, heartRate: heartRate)

        // Then: HR should contribute (30% weight) but HRV should moderate
        // Same calculation as testHighStressElevatedHeartRate
        XCTAssertEqual(result.level, 17.7, accuracy: 2, "HR component should contribute to stress")
        XCTAssertEqual(result.category, .relaxed, "Normal HRV keeps stress in relaxed range")
    }

    // MARK: - Baseline Customization Tests
    func testCustomBaseline() async throws {
        // Given: Custom baseline (athlete with low resting HR and high baseline HRV)
        let athleteBaseline = PersonalBaseline(restingHeartRate: 45.0, baselineHRV: 70.0)
        let customCalculator = StressCalculator(baseline: athleteBaseline)

        // When: Calculating stress with athlete's baseline
        let result = try await customCalculator.calculateStress(hrv: 70.0, heartRate: 45.0)

        // Then: Should be relaxed for athlete
        XCTAssertEqual(result.level, 0, accuracy: 10, "Athlete's normal readings should be relaxed")
        XCTAssertEqual(result.category, .relaxed, "Athlete should be categorized as relaxed")
    }

    // MARK: - Timestamp Tests
    func testTimestamp() async throws {
        // Given: Current time before calculation
        let beforeDate = Date()

        // When: Calculating stress
        let result = try await sut.calculateStress(hrv: 50.0, heartRate: 60.0)

        // Then: Timestamp should be current
        let afterDate = Date()
        XCTAssertGreaterThanOrEqual(result.timestamp, beforeDate, "Timestamp should be after start")
        XCTAssertLessThanOrEqual(result.timestamp, afterDate, "Timestamp should be before end")
    }

    // MARK: - Thread Safety Tests
    func testConcurrentCalculations() async throws {
        // Given: Multiple concurrent calculations
        let expectations = (1...10).map { _ in
            Task {
                try await sut.calculateStress(hrv: Double.random(in: 20...80), heartRate: Double.random(in: 50...120))
            }
        }

        // When: Waiting for all to complete
        var results: [StressResult] = []
        for expectation in expectations {
            let result = try await expectation.value
            results.append(result)
        }

        // Then: All should succeed
        XCTAssertEqual(results.count, 10, "All concurrent calculations should complete")
        for result in results {
            XCTAssertGreaterThanOrEqual(result.level, 0, "Stress should be non-negative")
            XCTAssertLessThanOrEqual(result.level, 100, "Stress should not exceed 100")
        }
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/StressMonitorTests.swift">
import Foundation
import Testing
@testable import StressMonitor

struct StressMonitorTests {

    @Test func testObservableModel_setError() {
        let model = ObservableModel()
        model.setError("Test error")
        #expect(model.errorMessage == "Test error")
    }

    @Test func testObservableModel_clearError() {
        let model = ObservableModel()
        model.setError("Test error")
        model.clearError()
        #expect(model.errorMessage == nil)
    }

    @Test func testObservableModel_initialState() {
        let model = ObservableModel()
        #expect(model.isLoading == false)
        #expect(model.errorMessage == nil)
    }

    @Test func testHRVMeasurement_init() {
        let hrv = HRVMeasurement(value: 50.0)
        #expect(hrv.value == 50.0)
        #expect(hrv.unit == "ms")
        #expect(hrv.id != UUID())
    }

    @Test func testHRVMeasurement_codable() throws {
        let hrv = HRVMeasurement(value: 45.5, timestamp: Date(timeIntervalSince1970: 1000))
        let data = try JSONEncoder().encode(hrv)
        let decoded = try JSONDecoder().decode(HRVMeasurement.self, from: data)
        #expect(decoded.value == hrv.value)
        #expect(decoded.unit == hrv.unit)
    }

    @Test func testHeartRateSample_init() {
        let hr = HeartRateSample(value: 72.0)
        #expect(hr.value == 72.0)
        #expect(hr.id != UUID())
    }

    @Test func testHeartRateSample_codable() throws {
        let hr = HeartRateSample(value: 80.0, timestamp: Date(timeIntervalSince1970: 2000))
        let data = try JSONEncoder().encode(hr)
        let decoded = try JSONDecoder().decode(HeartRateSample.self, from: data)
        #expect(decoded.value == hr.value)
    }
}
</file>

<file path="StressMonitor/StressMonitorTests/StressRepositoryTests.swift">
import SwiftData
import XCTest

@testable import StressMonitor

@MainActor
final class StressRepositoryTests: XCTestCase {

  var container: ModelContainer!
  var repository: StressRepository!
  var modelContext: ModelContext!

  override func setUp() async throws {
    let schema = Schema([StressMeasurement.self])
    let configuration = ModelConfiguration(isStoredInMemoryOnly: true)
    container = try ModelContainer(for: schema, configurations: [configuration])
    modelContext = ModelContext(container)
    repository = StressRepository(modelContext: modelContext)
  }

  override func tearDown() async throws {
    container = nil
    repository = nil
    modelContext = nil
  }

  // MARK: - save Tests

  func testSaveMeasurement() async throws {
    let measurement = StressMeasurement(
      timestamp: Date(),
      stressLevel: 45,
      hrv: 50,
      restingHeartRate: 70,
    )

    try await repository.save(measurement)

    let fetched = try await repository.fetchRecent(limit: 1)
    XCTAssertEqual(fetched.count, 1)
    XCTAssertEqual(fetched.first?.stressLevel, 45)
  }

  // MARK: - fetchRecent Tests

  func testFetchRecentReturnsEmpty() async throws {
    let fetched = try await repository.fetchRecent(limit: 5)
    XCTAssertEqual(fetched.count, 0)
  }

  func testFetchRecentWithLimit() async throws {
    for i in 0..<10 {
      let measurement = StressMeasurement(
        timestamp: Date().addingTimeInterval(Double(i) * 60),
        stressLevel: Double(i * 10),
        hrv: 50,
        restingHeartRate: 70,
      )
      try await repository.save(measurement)
    }

    let fetched = try await repository.fetchRecent(limit: 5)
    XCTAssertEqual(fetched.count, 5)
  }

  func testFetchRecentOrdersByTimestampDescending() async throws {
    let dates = [
      Date().addingTimeInterval(-300),
      Date().addingTimeInterval(-100),
      Date(),
    ]

    for (index, date) in dates.enumerated() {
      let measurement = StressMeasurement(
        timestamp: date,
        stressLevel: Double(index * 10),
        hrv: 50,
        restingHeartRate: 70,
      )
      try await repository.save(measurement)
    }

    let fetched = try await repository.fetchRecent(limit: 3)

    XCTAssertEqual(fetched[0].timestamp, dates[2])
    XCTAssertEqual(fetched[1].timestamp, dates[1])
    XCTAssertEqual(fetched[2].timestamp, dates[0])
  }

  // MARK: - fetchAll Tests

  func testFetchAll() async throws {
    for i in 0..<5 {
      let measurement = StressMeasurement(
        timestamp: Date(),
        stressLevel: Double(i * 10),
        hrv: 50,
        restingHeartRate: 70,
      )
      try await repository.save(measurement)
    }

    let fetched = try await repository.fetchAll()
    XCTAssertEqual(fetched.count, 5)
  }

  // MARK: - deleteOlderThan Tests

  func testDeleteOlderThan() async throws {
    let now = Date()

    let oldMeasurement = StressMeasurement(
      timestamp: now.addingTimeInterval(-86400 * 10),
      stressLevel: 30,
      hrv: 50,
      restingHeartRate: 70,
    )

    let newMeasurement = StressMeasurement(
      timestamp: now.addingTimeInterval(-86400),
      stressLevel: 60,
      hrv: 50,
      restingHeartRate: 70,
    )

    try await repository.save(oldMeasurement)
    try await repository.save(newMeasurement)

    try await repository.deleteOlderThan(now.addingTimeInterval(-86400 * 5))

    let remaining = try await repository.fetchAll()
    XCTAssertEqual(remaining.count, 1)
    XCTAssertEqual(remaining.first?.stressLevel, 60)
  }

  // MARK: - getBaseline Tests

  func testGetBaselineWithNoData() async throws {
    let baseline = try await repository.getBaseline()

    XCTAssertEqual(baseline.baselineHRV, 50)
    XCTAssertEqual(baseline.restingHeartRate, 60)
  }

  func testGetBaselineCachesResult() async throws {
    let baseline1 = try await repository.getBaseline()
    let baseline2 = try await repository.getBaseline()

    XCTAssertTrue(baseline1.lastUpdated == baseline2.lastUpdated)
  }

  func testUpdateBaseline() async throws {
    let newBaseline = PersonalBaseline(
      restingHeartRate: 55,
      baselineHRV: 45,
      lastUpdated: Date()
    )

    try await repository.updateBaseline(newBaseline)

    let fetched = try await repository.getBaseline()

    XCTAssertEqual(fetched.restingHeartRate, 55)
    XCTAssertEqual(fetched.baselineHRV, 45)
  }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/WatchConnectivityManager.swift">
import Combine
import Foundation
import WatchConnectivity

final class WatchConnectivityManager: NSObject, ObservableObject {
  static let shared = WatchConnectivityManager()

  @Published var isReachable = false

  private override init() {
    super.init()
    if WCSession.isSupported() {
      WCSession.default.delegate = self
      WCSession.default.activate()
    }
  }

  func syncData(_ data: [String: Any]) {
    guard WCSession.default.isReachable else {
      return
    }

    WCSession.default.transferUserInfo(data)
  }

  func requestData(_ action: String) async -> [String: Any] {
    guard WCSession.default.isReachable else {
      return [:]
    }

    return await withCheckedContinuation { continuation in
      WCSession.default.sendMessage(
        ["action": action],
        replyHandler: { reply in
          continuation.resume(returning: reply)
        },
        errorHandler: { _ in
          continuation.resume(returning: [:])
        }
      )
    }
  }
}

extension WatchConnectivityManager: WCSessionDelegate {
  // MARK: - Required WCSessionDelegate methods for watchOS
  
  func session(
    _ session: WCSession, 
    activationDidCompleteWith activationState: WCSessionActivationState,
    error: Error?
  ) {
    DispatchQueue.main.async {
      self.isReachable = session.isReachable
    }
  }

  func sessionReachabilityDidChange(_ session: WCSession) {
    DispatchQueue.main.async {
      self.isReachable = session.isReachable
    }
  }

  // MARK: - Message handling

  func session(_ session: WCSession, didReceiveMessage message: [String: Any]) {
    // Handle incoming messages from iPhone
    // Can be extended to process specific message types
  }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Services/WatchHealthKitManager.swift">
import Foundation
import HealthKit

final class WatchHealthKitManager: HealthKitServiceProtocol {
  private let healthStore = HKHealthStore()

  private let hrvType = HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!
  private let heartRateType = HKObjectType.quantityType(forIdentifier: .heartRate)!

  func requestAuthorization() async throws {
    guard HKHealthStore.isHealthDataAvailable() else {
      throw HealthKitError.notAvailable
    }

    let typesToRead: Set<HKSampleType> = [hrvType, heartRateType]

    try await healthStore.requestAuthorization(toShare: [], read: typesToRead)
  }

  func fetchLatestHRV() async throws -> HRVMeasurement? {
    let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)
    let query = HKSampleQuery(
      sampleType: hrvType,
      predicate: nil,
      limit: 1,
      sortDescriptors: [sortDescriptor]
    ) { [weak self] _, samples, _ in
      guard let self = self,
        let sample = samples?.first as? HKQuantitySample
      else {
        return
      }

      let value = sample.quantity.doubleValue(for: HKUnit.secondUnit(with: .milli))
      self.hrvResult = HRVMeasurement(value: value, timestamp: sample.endDate)
    }

    healthStore.execute(query)

    return await withCheckedContinuation { continuation in
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
        continuation.resume(returning: self.hrvResult)
      }
    }
  }

  func fetchHeartRate(samples: Int) async throws -> [HeartRateSample] {
    let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)
    let query = HKSampleQuery(
      sampleType: heartRateType,
      predicate: nil,
      limit: samples,
      sortDescriptors: [sortDescriptor]
    ) { [weak self] _, samples, _ in
      guard let self = self,
        let samples = samples as? [HKQuantitySample]
      else {
        return
      }

      let results = samples.map { sample in
        let value = sample.quantity.doubleValue(for: HKUnit.count().unitDivided(by: .minute()))
        return HeartRateSample(value: value, timestamp: sample.endDate)
      }

      self.heartRateResults = results
    }

    healthStore.execute(query)

    return await withCheckedContinuation { continuation in
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
        continuation.resume(returning: self.heartRateResults ?? [])
      }
    }
  }

  private var hrvResult: HRVMeasurement?
  private var heartRateResults: [HeartRateSample]?

  func fetchHRVHistory(since: Date) async throws -> [HRVMeasurement] {
    let predicate = HKQuery.predicateForSamples(withStart: since, end: nil, options: .strictStartDate)
    let sortDescriptor = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)
    let query = HKSampleQuery(
      sampleType: hrvType,
      predicate: predicate,
      limit: HKObjectQueryNoLimit,
      sortDescriptors: [sortDescriptor]
    ) { [weak self] _, samples, _ in
      guard let self = self,
        let samples = samples as? [HKQuantitySample]
      else {
        return
      }

      let results = samples.map { sample in
        let value = sample.quantity.doubleValue(for: HKUnit.secondUnit(with: .milli))
        return HRVMeasurement(value: value, timestamp: sample.endDate)
      }

      self.hrvHistoryResults = results
    }

    healthStore.execute(query)

    return await withCheckedContinuation { continuation in
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
        continuation.resume(returning: self.hrvHistoryResults ?? [])
      }
    }
  }

  func observeHeartRateUpdates() -> AsyncStream<HeartRateSample?> {
    AsyncStream { continuation in
      let query = HKObserverQuery(sampleType: heartRateType, predicate: nil) { _, _, _ in
        continuation.yield(nil)
      }
      self.healthStore.execute(query)
    }
  }

  private var hrvHistoryResults: [HRVMeasurement]?
}

enum HealthKitError: Error {
  case notAvailable
  case authorizationDenied
  case noData
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/ViewModels/WatchStressViewModel.swift">
import Foundation
import Observation
import WidgetKit

@Observable
final class WatchStressViewModel {
  var currentStress: StressResult?
  var isLoading = false
  var errorMessage: String?

  private let healthKit: WatchHealthKitManager
  private let algorithm: StressAlgorithmServiceProtocol
  private let connectivity: WatchConnectivityManager
  private let complicationProvider: ComplicationDataProvider

  init(
    healthKit: WatchHealthKitManager = WatchHealthKitManager(),
    algorithm: StressAlgorithmServiceProtocol = StressCalculator(),
    connectivity: WatchConnectivityManager = .shared,
    complicationProvider: ComplicationDataProvider = .shared
  ) {
    self.healthKit = healthKit
    self.algorithm = algorithm
    self.connectivity = connectivity
    self.complicationProvider = complicationProvider
  }

  func requestAuthorization() async {
    do {
      try await healthKit.requestAuthorization()
    } catch {
      errorMessage = "Authorization failed: \(error.localizedDescription)"
    }
  }

  func measureStress() async {
    isLoading = true
    errorMessage = nil

    do {
      async let hrv = healthKit.fetchLatestHRV()
      async let hr = healthKit.fetchHeartRate(samples: 10)

      let (hrvData, hrData) = try await (hrv, hr)

      guard let hrvValue = hrvData?.value,
        let heartRate = hrData.first?.value
      else {
        errorMessage = "No health data available"
        isLoading = false
        return
      }

      let result = try await algorithm.calculateStress(
        hrv: hrvValue,
        heartRate: heartRate
      )

      currentStress = result
      syncToPhone(result: result)
      syncToComplications(result: result)
    } catch {
      errorMessage = error.localizedDescription
    }

    isLoading = false
  }

  func loadLatestStress() async {
    isLoading = true

    let data = await connectivity.requestData("fetchLatest")

    if let level = data["stressLevel"] as? Double,
      let categoryRaw = data["category"] as? String,
      let category = StressCategory(rawValue: categoryRaw),
      let confidence = data["confidence"] as? Double,
      let hrv = data["hrv"] as? Double,
      let heartRate = data["heartRate"] as? Double,
      let timestamp = data["timestamp"] as? Date
    {
      currentStress = StressResult(
        level: level,
        category: category,
        confidence: confidence,
        hrv: hrv,
        heartRate: heartRate,
        timestamp: timestamp
      )
    }

    isLoading = false
  }

  private func syncToPhone(result: StressResult) {
    let data: [String: Any] = [
      "stressLevel": result.level,
      "category": result.category.rawValue,
      "confidence": result.confidence,
      "hrv": result.hrv,
      "heartRate": result.heartRate,
      "timestamp": result.timestamp,
    ]

    connectivity.syncData(data)
  }

  private func syncToComplications(result: StressResult) {
    complicationProvider.saveMeasurement(result)
  }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/StressMonitorWatchApp.swift">
import SwiftUI

@main
struct StressMonitorWatch_Watch_AppApp: App {
  var body: some Scene {
    WindowGroup {
      ContentView()
    }
  }

  init() {
    _ = WatchConnectivityManager.shared
  }
}
</file>

<file path="StressMonitor/StressMonitor/Models/StressMeasurement.swift">
import Foundation
import SwiftData
import SwiftUI

@Model
public final class StressMeasurement {
  public var timestamp: Date
  public var stressLevel: Double
  public var hrv: Double
  public var restingHeartRate: Double
  public var categoryRawValue: String
  public var confidences: [Double]?

  // MARK: - CloudKit Sync Properties
  public var isSynced: Bool
  public var cloudKitRecordName: String?
  public var deviceID: String
  public var cloudKitModTime: Date?

  public init(
    timestamp: Date,
    stressLevel: Double,
    hrv: Double,
    restingHeartRate: Double,
    confidences: [Double]? = nil,
    isSynced: Bool = false,
    cloudKitRecordName: String? = nil,
    deviceID: String = CloudKitDeviceID.current,
    cloudKitModTime: Date? = nil
  ) {
    self.timestamp = timestamp
    self.stressLevel = stressLevel
    self.hrv = hrv
    self.restingHeartRate = restingHeartRate
    self.categoryRawValue = StressResult.category(for: stressLevel).rawValue
    self.confidences = confidences
    self.isSynced = isSynced
    self.cloudKitRecordName = cloudKitRecordName
    self.deviceID = deviceID
    self.cloudKitModTime = cloudKitModTime
  }

  public var category: StressCategory {
    get { StressCategory(rawValue: categoryRawValue) ?? .mild }
    set { categoryRawValue = newValue.rawValue }
  }
}

// MARK: - CloudKit Device ID Helper

public enum CloudKitDeviceID {
  private static let key = "com.stressmonitor.deviceID"

  public static var current: String {
    if let existingID = UserDefaults.standard.string(forKey: key) {
      return existingID
    }

    let newID = UUID().uuidString
    UserDefaults.standard.set(newID, forKey: key)
    return newID
  }
}
</file>

<file path="StressMonitor/StressMonitor/Services/Protocols/StressRepositoryProtocol.swift">
import Foundation

@preconcurrency import SwiftData

protocol StressRepositoryProtocol: Sendable {
    func save(_ measurement: StressMeasurement) async throws
    func fetchRecent(limit: Int) async throws -> [StressMeasurement]
    func fetchAll() async throws -> [StressMeasurement]
    func deleteOlderThan(_ date: Date) async throws
    func getBaseline() async throws -> PersonalBaseline
    func updateBaseline(_ baseline: PersonalBaseline) async throws
    func fetchMeasurements(from: Date, to: Date) async throws -> [StressMeasurement]
    func delete(_ measurement: StressMeasurement) async throws
    func fetchAverageHRV(hours: Int) async throws -> Double
    func fetchAverageHRV(days: Int) async throws -> Double
    func deleteAllMeasurements() async throws
}
</file>

<file path="StressMonitor/StressMonitor/ViewModels/StressViewModel.swift">
import Foundation
import Observation
import HealthKit

@Observable
@MainActor
final class StressViewModel {

    var currentStress: StressResult?
    var historicalData: [StressMeasurement] = []
    var baseline: PersonalBaseline?
    var liveHeartRate: Double?
    var isLoading = false
    var errorMessage: String?
    var lastRefresh: Date?

    // MARK: - New Properties for Dashboard Enhancement

    /// Last 7 HRV readings for mini chart
    var hrvHistory: [Double] = []
    /// Heart rate trend direction
    var heartRateTrend: TrendDirection = .stable
    /// Today's measurements for timeline
    var todayMeasurements: [StressMeasurement] = []
    /// Current week average stress
    var weeklyCurrentAvg: Double = 0
    /// Previous week average stress
    var weeklyPreviousAvg: Double = 0
    /// AI-generated insight
    var aiInsight: AIInsight?

    // MARK: - Auto-Refresh Properties

    /// Last refresh time for debounce
    private var lastRefreshTime: Date?
    /// Minimum interval between refreshes (60 seconds)
    private let refreshInterval: TimeInterval = 60
    /// HealthKit observer query for HRV
    private var observerQuery: HKObserverQuery?
    /// HealthStore instance
    private let healthStore = HKHealthStore()

    // MARK: - Trend Direction

    enum TrendDirection {
        case up, down, stable
    }

    private let healthKit: HealthKitServiceProtocol
    private let algorithm: StressAlgorithmServiceProtocol
    private let repository: StressRepositoryProtocol

    /// Stored Task for heart rate observation cancellation
    private var heartRateTask: Task<Void, Never>?

    init(
        healthKit: HealthKitServiceProtocol,
        algorithm: StressAlgorithmServiceProtocol,
        repository: StressRepositoryProtocol
    ) {
        self.healthKit = healthKit
        self.algorithm = algorithm
        self.repository = repository
    }

    func loadCurrentStress() async {
        isLoading = true
        defer { isLoading = false }

        do {
            async let hrv = healthKit.fetchLatestHRV()
            async let hr = healthKit.fetchHeartRate(samples: 1)

            let (hrvData, hrData) = try await (hrv, hr)

            guard let hrvValue = hrvData?.value else {
                errorMessage = "No HRV data available"
                return
            }

            let heartRateValue = hrData.first?.value ?? 70

            let result = try await algorithm.calculateStress(hrv: hrvValue, heartRate: heartRateValue)
            currentStress = result
            lastRefresh = Date()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func loadHistoricalData(days: Int) async {
        isLoading = true
        defer { isLoading = false }

        do {
            historicalData = try await repository.fetchRecent(limit: days * 24)
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func loadBaseline() async {
        isLoading = true
        defer { isLoading = false }

        do {
            baseline = try await repository.getBaseline()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func refreshHealthData() async {
        await loadCurrentStress()
    }

    func observeHeartRate() {
        heartRateTask = Task {
            for await sample in healthKit.observeHeartRateUpdates() {
                liveHeartRate = sample?.value
            }
        }
    }

    func calculateAndSaveStress() async throws {
        async let hrv = healthKit.fetchLatestHRV()
        async let hr = healthKit.fetchHeartRate(samples: 1)

        let (hrvData, hrData) = try await (hrv, hr)

        guard let hrvValue = hrvData?.value else {
            throw StressError.noData
        }

        let heartRateValue = hrData.first?.value ?? 70
        let result = try await algorithm.calculateStress(hrv: hrvValue, heartRate: heartRateValue)

        let measurement = StressMeasurement(
            timestamp: result.timestamp,
            stressLevel: result.level,
            hrv: result.hrv,
            restingHeartRate: result.heartRate,
            confidences: [result.confidence]
        )

        try await repository.save(measurement)
        currentStress = result
        lastRefresh = Date()
    }

    func clearError() {
        errorMessage = nil
    }

    // MARK: - Dashboard Data Loading

    /// Load all dashboard data in one call
    func loadDashboardData() async {
        await loadCurrentStress()
        await loadHistoricalData(days: 14)
        loadTodayMeasurements()
        loadWeeklyComparison()
        generateInsight()
    }

    /// Load today's measurements for timeline view
    func loadTodayMeasurements() {
        let calendar = Calendar.current
        let startOfDay = calendar.startOfDay(for: Date())
        todayMeasurements = historicalData.filter { $0.timestamp >= startOfDay }
        hrvHistory = Array(todayMeasurements.map { $0.hrv }.suffix(7))
    }

    /// Calculate current vs previous week averages
    func loadWeeklyComparison() {
        let calendar = Calendar.current
        let now = Date()

        guard let weekStart = calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: now)),
              let prevWeekStart = calendar.date(byAdding: .weekOfYear, value: -1, to: weekStart) else {
            weeklyCurrentAvg = 0
            weeklyPreviousAvg = 0
            return
        }

        let currentWeek = historicalData.filter { $0.timestamp >= weekStart }
        let prevWeek = historicalData.filter { $0.timestamp >= prevWeekStart && $0.timestamp < weekStart }

        weeklyCurrentAvg = currentWeek.isEmpty ? 0 : currentWeek.map(\.stressLevel).reduce(0, +) / Double(currentWeek.count)
        weeklyPreviousAvg = prevWeek.isEmpty ? 0 : prevWeek.map(\.stressLevel).reduce(0, +) / Double(prevWeek.count)
    }

    /// Generate AI insight from current stress and history
    func generateInsight() {
        guard let stress = currentStress else {
            aiInsight = nil
            return
        }
        aiInsight = InsightGenerator.generate(from: stress, history: historicalData)
    }

    // MARK: - Auto-Refresh with HKObserverQuery

    /// Check if enough time has passed for a refresh
    private var canRefresh: Bool {
        guard let last = lastRefreshTime else { return true }
        return Date().timeIntervalSince(last) >= refreshInterval
    }

    /// Start auto-refresh via HealthKit observer
    func startAutoRefresh() {
        let hrvType = HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!

        let query = HKObserverQuery(sampleType: hrvType, predicate: nil) { [weak self] _, completionHandler, error in
            guard let self else {
                completionHandler()
                return
            }

            if let error = error {
                Task { @MainActor [weak self] in
                    self?.errorMessage = "HealthKit observer error: \(error.localizedDescription)"
                }
                completionHandler()
                return
            }

            Task { @MainActor [weak self] in
                self?.handleHealthKitUpdate()
            }

            completionHandler()
        }

        healthStore.execute(query)
        observerQuery = query
    }

    /// Stop auto-refresh observer
    func stopAutoRefresh() {
        // Cancel HKObserverQuery
        if let query = observerQuery {
            healthStore.stop(query)
            observerQuery = nil
        }
        // Cancel heart rate observation Task
        heartRateTask?.cancel()
        heartRateTask = nil
    }

    /// Handle HealthKit update with debounce
    private func handleHealthKitUpdate() {
        guard canRefresh else { return }

        let previousCategory = currentStress?.category

        Task {
            await loadCurrentStress()
            loadTodayMeasurements()
            generateInsight()

            // Haptic feedback on category change
            if let newCategory = currentStress?.category,
               newCategory != previousCategory {
                HapticManager.shared.stressLevelChanged(to: newCategory)
            }

            lastRefreshTime = Date()
        }
    }
}

enum StressError: Error {
    case noData
}
</file>

<file path="StressMonitor/StressMonitor/Views/Dashboard/StressDashboardView.swift">
import SwiftUI
import SwiftData

struct StressDashboardView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: DashboardViewModel?
    @State private var showingBreathing = false

    var body: some View {
        ZStack {
            Color.backgroundLight
                .ignoresSafeArea()

            Group {
                if let viewModel = viewModel {
                    contentView(viewModel: viewModel)
                } else {
                    ProgressView("Loading...")
                }
            }
        }
        .task {
            await setupViewModel()
        }
        .sheet(isPresented: $showingBreathing) {
            breathingPlaceholder
        }
    }

    private func setupViewModel() async {
        let repository = StressRepository(modelContext: modelContext)
        let healthKit = HealthKitManager()
        let algorithm = StressCalculator()

        viewModel = DashboardViewModel(
            healthKit: healthKit,
            algorithm: algorithm,
            repository: repository
        )

        await viewModel?.refreshStressLevel()
    }

    private func contentView(viewModel: DashboardViewModel) -> some View {
        ZStack {
            ScrollView {
                VStack(spacing: 20) {
                    header
                        .padding(.horizontal)
                        .padding(.top, 16)

                    // Stress Character Card (Phase 2)
                    if let stress = viewModel.currentStress {
                        StressCharacterCard(
                            result: stress,
                            size: .dashboard
                        )
                        .padding(.horizontal)
                    }

                    quickStatsRow
                        .padding(.horizontal)

                    // Breathing Exercise CTA (Phase 4)
                    BreathingExerciseCTA {
                        showingBreathing = true
                    }
                    .padding(.horizontal)

                    if let insight = viewModel.aiInsight {
                        AIInsightCard(insight: insight) {
                            showingBreathing = true
                        }
                        .padding(.horizontal)
                    }

                    Spacer()
                        .frame(height: 80)
                }
            }
            .refreshable {
                await viewModel.refreshStressLevel()
            }

            floatingButton(viewModel: viewModel)
        }
        .alert("Error", isPresented: .constant(viewModel.errorMessage != nil)) {
            Button("OK") { viewModel.errorMessage = nil }
        } message: {
            if let error = viewModel.errorMessage {
                Text(error)
            }
        }
    }

    private var header: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(formatDate(Date()))
                    .font(.caption)
                    .foregroundColor(.secondary)

                Text(greetingText())
                    .font(.largeTitle)
                    .fontWeight(.bold)

                if let viewModel = viewModel, let stress = viewModel.currentStress {
                    Text("Your stress is \(stress.category.rawValue) today")
                        .font(.body)
                        .foregroundColor(.secondary)
                }
            }

            Spacer()

            Button(action: {}) {
                Image(systemName: "person.circle.fill")
                    .font(.title)
                    .foregroundColor(.secondary)
            }
            .frame(width: DesignTokens.Layout.minTouchTarget, height: DesignTokens.Layout.minTouchTarget)
        }
    }

    private var stressRingSection: some View {
        VStack(spacing: 16) {
            if let viewModel = viewModel {
                StressRingView(
                    stressLevel: viewModel.currentStress?.level ?? 0,
                    category: viewModel.stressCategory
                )

                HStack(spacing: 8) {
                    Image(systemName: viewModel.stressCategory.icon)
                        .font(.title3)

                    Text(viewModel.stressCategory.rawValue.capitalized)
                        .font(.headline)
                }
                .foregroundColor(Color.stressColor(for: viewModel.stressCategory))
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(Color.stressColor(for: viewModel.stressCategory).opacity(0.15))
                .cornerRadius(20)

                if let confidence = viewModel.currentStress?.confidence {
                    HStack(spacing: 16) {
                        Label("\(Int(confidence * 100))% confident", systemImage: "checkmark.circle.fill")
                            .font(.caption)
                            .foregroundColor(.secondary)

                        if let updated = viewModel.lastUpdated {
                            Label("Updated \(relativeTime(updated))", systemImage: "clock")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
        }
    }

    private var quickStatsRow: some View {
        HStack(spacing: 12) {
            QuickStatCard(
                icon: "heart.fill",
                value: "\(Int(viewModel?.todayHRV ?? 0))",
                unit: "ms",
                label: "Today's HRV",
                tintColor: .red
            )

            QuickStatCard(
                icon: "chart.xyaxis.lines",
                value: trendIcon,
                unit: "",
                label: "7-Day",
                tintColor: .stressRelaxed
            )

            QuickStatCard(
                icon: "scale.3d",
                value: formatBaselineRange(viewModel?.baseline),
                unit: "",
                label: "Baseline",
                tintColor: .primaryBlue
            )
        }
    }

    private func floatingButton(viewModel: DashboardViewModel) -> some View {
        VStack {
            Spacer()

            Button(action: { Task { await viewModel.measureNow() } }) {
                HStack {
                    if viewModel.isMeasuring {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                            .padding(.leading, 8)
                    } else {
                        Image(systemName: "plus.circle.fill")
                            .font(.title3)
                    }

                    Text(viewModel.isMeasuring ? "Measuring..." : "Measure Now")
                        .font(.headline)
                }
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .frame(height: 52)
                .background(viewModel.isMeasuring ? Color.gray : Color.primaryBlue)
                .cornerRadius(26)
                .shadow(color: Color.black.opacity(0.1), radius: 8, y: 4)
            }
            .padding(.horizontal, 24)
            .padding(.bottom, 32)
        }
    }

    private var trendIcon: String {
        guard let trend = viewModel?.weeklyTrend else { return "→" }
        switch trend {
        case .up: return "↑"
        case .down: return "↓"
        case .stable: return "→"
        }
    }

    private func greetingText() -> String {
        let hour = Calendar.current.component(.hour, from: Date())

        switch hour {
        case 0..<12:
            return "Good Morning"
        case 12..<17:
            return "Good Afternoon"
        default:
            return "Good Evening"
        }
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE, MMM d"
        return formatter.string(from: date)
    }

    private func relativeTime(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }

    private func formatBaselineRange(_ baseline: PersonalBaseline?) -> String {
        guard let baseline = baseline else { return "--" }
        return "\(Int(baseline.baselineHRV))"
    }

    private var breathingPlaceholder: some View {
        BreathingExerciseView()
    }
}

#Preview {
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try! ModelContainer(for: StressMeasurement.self, configurations: config)
    return StressDashboardView()
        .modelContainer(container)
}
</file>

<file path="StressMonitor/StressMonitor/Views/HistoryView.swift">
import SwiftUI
import SwiftData

struct HistoryView: View {
    @Environment(\.modelContext) private var modelContext
    @Query(sort: \StressMeasurement.timestamp, order: .reverse) private var measurements: [StressMeasurement]
    @State private var appeared = false

    var body: some View {
        Group {
            if measurements.isEmpty {
                emptyState
            } else {
                listContent
            }
        }
        .navigationTitle("History")
        .accessibilityLabel("Stress measurement history")
        .refreshable {
            HapticManager.shared.success()
        }
        .accessibilityAction(named: "Refresh") {
            // Trigger refresh action
            HapticManager.shared.success()
        }
    }

    private var listContent: some View {
        List {
            ForEach(measurements) { measurement in
                HistoryRow(measurement: measurement)
                    .accessibilityElement(children: .combine)
            }
        }
        .listStyle(.insetGrouped)
        .accessibilityLabel("Stress measurements list")
        .accessibilityHint("\(measurements.count) measurements available")
    }

    private var emptyState: some View {
        ContentUnavailableView {
            Label("No history available", systemImage: "chart.bar.doc.horizontal")
        } description: {
            Text("Stress measurements will appear here once you start tracking.")
        }
    }
}

struct HistoryRow: View {
    let measurement: StressMeasurement

    var body: some View {
        HStack(spacing: DesignTokens.Spacing.md) {
            VStack(alignment: .leading, spacing: DesignTokens.Spacing.xs) {
                Text(formattedTime)
                    .font(.system(size: DesignTokens.Typography.body))
                    .foregroundColor(.primary)

                Text(measurement.category.rawValue.capitalized)
                    .font(.system(size: DesignTokens.Typography.caption))
                    .foregroundColor(.secondary)
            }

            Spacer()

            VStack(alignment: .trailing, spacing: DesignTokens.Spacing.xs) {
                HStack(spacing: DesignTokens.Spacing.xs) {
                    Image(systemName: measurement.category.icon)
                        .font(.system(size: 14))
                        .foregroundColor(Color.stressColor(for: measurement.category))
                        .accessibilityHidden(true)

                    Text("\(Int(measurement.stressLevel))")
                        .font(.system(size: DesignTokens.Typography.headline, weight: .semibold))
                        .foregroundColor(Color.stressColor(for: measurement.category))
                }

                Text("\(Int(measurement.hrv)) ms")
                    .font(.system(size: DesignTokens.Typography.caption))
                    .foregroundColor(.secondary)
            }
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Stress measurement from \(formattedTime)")
        .accessibilityValue("\(measurement.category.rawValue.capitalized) stress, level \(Int(measurement.stressLevel)) out of 100, with \(Int(measurement.hrv)) milliseconds heart rate variability")
        .accessibilityHint("Tap for detailed information about this measurement")
    }

    private var formattedTime: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: measurement.timestamp, relativeTo: Date())
    }
}

#Preview {
    NavigationStack {
        HistoryView()
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/Models/StressCategory.swift">
import SwiftUI

enum StressCategory: String, CaseIterable, Codable, Sendable {
    case relaxed
    case mild
    case moderate
    case high

    // MARK: - Dual Coding: Color

    /// Primary color for this stress category (WCAG AA compliant)
    var color: Color {
        switch self {
        case .relaxed:
            return Color(light: Color(hex: "#34C759"), dark: Color(hex: "#30D158"))
        case .mild:
            return Color(light: Color(hex: "#007AFF"), dark: Color(hex: "#0A84FF"))
        case .moderate:
            return Color(hex: "#FFD60A")
        case .high:
            return Color(light: Color(hex: "#FF9500"), dark: Color(hex: "#FF9F0A"))
        }
    }

    // MARK: - Dual Coding: Icon

    /// SF Symbol icon for this stress category
    var icon: String {
        switch self {
        case .relaxed: return "leaf.fill"
        case .mild: return "circle.fill"
        case .moderate: return "triangle.fill"
        case .high: return "square.fill"
        }
    }

    // MARK: - Dual Coding: Pattern Description

    /// Accessibility pattern description for color-blind users
    var pattern: String {
        switch self {
        case .relaxed: return "solid fill"
        case .mild: return "diagonal lines"
        case .moderate: return "dots pattern"
        case .high: return "crosshatch"
        }
    }

    // MARK: - Accessibility

    /// VoiceOver description combining all dual coding elements
    var accessibilityDescription: String {
        let name = rawValue.capitalized
        return "\(name) stress level, represented by \(icon) icon with \(pattern)"
    }

    /// Accessibility hint for interactive stress indicators
    var accessibilityHint: String {
        "Stress category indicator"
    }

    /// Accessibility value for stress level indicators
    /// - Parameter level: Stress level from 0-100
    func accessibilityValue(level: Double) -> String {
        let name = rawValue.capitalized
        return "\(Int(level)) out of 100, \(name) stress"
    }
}
</file>

<file path="StressMonitor/StressMonitorWatch Watch App/ContentView.swift">
import SwiftUI

struct ContentView: View {
  @State private var viewModel = WatchStressViewModel()

  var body: some View {
    NavigationStack {
      VStack(spacing: WatchDesignTokens.standardSpacing) {
        if let stress = viewModel.currentStress {
          CompactStressView(stressLevel: stress.level, category: stress.category)
        } else {
          CompactStressView(stressLevel: 0, category: .relaxed)
            .opacity(0.5)
        }

        Button(action: {
          Task {
            await viewModel.measureStress()
          }
        }) {
          HStack {
            if viewModel.isLoading {
              ProgressView()
                .progressViewStyle(.circular)
            } else {
              Image(systemName: "heart.fill")
              Text("Measure")
            }
          }
          .frame(maxWidth: .infinity)
          .frame(height: WatchDesignTokens.buttonHeight)
          .background(Color.blue)
          .foregroundStyle(.white)
          .cornerRadius(WatchDesignTokens.buttonCornerRadius)
        }
        .disabled(viewModel.isLoading)

        if let errorMessage = viewModel.errorMessage {
          Text(errorMessage)
            .font(.system(size: WatchDesignTokens.captionSize))
            .foregroundStyle(.red)
            .multilineTextAlignment(.center)
        }
      }
      .padding()
      .navigationTitle("Stress")
      .task {
        await viewModel.requestAuthorization()
        await viewModel.loadLatestStress()
      }
    }
  }
}

#Preview {
  ContentView()
}
</file>

<file path="StressMonitor/StressMonitor/Models/StressCategory.swift">
import SwiftUI

public enum StressCategory: String, CaseIterable, Codable, Sendable {
    case relaxed
    case mild
    case moderate
    case high

    // MARK: - Dual Coding: Color

    /// Primary color for this stress category (WCAG AA compliant)
    public var color: Color {
        switch self {
        case .relaxed:
            return Color(light: Color(hex: "#34C759"), dark: Color(hex: "#30D158"))
        case .mild:
            return Color(light: Color(hex: "#007AFF"), dark: Color(hex: "#0A84FF"))
        case .moderate:
            return Color(hex: "#FFD60A")
        case .high:
            return Color(light: Color(hex: "#FF9500"), dark: Color(hex: "#FF9F0A"))
        }
    }

    // MARK: - Dual Coding: Icon

    /// SF Symbol icon for this stress category
    public var icon: String {
        switch self {
        case .relaxed: return "leaf.fill"
        case .mild: return "circle.fill"
        case .moderate: return "triangle.fill"
        case .high: return "square.fill"
        }
    }

    // MARK: - Dual Coding: Pattern Description

    /// Accessibility pattern description for color-blind users
    public var pattern: String {
        switch self {
        case .relaxed: return "solid fill"
        case .mild: return "diagonal lines"
        case .moderate: return "dots pattern"
        case .high: return "crosshatch"
        }
    }

    // MARK: - Accessibility

    /// VoiceOver description combining all dual coding elements
    /// Note: displayName is defined in Badge.swift extension
    public var accessibilityDescription: String {
        let name = rawValue.capitalized
        return "\(name) stress level, represented by \(icon) icon with \(pattern)"
    }

    /// Accessibility hint for interactive stress indicators
    public var accessibilityHint: String {
        "Stress category indicator"
    }

    /// Accessibility value for stress level indicators
    /// - Parameter level: Stress level from 0-100
    public func accessibilityValue(level: Double) -> String {
        let name = rawValue.capitalized
        return "\(Int(level)) out of 100, \(name) stress"
    }
}
</file>

<file path="StressMonitor/StressMonitor/Services/Repository/StressRepository.swift">
import Foundation
import SwiftData
import CloudKit

@MainActor
final class StressRepository: StressRepositoryProtocol {

    // MARK: - Properties

    private let modelContext: ModelContext
    private nonisolated let baselineCalculator: BaselineCalculator
    private let cloudKitManager: CloudKitServiceProtocol?

    private var cachedBaseline: PersonalBaseline?

    // MARK: - Sync Status Callbacks

    public var onSyncStatusChange: ((SyncStatus) -> Void)?
    public var onSyncError: ((Error) -> Void)?

    // MARK: - Initialization

    init(
        modelContext: ModelContext,
        baselineCalculator: BaselineCalculator? = nil,
        cloudKitManager: CloudKitServiceProtocol? = nil
    ) {
        self.modelContext = modelContext
        self.baselineCalculator = baselineCalculator ?? BaselineCalculator()
        self.cloudKitManager = cloudKitManager

        // Note: Observation of CloudKit sync status is handled through
        // the onSyncStatusChange callback property set by the caller
    }

    // MARK: - Save Operations

    func save(_ measurement: StressMeasurement) async throws {
        // Offline-first: Always save locally first
        modelContext.insert(measurement)

        do {
            try modelContext.save()
        } catch {
            throw RepositoryError.saveFailed(error)
        }

        // Trigger CloudKit sync if available
        if let cloudKit = cloudKitManager {
            await syncMeasurementToCloudKit(measurement)
        }
    }

    func saveBatch(_ measurements: [StressMeasurement]) async throws {
        // Offline-first: Save all locally first
        for measurement in measurements {
            modelContext.insert(measurement)
        }

        do {
            try modelContext.save()
        } catch {
            throw RepositoryError.saveFailed(error)
        }

        // Trigger CloudKit sync if available
        if let cloudKit = cloudKitManager {
            await syncBatchToCloudKit(measurements)
        }
    }

    // MARK: - Fetch Operations

    func fetchRecent(limit: Int) async throws -> [StressMeasurement] {
        var descriptor = FetchDescriptor<StressMeasurement>(
            sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
        )
        descriptor.fetchLimit = limit

        do {
            return try modelContext.fetch(descriptor)
        } catch {
            return []
        }
    }

    func fetchAll() async throws -> [StressMeasurement] {
        let descriptor = FetchDescriptor<StressMeasurement>(
            sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
        )

        do {
            return try modelContext.fetch(descriptor)
        } catch {
            return []
        }
    }

    func fetchUnsyncedMeasurements() async throws -> [StressMeasurement] {
        let descriptor = FetchDescriptor<StressMeasurement>(
            predicate: #Predicate<StressMeasurement> { !$0.isSynced },
            sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
        )

        do {
            return try modelContext.fetch(descriptor)
        } catch {
            return []
        }
    }

    func fetchMeasurements(from: Date, to: Date) async throws -> [StressMeasurement] {
        let descriptor = FetchDescriptor<StressMeasurement>(
            predicate: #Predicate<StressMeasurement> { $0.timestamp >= from && $0.timestamp <= to },
            sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
        )

        do {
            return try modelContext.fetch(descriptor)
        } catch {
            return []
        }
    }

    // MARK: - Delete Operations

    func delete(_ measurement: StressMeasurement) async throws {
        // Mark for deletion and sync first
        measurement.isSynced = false

        do {
            try modelContext.save()
        } catch {
            throw RepositoryError.deleteFailed(error)
        }

        // Delete from CloudKit if available
        if let cloudKit = cloudKitManager {
            do {
                try await cloudKit.deleteMeasurement(measurement)
                measurement.cloudKitRecordName = nil
            } catch {
                onSyncError?(error)
                // Continue with local deletion even if CloudKit fails
            }
        }

        // Delete from local store
        modelContext.delete(measurement)

        do {
            try modelContext.save()
        } catch {
            throw RepositoryError.deleteFailed(error)
        }
    }

    func deleteOlderThan(_ date: Date) async throws {
        let descriptor = FetchDescriptor<StressMeasurement>(
            predicate: #Predicate<StressMeasurement> { $0.timestamp < date }
        )

        do {
            let oldMeasurements = try modelContext.fetch(descriptor)

            // Mark all for deletion first
            for measurement in oldMeasurements {
                measurement.isSynced = false
            }
            try modelContext.save()

            // Delete from CloudKit if available
            if let cloudKit = cloudKitManager {
                for measurement in oldMeasurements {
                    try? await cloudKit.deleteMeasurement(measurement)
                }
            }

            // Delete from local store
            for measurement in oldMeasurements {
                modelContext.delete(measurement)
            }
            try modelContext.save()
        } catch {
            throw RepositoryError.deleteFailed(error)
        }
    }

    func deleteAllMeasurements() async throws {
        let descriptor = FetchDescriptor<StressMeasurement>()
        let allMeasurements = try modelContext.fetch(descriptor)

        for measurement in allMeasurements {
            modelContext.delete(measurement)
        }
        try modelContext.save()
        cachedBaseline = nil
    }

    // MARK: - Baseline Operations

    func getBaseline() async throws -> PersonalBaseline {
        if let cached = cachedBaseline {
            return cached
        }

        let thirtyDaysAgo = Calendar.current.date(byAdding: .day, value: -30, to: Date())!
        let descriptor = FetchDescriptor<StressMeasurement>(
            predicate: #Predicate<StressMeasurement> { $0.timestamp >= thirtyDaysAgo }
        )

        let measurements = try modelContext.fetch(descriptor)

        let baseline: PersonalBaseline
        if measurements.isEmpty {
            baseline = PersonalBaseline()
        } else {
            let hrvMeasurements = measurements.map { HRVMeasurement(value: $0.hrv, timestamp: $0.timestamp) }
            baseline = try await baselineCalculator.calculateBaseline(from: hrvMeasurements)
        }

        cachedBaseline = baseline
        return baseline
    }

    func updateBaseline(_ baseline: PersonalBaseline) async throws {
        cachedBaseline = baseline
    }

    // MARK: - Statistics Operations

    func fetchAverageHRV(hours: Int) async throws -> Double {
        let startDate = Calendar.current.date(byAdding: .hour, value: -hours, to: Date()) ?? Date()
        let measurements = try await fetchMeasurements(from: startDate, to: Date())

        guard !measurements.isEmpty else { return 0 }
        return measurements.map { $0.hrv }.reduce(0, +) / Double(measurements.count)
    }

    func fetchAverageHRV(days: Int) async throws -> Double {
        let startDate = Calendar.current.date(byAdding: .day, value: -days, to: Date()) ?? Date()
        let measurements = try await fetchMeasurements(from: startDate, to: Date())

        guard !measurements.isEmpty else { return 0 }
        return measurements.map { $0.hrv }.reduce(0, +) / Double(measurements.count)
    }

    // MARK: - CloudKit Sync Operations

    /// Sync all pending measurements to CloudKit
    func syncPendingMeasurements() async throws {
        guard let cloudKit = cloudKitManager else {
            throw RepositoryError.cloudKitUnavailable
        }

        let unsynced = try await fetchUnsyncedMeasurements()

        guard !unsynced.isEmpty else { return }

        onSyncStatusChange?(.syncing(progress: 0.0))

        for (index, measurement) in unsynced.enumerated() {
            let progress = Double(index) / Double(unsynced.count)
            onSyncStatusChange?(.syncing(progress: progress))

            await syncMeasurementToCloudKit(measurement)
        }

        onSyncStatusChange?(.success)
    }

    /// Fetch changes from CloudKit and merge with local data
    func fetchFromCloudKit(since date: Date? = nil) async throws {
        guard let cloudKit = cloudKitManager else {
            throw RepositoryError.cloudKitUnavailable
        }

        onSyncStatusChange?(.syncing(progress: 0.0))

        do {
            let remoteMeasurements = try await cloudKit.fetchMeasurements(since: date)

            for measurement in remoteMeasurements {
                await mergeRemoteMeasurement(measurement)
            }

            onSyncStatusChange?(.success)
        } catch let error as CKError {
            onSyncError?(adaptCloudKitError(error))
            throw adaptCloudKitError(error)
        }
    }

    /// Perform full bidirectional sync
    func performFullSync() async throws {
        guard let cloudKit = cloudKitManager else {
            throw RepositoryError.cloudKitUnavailable
        }

        onSyncStatusChange?(.syncing(progress: 0.0))

        // Step 1: Push pending local changes
        try await syncPendingMeasurements()

        // Step 2: Pull remote changes
        if let lastSync = cloudKit.lastSyncDate {
            try await fetchFromCloudKit(since: lastSync)
        } else {
            try await fetchFromCloudKit()
        }

        onSyncStatusChange?(.success)
    }

    /// Check CloudKit account status
    func checkCloudKitStatus() async throws -> CloudKitAccountStatus {
        guard let cloudKit = cloudKitManager else {
            throw RepositoryError.cloudKitUnavailable
        }

        return try await cloudKit.checkAccountStatus()
    }

    // MARK: - Private Helper Methods

    private func syncMeasurementToCloudKit(_ measurement: StressMeasurement) async {
        guard let cloudKit = cloudKitManager else { return }

        do {
            try await cloudKit.saveMeasurement(measurement)

            // Update measurement with CloudKit metadata
            measurement.isSynced = true
            measurement.cloudKitModTime = Date()

            // Generate record name if not exists
            if measurement.cloudKitRecordName == nil {
                measurement.cloudKitRecordName = generateRecordName(for: measurement)
            }

            try modelContext.save()
        } catch {
            onSyncError?(error)
            measurement.isSynced = false
        }
    }

    private func syncBatchToCloudKit(_ measurements: [StressMeasurement]) async {
        guard let cloudKit = cloudKitManager else { return }

        onSyncStatusChange?(.syncing(progress: 0.0))

        for (index, measurement) in measurements.enumerated() {
            let progress = Double(index) / Double(measurements.count)
            onSyncStatusChange?(.syncing(progress: progress))

            await syncMeasurementToCloudKit(measurement)
        }

        onSyncStatusChange?(.success)
    }

    private func mergeRemoteMeasurement(_ remote: StressMeasurement) async {
        // Check if local version exists - fetch all and filter in Swift
        // This is more reliable than complex predicates
        let descriptor = FetchDescriptor<StressMeasurement>()

        do {
            let allMeasurements = try modelContext.fetch(descriptor)
            let existing = allMeasurements.filter { 
                $0.timestamp == remote.timestamp && $0.deviceID == remote.deviceID 
            }

            if let local = existing.first {
                // Conflict resolution: Use most recent modification time
                if let remoteModTime = remote.cloudKitModTime,
                   let localModTime = local.cloudKitModTime,
                   remoteModTime > localModTime {
                    // Remote is newer - update local
                    local.stressLevel = remote.stressLevel
                    local.hrv = remote.hrv
                    local.restingHeartRate = remote.restingHeartRate
                    local.categoryRawValue = remote.categoryRawValue
                    local.confidences = remote.confidences
                    local.isSynced = true
                    local.cloudKitModTime = remote.cloudKitModTime
                    local.cloudKitRecordName = remote.cloudKitRecordName
                }
            } else {
                // No local version - insert remote
                modelContext.insert(remote)
                remote.isSynced = true
            }

            try modelContext.save()
        } catch {
            onSyncError?(error)
        }
    }

    private func generateRecordName(for measurement: StressMeasurement) -> String {
        "measurement-\(measurement.timestamp.timeIntervalSince1970)-\(measurement.deviceID)"
    }

    private func adaptCloudKitError(_ error: CKError) -> CloudKitError {
        switch error.code {
        case .networkFailure, .networkUnavailable:
            return .networkUnavailable(.noInternet)
        case .notAuthenticated:
            return .networkUnavailable(.iCloudNotSignedIn)
        case .quotaExceeded:
            return .networkUnavailable(.quotaExceeded)
        case .requestRateLimited:
            return .rateLimited
        case .zoneNotFound:
            return .zoneNotFound
        case .unknownItem:
            return .recordNotFound
        default:
            return .unknown(error)
        }
    }
}

// MARK: - Repository Errors

public enum RepositoryError: Error, Sendable {
    case saveFailed(Error)
    case deleteFailed(Error)
    case cloudKitUnavailable
    case syncFailed(Error)

    public var localizedDescription: String {
        switch self {
        case .saveFailed(let error):
            return "Failed to save measurement: \(error.localizedDescription)"
        case .deleteFailed(let error):
            return "Failed to delete measurement: \(error.localizedDescription)"
        case .cloudKitUnavailable:
            return "CloudKit is not available"
        case .syncFailed(let error):
            return "Sync failed: \(error.localizedDescription)"
        }
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/MainTabView.swift">
import SwiftUI
import SwiftData

struct MainTabView: View {
    @Environment(\.modelContext) private var modelContext

    /// Enable mock data mode for development/simulator testing
    /// Set to true to see sample data without real HealthKit data
    static var useMockData: Bool = {
        #if DEBUG
        return ProcessInfo.processInfo.environment["XCODE_RUNNING_FOR_PREVIEWS"] != "1"
        #else
        return false
        #endif
    }()

    var body: some View {
        TabView {
            if Self.useMockData {
                DashboardView(viewModel: PreviewDataFactory.mockDashboardViewModel())
                    .tabItem {
                        Label("Now", systemImage: "heart.fill")
                    }
                    .accessibilityIdentifier("DashboardTab")
                    .accessibilityLabel("Current stress level")
                    .accessibilityHint("View your current stress measurement")
            } else {
                DashboardView(repository: StressRepository(modelContext: modelContext))
                    .tabItem {
                        Label("Now", systemImage: "heart.fill")
                    }
                    .accessibilityIdentifier("DashboardTab")
                    .accessibilityLabel("Current stress level")
                    .accessibilityHint("View your current stress measurement")
            }

            MeasurementHistoryView()
                .tabItem {
                    Label("History", systemImage: "chart.bar")
                }
                .accessibilityIdentifier("HistoryTab")
                .accessibilityLabel("Stress history")
                .accessibilityHint("View past stress measurements")

            TrendsView()
                .tabItem {
                    Label("Trends", systemImage: "chart.xyaxis.line")
                }
                .accessibilityIdentifier("TrendsTab")
                .accessibilityLabel("Trends and patterns")
                .accessibilityHint("View your stress trends over time")

            SettingsView()
                .tabItem {
                    Label("Settings", systemImage: "gear")
                }
                .accessibilityIdentifier("SettingsTab")
                .accessibilityLabel("Settings")
                .accessibilityHint("Configure app settings")
        }
        .tint(.accentColor)
    }
}

#Preview {
    MainTabView()
        .modelContainer(for: StressMeasurement.self, inMemory: true)
}
</file>

<file path="StressMonitor/StressMonitor/StressMonitorApp.swift">
import SwiftData
import SwiftUI

@main
struct StressMonitorApp: App {
  static let schema = Schema([
    StressMeasurement.self
  ])

  static let modelConfiguration = ModelConfiguration(
    schema: schema,
    isStoredInMemoryOnly: false
  )

  var sharedModelContainer: ModelContainer = {
    do {
      return try ModelContainer(for: schema, configurations: [modelConfiguration])
    } catch {
      fatalError("Could not create ModelContainer: \(error)")
    }
  }()

  var body: some Scene {
    WindowGroup {
      MainTabView()
        .task {
          await initializeServices()
        }
    }
    .modelContainer(sharedModelContainer)
  }

  @MainActor
  private func initializeServices() async {
    let context = sharedModelContainer.mainContext

    PhoneConnectivityManager.shared.setModelContext(context)

    try? await NotificationManager.shared.requestAuthorization()
  }
}
</file>

<file path="StressMonitor/StressMonitorTests/StressViewModelTests.swift">
import XCTest
import SwiftData
@testable import StressMonitor

@MainActor
final class StressViewModelTests: XCTestCase {

    var viewModel: StressViewModel!
    var mockHealthKit: MockHealthKitService!
    var mockAlgorithm: MockStressAlgorithmService!
    var mockRepository: MockStressViewModelRepository!

    override func setUp() async throws {
        mockHealthKit = MockHealthKitService()
        mockAlgorithm = MockStressAlgorithmService()
        mockRepository = MockStressViewModelRepository()

        viewModel = StressViewModel(
            healthKit: mockHealthKit,
            algorithm: mockAlgorithm,
            repository: mockRepository
        )
    }

    override func tearDown() async throws {
        viewModel = nil
        mockHealthKit = nil
        mockAlgorithm = nil
        mockRepository = nil
    }

    // MARK: - loadCurrentStress Tests

    func testLoadCurrentStressSuccess() async throws {
        mockHealthKit.hrvToReturn = HRVMeasurement(value: 50)
        mockHealthKit.heartRatesToReturn = [HeartRateSample(value: 70)]
        mockAlgorithm.stressToReturn = StressResult(
            level: 30,
            category: .mild,
            confidence: 0.9,
            hrv: 50,
            heartRate: 70
        )

        await viewModel.loadCurrentStress()

        XCTAssertNotNil(viewModel.currentStress)
        XCTAssertEqual(viewModel.currentStress?.level, 30)
        XCTAssertNil(viewModel.errorMessage)
        XCTAssertNotNil(viewModel.lastRefresh)
        XCTAssertFalse(viewModel.isLoading)
    }

    func testLoadCurrentStressNoHRVData() async {
        mockHealthKit.hrvToReturn = nil

        await viewModel.loadCurrentStress()

        XCTAssertNil(viewModel.currentStress)
        XCTAssertNotNil(viewModel.errorMessage)
        XCTAssertFalse(viewModel.isLoading)
    }

    func testLoadCurrentStressSetsLoadingState() async {
        mockHealthKit.hrvToReturn = HRVMeasurement(value: 50)
        mockHealthKit.heartRatesToReturn = [HeartRateSample(value: 70)]
        mockAlgorithm.stressToReturn = StressResult(
            level: 30,
            category: .mild,
            confidence: 0.9,
            hrv: 50,
            heartRate: 70
        )

        // Verify initial state
        XCTAssertFalse(viewModel.isLoading, "Initial state should not be loading")

        // Run the operation
        await viewModel.loadCurrentStress()

        // Verify final state is not loading (important invariant)
        XCTAssertFalse(viewModel.isLoading, "Loading state should be false after operation completes")
    }

    // MARK: - loadHistoricalData Tests

    func testLoadHistoricalData() async throws {
        let measurements = [
            StressMeasurement(timestamp: Date(), stressLevel: 30, hrv: 50, restingHeartRate: 70),
            StressMeasurement(timestamp: Date(), stressLevel: 50, hrv: 45, restingHeartRate: 80)
        ]
        mockRepository.measurementsToReturn = measurements

        await viewModel.loadHistoricalData(days: 7)

        XCTAssertEqual(viewModel.historicalData.count, 2)
        XCTAssertNil(viewModel.errorMessage)
    }

    // MARK: - loadBaseline Tests

    func testLoadBaseline() async throws {
        let baseline = PersonalBaseline(restingHeartRate: 55, baselineHRV: 48)
        mockRepository.baselineToReturn = baseline

        await viewModel.loadBaseline()

        XCTAssertEqual(viewModel.baseline?.restingHeartRate, 55)
        XCTAssertEqual(viewModel.baseline?.baselineHRV, 48)
        XCTAssertNil(viewModel.errorMessage)
    }

    // MARK: - clearError Tests

    func testClearError() {
        viewModel.errorMessage = "Test error"
        viewModel.clearError()

        XCTAssertNil(viewModel.errorMessage)
    }

    // MARK: - calculateAndSaveStress Tests

    func testCalculateAndSaveStress() async throws {
        mockHealthKit.hrvToReturn = HRVMeasurement(value: 50)
        mockHealthKit.heartRatesToReturn = [HeartRateSample(value: 70)]
        mockAlgorithm.stressToReturn = StressResult(
            level: 30,
            category: .mild,
            confidence: 0.9,
            hrv: 50,
            heartRate: 70
        )

        try await viewModel.calculateAndSaveStress()

        XCTAssertNotNil(viewModel.currentStress)
        XCTAssertTrue(mockRepository.saveWasCalled)
    }
}

// MARK: - Mocks

final class MockHealthKitService: HealthKitServiceProtocol {
    var hrvToReturn: HRVMeasurement?
    var heartRatesToReturn: [HeartRateSample] = []

    func requestAuthorization() async throws {
    }

    func fetchLatestHRV() async throws -> HRVMeasurement? {
        hrvToReturn
    }

    func fetchHeartRate(samples: Int) async throws -> [HeartRateSample] {
        heartRatesToReturn
    }

    func fetchHRVHistory(since: Date) async throws -> [HRVMeasurement] {
        []
    }

    func observeHeartRateUpdates() -> AsyncStream<HeartRateSample?> {
        AsyncStream { _ in }
    }
}

final class MockStressAlgorithmService: StressAlgorithmServiceProtocol {
    var stressToReturn: StressResult?

    func calculateStress(hrv: Double, heartRate: Double) async throws -> StressResult {
        stressToReturn ?? StressResult(level: 0, category: .relaxed, confidence: 1, hrv: hrv, heartRate: heartRate)
    }

    func calculateConfidence(hrv: Double, heartRate: Double, samples: Int) -> Double {
        1.0
    }
}

final class MockStressViewModelRepository: StressRepositoryProtocol {
    var measurementsToReturn: [StressMeasurement] = []
    var baselineToReturn: PersonalBaseline?
    var saveWasCalled = false

    func save(_ measurement: StressMeasurement) async throws {
        saveWasCalled = true
    }

    func fetchRecent(limit: Int) async throws -> [StressMeasurement] {
        measurementsToReturn
    }

    func fetchAll() async throws -> [StressMeasurement] {
        measurementsToReturn
    }

    func deleteOlderThan(_ date: Date) async throws {
    }

    func getBaseline() async throws -> PersonalBaseline {
        baselineToReturn ?? PersonalBaseline()
    }

    func updateBaseline(_ baseline: PersonalBaseline) async throws {
    }

    func fetchMeasurements(from: Date, to: Date) async throws -> [StressMeasurement] {
        return measurementsToReturn
    }

    func delete(_ measurement: StressMeasurement) async throws {}

    func fetchAverageHRV(hours: Int) async throws -> Double {
        return 0.0
    }

    func fetchAverageHRV(days: Int) async throws -> Double {
        return 0.0
    }

    func deleteAllMeasurements() async throws {}
}
</file>

<file path="StressMonitor/StressMonitor/Theme/Color+Extensions.swift">
import SwiftUI

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3:
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6:
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8:
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }

    init(light: Color, dark: Color) {
        self.init(uiColor: UIColor { traitCollection in
            traitCollection.userInterfaceStyle == .dark ? UIColor(dark) : UIColor(light)
        })
    }

    // MARK: - Stress Level Colors

    static let stressRelaxed = Color(light: Color(hex: "#34C759"), dark: Color(hex: "#30D158"))
    static let stressMild = Color(light: Color(hex: "#007AFF"), dark: Color(hex: "#0A84FF"))
    static let stressModerate = Color(hex: "#FFD60A")
    static let stressHigh = Color(light: Color(hex: "#FF9500"), dark: Color(hex: "#FF9F0A"))
    static let stressSevere = Color(light: Color(hex: "#FF3B30"), dark: Color(hex: "#FF453A"))

    // MARK: - Semantic Colors

    static let primaryBlue = Color(light: Color(hex: "#007AFF"), dark: Color(hex: "#0A84FF"))
    static let primaryGreen = Color(light: Color(hex: "#34C759"), dark: Color(hex: "#30D158"))
    static let success = Color(light: Color(hex: "#34C759"), dark: Color(hex: "#30D158"))
    static let warning = Color(hex: "#FFB00A")
    static let error = Color(light: Color(hex: "#FF3B30"), dark: Color(hex: "#FF453A"))

    // MARK: - Light Mode Colors

    static let backgroundLight = Color(hex: "#F2F2F7")
    static let surfaceLight = Color.white
    static let cardLight = Color.white
    static let textPrimaryLight = Color.black
    static let textSecondaryLight = Color(hex: "#8E8E93")
    static let dividerLight = Color(hex: "#C6C6C8")

    // MARK: - Dark Mode Colors

    static let backgroundDark = Color.black
    static let surfaceDark = Color(hex: "#1C1C1E")
    static let cardDark = Color(hex: "#1C1C1E")
    static let textPrimaryDark = Color.white
    static let textSecondaryDark = Color(hex: "#EBEBF5")
    static let dividerDark = Color(hex: "#38383A")

    // MARK: - OLED Dark Mode Colors

    /// Deep dark background for OLED displays - #121212
    static let oledBackground = Color(hex: "#121212")
    /// Card background for OLED dark theme - #1E1E1E
    static let oledCardBackground = Color(hex: "#1E1E1E")
    /// Secondary card background for OLED - #2A2A2A
    static let oledCardSecondary = Color(hex: "#2A2A2A")
    /// Secondary text color for OLED - #9CA3AF
    static let oledTextSecondary = Color(hex: "#9CA3AF")

    // MARK: - Accent Colors

    /// HRV accent color (green-teal)
    static let hrvAccent = Color(hex: "#34D399")
    /// Heart rate accent color (red-pink)
    static let heartRateAccent = Color(hex: "#F87171")

    // MARK: - Color Helpers

    static func stressColor(for level: Double) -> Color {
        switch level {
        case 0...25: return .stressRelaxed
        case 26...50: return .stressMild
        case 51...75: return .stressModerate
        case 76...100: return .stressHigh
        default: return .secondary
        }
    }

    static func stressColor(for category: StressCategory) -> Color {
        // Delegate to StressCategory as single source of truth
        return category.color
    }

    static func stressIcon(for category: StressCategory) -> String {
        // Delegate to StressCategory as single source of truth
        return category.icon
    }
}
</file>

<file path="StressMonitor/StressMonitor/Views/DashboardView.swift">
import SwiftUI
import SwiftData

struct DashboardView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: StressViewModel
    @State private var appeared = false
    @State private var appearAnimation = false

    init(viewModel: StressViewModel? = nil, repository: StressRepository? = nil) {
        if let viewModel = viewModel {
            _viewModel = State(initialValue: viewModel)
        } else if let repository = repository {
            _viewModel = State(initialValue: StressViewModel(
                healthKit: HealthKitManager(),
                algorithm: StressCalculator(),
                repository: repository
            ))
        } else {
            // Fallback with in-memory container for previews
            _viewModel = State(initialValue: StressViewModel(
                healthKit: HealthKitManager(),
                algorithm: StressCalculator(),
                repository: StressRepository(modelContext: ModelContext(try! ModelContainer(for: StressMeasurement.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))))
            ))
        }
    }

    var body: some View {
        NavigationStack {
            Group {
                if viewModel.isLoading && viewModel.currentStress == nil {
                    loadingView
                } else if let stress = viewModel.currentStress {
                    content(stress)
                } else {
                    emptyState
                }
            }
            .navigationTitle("Dashboard")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button {
                        Task { await viewModel.loadDashboardData() }
                    } label: {
                        Image(systemName: "arrow.clockwise")
                            .foregroundStyle(Color.primaryBlue)
                    }
                }
            }
            .alert("Error", isPresented: .constant(viewModel.errorMessage != nil)) {
                Button("OK") {
                    viewModel.clearError()
                }
            } message: {
                if let error = viewModel.errorMessage {
                    Text(error)
                }
            }
        }
        .task {
            if !appeared {
                appeared = true
                await loadInitialData()
                viewModel.startAutoRefresh()
            }
        }
        .onDisappear {
            viewModel.stopAutoRefresh()
        }
    }

    private func loadInitialData() async {
        await viewModel.loadDashboardData()
        await viewModel.loadBaseline()
        viewModel.observeHeartRate()

        withAnimation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.1)) {
            appearAnimation = true
        }
    }

    private var loadingView: some View {
        VStack(spacing: DesignTokens.Spacing.lg) {
            ProgressView()
                .scaleEffect(1.5)

            Text("Loading stress data...")
                .font(.system(size: DesignTokens.Typography.body))
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.Wellness.adaptiveBackground)
    }

    // MARK: - Main Content

    private func content(_ stress: StressResult) -> some View {
        ScrollView {
            LazyVStack(spacing: 24) {
                // 1. Stress Character Card (includes date header, status, last updated)
                StressCharacterCard(result: stress, size: .dashboard) {
                    Task { await viewModel.loadDashboardData() }
                }
                .opacity(appearAnimation ? 1 : 0)
                .scaleEffect(appearAnimation ? 1 : 0.95)

                // 2. Insight Card
                if let insight = viewModel.aiInsight {
                    DashboardInsightCard(
                        title: "Today's Insight",
                        description: insight.message
                    )
                    .opacity(appearAnimation ? 1 : 0)
                }

                // 5. Triple Metric Row
                TripleMetricRow(
                    rhrValue: "\(Int(stress.heartRate))",
                    hrvValue: "\(Int(stress.hrv))",
                    rrValue: "14"
                )
                .opacity(appearAnimation ? 1 : 0)

                // 6. Self Note Card
                SelfNoteCard()
                    .opacity(appearAnimation ? 1 : 0)

                // 7. Your Health Data Section
                SectionHeader(title: "Your health data", icon: "heart.fill")
                    .opacity(appearAnimation ? 1 : 0)

                HealthDataSection()
                    .opacity(appearAnimation ? 1 : 0)

                // 8. Quick Action Section
                SectionHeader(title: "Quick Action", icon: "bolt.fill")
                    .opacity(appearAnimation ? 1 : 0)

                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        QuickActionCard.miniWalk()
                        QuickActionCard.boxBreathing()
                        QuickActionCard.gratitude()
                    }
                    .padding(.horizontal, 4)
                }
                .opacity(appearAnimation ? 1 : 0)

                // 9. Stress Over Time Section
                SectionHeader(title: "Stress over time", icon: "chart.bar.fill")
                    .opacity(appearAnimation ? 1 : 0)

                StressOverTimeChart()
                    .opacity(appearAnimation ? 1 : 0)

                // Bottom padding
                Spacer()
                    .frame(height: 32)
            }
            .padding()
        }
        .background(Color.Wellness.adaptiveBackground)
    }

    // MARK: - Empty State

    private var emptyState: some View {
        VStack(spacing: DesignTokens.Spacing.lg) {
            Image(systemName: "heart.slash")
                .font(.system(size: 60))
                .foregroundColor(Color.Wellness.adaptiveSecondaryText)
                .accessibilityHidden(true)

            Text("No stress data available")
                .font(.system(size: DesignTokens.Typography.headline, weight: .semibold))
                .foregroundStyle(Color.Wellness.adaptivePrimaryText)
                .accessibilityLabel("No stress data available")
                .accessibilityAddTraits(.isHeader)

            Text("Data will appear automatically when HealthKit has readings")
                .font(.system(size: DesignTokens.Typography.body))
                .foregroundStyle(Color.Wellness.adaptiveSecondaryText)
                .multilineTextAlignment(.center)
                .accessibilityLabel("Stress data will refresh automatically from HealthKit")
        }
        .padding(DesignTokens.Spacing.lg)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.Wellness.adaptiveBackground)
    }
}

// MARK: - Previews

#Preview("Dashboard - With Mock Data") {
    let viewModel = PreviewDataFactory.mockDashboardViewModel()
    DashboardView(viewModel: viewModel)
}

#Preview("Dashboard - Empty State") {
    DashboardView()
}

#Preview("Dashboard - Dark Mode") {
    let viewModel = PreviewDataFactory.mockDashboardViewModel()
    DashboardView(viewModel: viewModel)
        .preferredColorScheme(.dark)
}
</file>

</files>
